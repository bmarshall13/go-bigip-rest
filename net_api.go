/*
 * BigIP iControl REST
 *
 * REST API for F5 BigIP. List of operations is not complete, nor known to be accurate.
 *
 * OpenAPI spec version: 12.0
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package f5api

import (
	"fmt"
	"net/url"
	"strings"

	"encoding/json"
)

// This class holds all the API methods for the Net API sub tree
type NetApi struct {
	configuration *configuration
}

func unused_import_hack_NetApi() {
	strings.Replace("a", "a", fmt.Sprintf("%v", nil), -1)
}

// DeleteArp
//
//
// Manage the Address Resolution Protocol (ARP) table.
//
// id is for ID of the resource.
func (a NetApi) DeleteArp(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/arp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteBwcPolicy
//
//
// Bandwidth control policy for traffic flow..
//
// id is for ID of the resource.
func (a NetApi) DeleteBwcPolicy(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/policy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteBwcPriorityGroup
//
//
// Bandwidth traffic group for bandwidth policy traffic flows..
//
// id is for ID of the resource.
func (a NetApi) DeleteBwcPriorityGroup(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/priorityGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteBwcPriorityGroupPriorityClasses
//
//
// Bandwidth traffic classes in the bandwidth traffic group..
//
// id is for ID of the resource.
func (a NetApi) DeleteBwcPriorityGroupPriorityClasses(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/priorityGroup/priorityClasses/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteBwcProbe
//
//
// .
//
// id is for ID of the resource.
func (a NetApi) DeleteBwcProbe(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/probe/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteCmetrics
//
//
// Route metrics table display.
//
// id is for ID of the resource.
func (a NetApi) DeleteCmetrics(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cmetrics/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteCosMap8021p
//
//
// Configures vlan 8021.p tag to traffic priority mapping..
//
// id is for ID of the resource.
func (a NetApi) DeleteCosMap8021p(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/map_8021p/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteCosMapDscp
//
//
// Configures IP DSCP field to traffic priority mapping..
//
// id is for ID of the resource.
func (a NetApi) DeleteCosMapDscp(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/mapDscp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteCosTrafficPriority
//
//
// Configures a traffic priority object..
//
// id is for ID of the resource.
func (a NetApi) DeleteCosTrafficPriority(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/trafficPriority/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteDnsResolver
//
//
// DNS Resolver object..
//
// id is for ID of the resource.
func (a NetApi) DeleteDnsResolver(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/dnsResolver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteFdbTunnel
//
//
// Tunnel forwarding database configuration and status.
//
// id is for ID of the resource.
func (a NetApi) DeleteFdbTunnel(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/fdb/tunnel/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteFdbTunnelRecords
//
//
// .
//
// id is for ID of the resource.
func (a NetApi) DeleteFdbTunnelRecords(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/fdb/tunnel/records/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteFdbVlan
//
//
// VLAN forwarding database configuration and status.
//
// id is for ID of the resource.
func (a NetApi) DeleteFdbVlan(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/fdb/vlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteIpsecIkePeer
//
//
// Specifies IKE phase 1 parameters for remote ike peers..
//
// id is for ID of the resource.
func (a NetApi) DeleteIpsecIkePeer(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ikePeer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteIpsecIkeSa
//
//
// Displays IKE security associations.
//
// id is for ID of the resource.
func (a NetApi) DeleteIpsecIkeSa(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ikeSa/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteIpsecIpsecPolicy
//
//
// Configure IPsec security policy..
//
// id is for ID of the resource.
func (a NetApi) DeleteIpsecIpsecPolicy(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ipsecPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteIpsecIpsecSa
//
//
// Displays IPsec security associations.
//
// id is for ID of the resource.
func (a NetApi) DeleteIpsecIpsecSa(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ipsecSa/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteIpsecManualSecurityAssociation
//
//
// Specifies manually configured Security Association parameters..
//
// id is for ID of the resource.
func (a NetApi) DeleteIpsecManualSecurityAssociation(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/manualSecurityAssociation/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteIpsecTrafficSelector
//
//
// Traffic Selector configuration..
//
// id is for ID of the resource.
func (a NetApi) DeleteIpsecTrafficSelector(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/trafficSelector/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteNdp
//
//
// Manage the IPv6 Neighbor Discovery Protocol (NDP) table..
//
// id is for ID of the resource.
func (a NetApi) DeleteNdp(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ndp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeletePacketFilter
//
//
// Packet filter configuration.
//
// id is for ID of the resource.
func (a NetApi) DeletePacketFilter(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/packetFilter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeletePortMirror
//
//
// Interface port mirroring configuration.
//
// id is for ID of the resource.
func (a NetApi) DeletePortMirror(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/portMirror/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteRateShapingColorPolicer
//
//
// Color based policer configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteRateShapingColorPolicer(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/colorPolicer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteRateShapingDropPolicy
//
//
// Drop policy configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteRateShapingDropPolicy(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/dropPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteRateShapingQueue
//
//
// Queuing method configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteRateShapingQueue(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/queue/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteRateShapingShapingPolicy
//
//
// Shaping policy configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteRateShapingShapingPolicy(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/shapingPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteRateShapingTmClass
//
//
// Rate class configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteRateShapingTmClass(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/tmClass/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteRoute
//
//
// Routing tables and configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteRoute(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/route/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteRouteDomain
//
//
// Route domain configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteRouteDomain(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routeDomain/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteRouterAdvertisement
//
//
// Configures IPv6 prefixes for router advertisement on a VLAN..
//
// id is for ID of the resource.
func (a NetApi) DeleteRouterAdvertisement(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routerAdvertisement/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteRouterAdvertisementPrefixes
//
//
// .
//
// id is for ID of the resource.
func (a NetApi) DeleteRouterAdvertisementPrefixes(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routerAdvertisement/prefixes/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteSelf
//
//
// Self-IP address configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteSelf(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/self/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteServicePolicy
//
//
// Service Policy configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteServicePolicy(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/servicePolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteStp
//
//
// STP configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteStp(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/stp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteTimerPolicy
//
//
// Timer Policy configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteTimerPolicy(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/timerPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteTrunk
//
//
// Trunk configuration and statistics.
//
// id is for ID of the resource.
func (a NetApi) DeleteTrunk(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/trunk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteTunnelsEtherip
//
//
// EtherIP tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteTunnelsEtherip(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/etherip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteTunnelsFec
//
//
// FEC tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteTunnelsFec(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/fec/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteTunnelsGeneve
//
//
// Geneve tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteTunnelsGeneve(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/geneve/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteTunnelsGre
//
//
// GRE tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteTunnelsGre(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/gre/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteTunnelsIpip
//
//
// IPIP tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteTunnelsIpip(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/ipip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteTunnelsIpsec
//
//
// IPSEC tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteTunnelsIpsec(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/ipsec/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteTunnelsMap
//
//
// MAP tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteTunnelsMap(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/map/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteTunnelsPpp
//
//
// PPP tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteTunnelsPpp(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/ppp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteTunnelsTcpForward
//
//
// .
//
// id is for ID of the resource.
func (a NetApi) DeleteTunnelsTcpForward(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/tcpForward/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteTunnelsTunnel
//
//
// Tunnel configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteTunnelsTunnel(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/tunnel/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteTunnelsV6rd
//
//
// 6RD tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteTunnelsV6rd(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/v6rd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteTunnelsVxlan
//
//
// VXLAN tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteTunnelsVxlan(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/vxlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteTunnelsWccp
//
//
// WCCP tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteTunnelsWccp(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/wccp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteVlan
//
//
// VLAN configuration and statistics.
//
// id is for ID of the resource.
func (a NetApi) DeleteVlan(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/vlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteVlanGroup
//
//
// VLAN group configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteVlanGroup(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/vlanGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteVlanInterfaces
//
//
// Specifies which interfaces you want this VLAN to use for traffic management..
//
// id is for ID of the resource.
func (a NetApi) DeleteVlanInterfaces(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/vlan/interfaces/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteWccp
//
//
// WCCP configuration.
//
// id is for ID of the resource.
func (a NetApi) DeleteWccp(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/wccp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteWccpServices
//
//
// .
//
// id is for ID of the resource.
func (a NetApi) DeleteWccpServices(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/wccp/services/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// GetArp
//
//
// Manage the Address Resolution Protocol (ARP) table.
//
// id is for ID of the resource.
func (a NetApi) GetArp(id string) (*NetArp, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/arp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetArp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetArpList
//
//
// Manage the Address Resolution Protocol (ARP) table..
func (a NetApi) GetArpList() (*NetArpList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/arp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetArpList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetBwc
//
//
// Bandwidth related configuration.
//
// id is for ID of the resource.
func (a NetApi) GetBwc(id string) (*NetBwc, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwc)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetBwcList
//
//
// Bandwidth related configuration..
func (a NetApi) GetBwcList() (*NetBwcList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwcList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetBwcPolicy
//
//
// Bandwidth control policy for traffic flow..
//
// id is for ID of the resource.
func (a NetApi) GetBwcPolicy(id string) (*NetBwcPolicy, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/policy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwcPolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetBwcPolicyList
//
//
// Bandwidth control policy for traffic flow...
func (a NetApi) GetBwcPolicyList() (*NetBwcPolicyList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/policy"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwcPolicyList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetBwcPriorityGroup
//
//
// Bandwidth traffic group for bandwidth policy traffic flows..
//
// id is for ID of the resource.
func (a NetApi) GetBwcPriorityGroup(id string) (*NetBwcPriorityGroup, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/priorityGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwcPriorityGroup)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetBwcPriorityGroupList
//
//
// Bandwidth traffic group for bandwidth policy traffic flows...
func (a NetApi) GetBwcPriorityGroupList() (*NetBwcPriorityGroupList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/priorityGroup"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwcPriorityGroupList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetBwcPriorityGroupPriorityClasses
//
//
// Bandwidth traffic classes in the bandwidth traffic group..
//
// id is for ID of the resource.
func (a NetApi) GetBwcPriorityGroupPriorityClasses(id string) (*NetBwcPriorityGroupPriorityClasses, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/priorityGroup/priorityClasses/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwcPriorityGroupPriorityClasses)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetBwcPriorityGroupPriorityClassesList
//
//
// Bandwidth traffic classes in the bandwidth traffic group...
func (a NetApi) GetBwcPriorityGroupPriorityClassesList() (*NetBwcPriorityGroupPriorityClassesList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/priorityGroup/priorityClasses"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwcPriorityGroupPriorityClassesList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetBwcProbe
//
//
// .
//
// id is for ID of the resource.
func (a NetApi) GetBwcProbe(id string) (*NetBwcProbe, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/probe/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwcProbe)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetBwcProbeList
//
//
// ..
func (a NetApi) GetBwcProbeList() (*NetBwcProbeList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/probe"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwcProbeList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCmetrics
//
//
// Route metrics table display.
//
// id is for ID of the resource.
func (a NetApi) GetCmetrics(id string) (*NetCmetrics, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cmetrics/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCmetrics)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCmetricsList
//
//
// Route metrics table display..
func (a NetApi) GetCmetricsList() (*NetCmetricsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cmetrics"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCmetricsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCos
//
//
// Class of Service related configuration.
//
// id is for ID of the resource.
func (a NetApi) GetCos(id string) (*NetCos, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCos)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCosGlobalSettings
//
//
// Configures the global configuration for class of service..
//
// id is for ID of the resource.
func (a NetApi) GetCosGlobalSettings(id string) (*NetCosGlobalSettings, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/globalSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCosGlobalSettings)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCosGlobalSettingsList
//
//
// Configures the global configuration for class of service...
func (a NetApi) GetCosGlobalSettingsList() (*NetCosGlobalSettingsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/globalSettings"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCosGlobalSettingsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCosList
//
//
// Class of Service related configuration..
func (a NetApi) GetCosList() (*NetCosList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCosList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCosMap8021p
//
//
// Configures vlan 8021.p tag to traffic priority mapping..
//
// id is for ID of the resource.
func (a NetApi) GetCosMap8021p(id string) (*NetCosMap8021p, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/map_8021p/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCosMap8021p)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCosMap8021pList
//
//
// Configures vlan 8021.p tag to traffic priority mapping...
func (a NetApi) GetCosMap8021pList() (*NetCosMap8021pList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/map_8021p"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCosMap8021pList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCosMapDscp
//
//
// Configures IP DSCP field to traffic priority mapping..
//
// id is for ID of the resource.
func (a NetApi) GetCosMapDscp(id string) (*NetCosMapDscp, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/mapDscp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCosMapDscp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCosMapDscpList
//
//
// Configures IP DSCP field to traffic priority mapping...
func (a NetApi) GetCosMapDscpList() (*NetCosMapDscpList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/mapDscp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCosMapDscpList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCosTrafficPriority
//
//
// Configures a traffic priority object..
//
// id is for ID of the resource.
func (a NetApi) GetCosTrafficPriority(id string) (*NetCosTrafficPriority, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/trafficPriority/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCosTrafficPriority)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCosTrafficPriorityList
//
//
// Configures a traffic priority object...
func (a NetApi) GetCosTrafficPriorityList() (*NetCosTrafficPriorityList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/trafficPriority"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCosTrafficPriorityList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDagGlobals
//
//
// Global disaggregation settings.
//
// id is for ID of the resource.
func (a NetApi) GetDagGlobals(id string) (*NetDagGlobals, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/dagGlobals/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetDagGlobals)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDagGlobalsList
//
//
// Global disaggregation settings..
func (a NetApi) GetDagGlobalsList() (*NetDagGlobalsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/dagGlobals"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetDagGlobalsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDnsResolver
//
//
// DNS Resolver object..
//
// id is for ID of the resource.
func (a NetApi) GetDnsResolver(id string) (*NetDnsResolver, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/dnsResolver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetDnsResolver)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDnsResolverList
//
//
// DNS Resolver object...
func (a NetApi) GetDnsResolverList() (*NetDnsResolverList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/dnsResolver"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetDnsResolverList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFdb
//
//
// VLAN/Tunnel forwarding database configuration and status.
//
// id is for ID of the resource.
func (a NetApi) GetFdb(id string) (*NetFdb, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/fdb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetFdb)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFdbList
//
//
// VLAN/Tunnel forwarding database configuration and status..
func (a NetApi) GetFdbList() (*NetFdbList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/fdb"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetFdbList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFdbTunnel
//
//
// Tunnel forwarding database configuration and status.
//
// id is for ID of the resource.
func (a NetApi) GetFdbTunnel(id string) (*NetFdbTunnel, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/fdb/tunnel/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetFdbTunnel)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFdbTunnelList
//
//
// Tunnel forwarding database configuration and status..
func (a NetApi) GetFdbTunnelList() (*NetFdbTunnelList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/fdb/tunnel"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetFdbTunnelList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFdbTunnelRecords
//
//
// .
//
// id is for ID of the resource.
func (a NetApi) GetFdbTunnelRecords(id string) (*NetFdbTunnelRecords, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/fdb/tunnel/records/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetFdbTunnelRecords)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFdbTunnelRecordsList
//
//
// ..
func (a NetApi) GetFdbTunnelRecordsList() (*NetFdbTunnelRecordsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/fdb/tunnel/records"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetFdbTunnelRecordsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFdbVlan
//
//
// VLAN forwarding database configuration and status.
//
// id is for ID of the resource.
func (a NetApi) GetFdbVlan(id string) (*NetFdbVlan, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/fdb/vlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetFdbVlan)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFdbVlanList
//
//
// VLAN forwarding database configuration and status..
func (a NetApi) GetFdbVlanList() (*NetFdbVlanList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/fdb/vlan"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetFdbVlanList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIkeEvtStat
//
//
// .
//
// id is for ID of the resource.
func (a NetApi) GetIkeEvtStat(id string) (*NetIkeEvtStat, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ikeEvtStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIkeEvtStat)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIkeEvtStatList
//
//
// ..
func (a NetApi) GetIkeEvtStatList() (*NetIkeEvtStatList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ikeEvtStat"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIkeEvtStatList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIkeMsgStat
//
//
// .
//
// id is for ID of the resource.
func (a NetApi) GetIkeMsgStat(id string) (*NetIkeMsgStat, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ikeMsgStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIkeMsgStat)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIkeMsgStatList
//
//
// ..
func (a NetApi) GetIkeMsgStatList() (*NetIkeMsgStatList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ikeMsgStat"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIkeMsgStatList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetInterfaceCos
//
//
// Interface COS (Class of Service) related statistics.
//
// id is for ID of the resource.
func (a NetApi) GetInterfaceCos(id string) (*NetInterfaceCos, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/interfaceCos/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetInterfaceCos)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetInterfaceCosList
//
//
// Interface COS (Class of Service) related statistics..
func (a NetApi) GetInterfaceCosList() (*NetInterfaceCosList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/interfaceCos"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetInterfaceCosList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpsec
//
//
// IPsec configuration.
//
// id is for ID of the resource.
func (a NetApi) GetIpsec(id string) (*NetIpsec, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsec)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpsecIkeDaemon
//
//
// Configure global setting for ike agent..
//
// id is for ID of the resource.
func (a NetApi) GetIpsecIkeDaemon(id string) (*NetIpsecIkeDaemon, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ikeDaemon/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecIkeDaemon)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpsecIkeDaemonList
//
//
// Configure global setting for ike agent...
func (a NetApi) GetIpsecIkeDaemonList() (*NetIpsecIkeDaemonList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ikeDaemon"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecIkeDaemonList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpsecIkePeer
//
//
// Specifies IKE phase 1 parameters for remote ike peers..
//
// id is for ID of the resource.
func (a NetApi) GetIpsecIkePeer(id string) (*NetIpsecIkePeer, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ikePeer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecIkePeer)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpsecIkePeerList
//
//
// Specifies IKE phase 1 parameters for remote ike peers...
func (a NetApi) GetIpsecIkePeerList() (*NetIpsecIkePeerList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ikePeer"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecIkePeerList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpsecIkeSa
//
//
// Displays IKE security associations.
//
// id is for ID of the resource.
func (a NetApi) GetIpsecIkeSa(id string) (*NetIpsecIkeSa, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ikeSa/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecIkeSa)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpsecIkeSaList
//
//
// Displays IKE security associations..
func (a NetApi) GetIpsecIkeSaList() (*NetIpsecIkeSaList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ikeSa"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecIkeSaList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpsecIpsecPolicy
//
//
// Configure IPsec security policy..
//
// id is for ID of the resource.
func (a NetApi) GetIpsecIpsecPolicy(id string) (*NetIpsecIpsecPolicy, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ipsecPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecIpsecPolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpsecIpsecPolicyList
//
//
// Configure IPsec security policy...
func (a NetApi) GetIpsecIpsecPolicyList() (*NetIpsecIpsecPolicyList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ipsecPolicy"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecIpsecPolicyList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpsecIpsecSa
//
//
// Displays IPsec security associations.
//
// id is for ID of the resource.
func (a NetApi) GetIpsecIpsecSa(id string) (*NetIpsecIpsecSa, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ipsecSa/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecIpsecSa)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpsecIpsecSaList
//
//
// Displays IPsec security associations..
func (a NetApi) GetIpsecIpsecSaList() (*NetIpsecIpsecSaList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ipsecSa"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecIpsecSaList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpsecList
//
//
// IPsec configuration..
func (a NetApi) GetIpsecList() (*NetIpsecList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpsecManualSecurityAssociation
//
//
// Specifies manually configured Security Association parameters..
//
// id is for ID of the resource.
func (a NetApi) GetIpsecManualSecurityAssociation(id string) (*NetIpsecManualSecurityAssociation, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/manualSecurityAssociation/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecManualSecurityAssociation)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpsecManualSecurityAssociationList
//
//
// Specifies manually configured Security Association parameters...
func (a NetApi) GetIpsecManualSecurityAssociationList() (*NetIpsecManualSecurityAssociationList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/manualSecurityAssociation"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecManualSecurityAssociationList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpsecStat
//
//
// IPSec statistics.
//
// id is for ID of the resource.
func (a NetApi) GetIpsecStat(id string) (*NetIpsecStat, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsecStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecStat)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpsecStatList
//
//
// IPSec statistics..
func (a NetApi) GetIpsecStatList() (*NetIpsecStatList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsecStat"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecStatList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpsecTrafficSelector
//
//
// Traffic Selector configuration..
//
// id is for ID of the resource.
func (a NetApi) GetIpsecTrafficSelector(id string) (*NetIpsecTrafficSelector, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/trafficSelector/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecTrafficSelector)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpsecTrafficSelectorList
//
//
// Traffic Selector configuration...
func (a NetApi) GetIpsecTrafficSelectorList() (*NetIpsecTrafficSelectorList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/trafficSelector"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecTrafficSelectorList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLldpGlobals
//
//
// .
//
// id is for ID of the resource.
func (a NetApi) GetLldpGlobals(id string) (*NetLldpGlobals, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/lldpGlobals/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetLldpGlobals)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLldpGlobalsList
//
//
// ..
func (a NetApi) GetLldpGlobalsList() (*NetLldpGlobalsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/lldpGlobals"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetLldpGlobalsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLldpNeighbors
//
//
// .
//
// id is for ID of the resource.
func (a NetApi) GetLldpNeighbors(id string) (*NetLldpNeighbors, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/lldpNeighbors/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetLldpNeighbors)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLldpNeighborsList
//
//
// ..
func (a NetApi) GetLldpNeighborsList() (*NetLldpNeighborsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/lldpNeighbors"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetLldpNeighborsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetMroute
//
//
// Displays multicast routes.
//
// id is for ID of the resource.
func (a NetApi) GetMroute(id string) (*NetMroute, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/mroute/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetMroute)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetMrouteList
//
//
// Displays multicast routes..
func (a NetApi) GetMrouteList() (*NetMrouteList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/mroute"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetMrouteList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetMulticastGlobals
//
//
// Manage multicast traffic configuration options.
//
// id is for ID of the resource.
func (a NetApi) GetMulticastGlobals(id string) (*NetMulticastGlobals, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/multicastGlobals/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetMulticastGlobals)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetMulticastGlobalsList
//
//
// Manage multicast traffic configuration options..
func (a NetApi) GetMulticastGlobalsList() (*NetMulticastGlobalsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/multicastGlobals"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetMulticastGlobalsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetNdp
//
//
// Manage the IPv6 Neighbor Discovery Protocol (NDP) table..
//
// id is for ID of the resource.
func (a NetApi) GetNdp(id string) (*NetNdp, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ndp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetNdp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetNdpList
//
//
// Manage the IPv6 Neighbor Discovery Protocol (NDP) table...
func (a NetApi) GetNdpList() (*NetNdpList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ndp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetNdpList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPacketFilter
//
//
// Packet filter configuration.
//
// id is for ID of the resource.
func (a NetApi) GetPacketFilter(id string) (*NetPacketFilter, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/packetFilter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetPacketFilter)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPacketFilterList
//
//
// Packet filter configuration..
func (a NetApi) GetPacketFilterList() (*NetPacketFilterList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/packetFilter"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetPacketFilterList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPacketFilterTrusted
//
//
// Trusted entities that are exempt from packet filter rules.
//
// id is for ID of the resource.
func (a NetApi) GetPacketFilterTrusted(id string) (*NetPacketFilterTrusted, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/packetFilterTrusted/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetPacketFilterTrusted)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPacketFilterTrustedList
//
//
// Trusted entities that are exempt from packet filter rules..
func (a NetApi) GetPacketFilterTrustedList() (*NetPacketFilterTrustedList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/packetFilterTrusted"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetPacketFilterTrustedList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPortMirror
//
//
// Interface port mirroring configuration.
//
// id is for ID of the resource.
func (a NetApi) GetPortMirror(id string) (*NetPortMirror, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/portMirror/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetPortMirror)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPortMirrorList
//
//
// Interface port mirroring configuration..
func (a NetApi) GetPortMirrorList() (*NetPortMirrorList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/portMirror"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetPortMirrorList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRateShaping
//
//
// Rate shaping configuration.
//
// id is for ID of the resource.
func (a NetApi) GetRateShaping(id string) (*NetRateShaping, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShaping)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRateShapingColorPolicer
//
//
// Color based policer configuration.
//
// id is for ID of the resource.
func (a NetApi) GetRateShapingColorPolicer(id string) (*NetRateShapingColorPolicer, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/colorPolicer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingColorPolicer)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRateShapingColorPolicerList
//
//
// Color based policer configuration..
func (a NetApi) GetRateShapingColorPolicerList() (*NetRateShapingColorPolicerList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/colorPolicer"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingColorPolicerList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRateShapingDropPolicy
//
//
// Drop policy configuration.
//
// id is for ID of the resource.
func (a NetApi) GetRateShapingDropPolicy(id string) (*NetRateShapingDropPolicy, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/dropPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingDropPolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRateShapingDropPolicyList
//
//
// Drop policy configuration..
func (a NetApi) GetRateShapingDropPolicyList() (*NetRateShapingDropPolicyList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/dropPolicy"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingDropPolicyList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRateShapingList
//
//
// Rate shaping configuration..
func (a NetApi) GetRateShapingList() (*NetRateShapingList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRateShapingQueue
//
//
// Queuing method configuration.
//
// id is for ID of the resource.
func (a NetApi) GetRateShapingQueue(id string) (*NetRateShapingQueue, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/queue/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingQueue)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRateShapingQueueList
//
//
// Queuing method configuration..
func (a NetApi) GetRateShapingQueueList() (*NetRateShapingQueueList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/queue"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingQueueList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRateShapingShapingPolicy
//
//
// Shaping policy configuration.
//
// id is for ID of the resource.
func (a NetApi) GetRateShapingShapingPolicy(id string) (*NetRateShapingShapingPolicy, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/shapingPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingShapingPolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRateShapingShapingPolicyList
//
//
// Shaping policy configuration..
func (a NetApi) GetRateShapingShapingPolicyList() (*NetRateShapingShapingPolicyList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/shapingPolicy"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingShapingPolicyList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRateShapingTmClass
//
//
// Rate class configuration.
//
// id is for ID of the resource.
func (a NetApi) GetRateShapingTmClass(id string) (*NetRateShapingTmClass, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/tmClass/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingTmClass)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRateShapingTmClassList
//
//
// Rate class configuration..
func (a NetApi) GetRateShapingTmClassList() (*NetRateShapingTmClassList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/tmClass"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingTmClassList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRoute
//
//
// Routing tables and configuration.
//
// id is for ID of the resource.
func (a NetApi) GetRoute(id string) (*NetRoute, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/route/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRoute)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRouteDomain
//
//
// Route domain configuration.
//
// id is for ID of the resource.
func (a NetApi) GetRouteDomain(id string) (*NetRouteDomain, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routeDomain/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouteDomain)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRouteDomainFwActive
//
//
// Firewall policy rule entry.
//
// id is for ID of the resource.
func (a NetApi) GetRouteDomainFwActive(id string) (*NetRouteDomainFwActive, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routeDomain/fwActive/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouteDomainFwActive)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRouteDomainFwActiveList
//
//
// Firewall policy rule entry..
func (a NetApi) GetRouteDomainFwActiveList() (*NetRouteDomainFwActiveList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routeDomain/fwActive"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouteDomainFwActiveList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRouteDomainFwEnforcedPolicyRules
//
//
// Firewall policy rule entry.
//
// id is for ID of the resource.
func (a NetApi) GetRouteDomainFwEnforcedPolicyRules(id string) (*NetRouteDomainFwEnforcedPolicyRules, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routeDomain/fwEnforcedPolicyRules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouteDomainFwEnforcedPolicyRules)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRouteDomainFwEnforcedPolicyRulesList
//
//
// Firewall policy rule entry..
func (a NetApi) GetRouteDomainFwEnforcedPolicyRulesList() (*NetRouteDomainFwEnforcedPolicyRulesList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routeDomain/fwEnforcedPolicyRules"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouteDomainFwEnforcedPolicyRulesList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRouteDomainFwStagedPolicyRules
//
//
// Firewall policy rule entry.
//
// id is for ID of the resource.
func (a NetApi) GetRouteDomainFwStagedPolicyRules(id string) (*NetRouteDomainFwStagedPolicyRules, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routeDomain/fwStagedPolicyRules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouteDomainFwStagedPolicyRules)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRouteDomainFwStagedPolicyRulesList
//
//
// Firewall policy rule entry..
func (a NetApi) GetRouteDomainFwStagedPolicyRulesList() (*NetRouteDomainFwStagedPolicyRulesList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routeDomain/fwStagedPolicyRules"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouteDomainFwStagedPolicyRulesList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRouteDomainList
//
//
// Route domain configuration..
func (a NetApi) GetRouteDomainList() (*NetRouteDomainList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routeDomain"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouteDomainList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRouteList
//
//
// Routing tables and configuration..
func (a NetApi) GetRouteList() (*NetRouteList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/route"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouteList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRouterAdvertisement
//
//
// Configures IPv6 prefixes for router advertisement on a VLAN..
//
// id is for ID of the resource.
func (a NetApi) GetRouterAdvertisement(id string) (*NetRouterAdvertisement, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routerAdvertisement/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouterAdvertisement)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRouterAdvertisementList
//
//
// Configures IPv6 prefixes for router advertisement on a VLAN...
func (a NetApi) GetRouterAdvertisementList() (*NetRouterAdvertisementList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routerAdvertisement"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouterAdvertisementList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRouterAdvertisementPrefixes
//
//
// .
//
// id is for ID of the resource.
func (a NetApi) GetRouterAdvertisementPrefixes(id string) (*NetRouterAdvertisementPrefixes, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routerAdvertisement/prefixes/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouterAdvertisementPrefixes)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRouterAdvertisementPrefixesList
//
//
// ..
func (a NetApi) GetRouterAdvertisementPrefixesList() (*NetRouterAdvertisementPrefixesList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routerAdvertisement/prefixes"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouterAdvertisementPrefixesList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRstCause
//
//
// TCP/IP Reset Cause statistics..
//
// id is for ID of the resource.
func (a NetApi) GetRstCause(id string) (*NetRstCause, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rstCause/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRstCause)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRstCauseList
//
//
// TCP/IP Reset Cause statistics...
func (a NetApi) GetRstCauseList() (*NetRstCauseList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rstCause"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRstCauseList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSelf
//
//
// Self-IP address configuration.
//
// id is for ID of the resource.
func (a NetApi) GetSelf(id string) (*NetSelf, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/self/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetSelf)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSelfAllow
//
//
// The default set of protocol and ports allowed by a self IP.
//
// id is for ID of the resource.
func (a NetApi) GetSelfAllow(id string) (*NetSelfAllow, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/selfAllow/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetSelfAllow)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSelfAllowList
//
//
// The default set of protocol and ports allowed by a self IP..
func (a NetApi) GetSelfAllowList() (*NetSelfAllowList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/selfAllow"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetSelfAllowList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSelfFwActive
//
//
// Firewall policy rule entry.
//
// id is for ID of the resource.
func (a NetApi) GetSelfFwActive(id string) (*NetSelfFwActive, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/self/fwActive/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetSelfFwActive)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSelfFwActiveList
//
//
// Firewall policy rule entry..
func (a NetApi) GetSelfFwActiveList() (*NetSelfFwActiveList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/self/fwActive"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetSelfFwActiveList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSelfFwEnforcedPolicyRules
//
//
// Firewall policy rule entry.
//
// id is for ID of the resource.
func (a NetApi) GetSelfFwEnforcedPolicyRules(id string) (*NetSelfFwEnforcedPolicyRules, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/self/fwEnforcedPolicyRules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetSelfFwEnforcedPolicyRules)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSelfFwEnforcedPolicyRulesList
//
//
// Firewall policy rule entry..
func (a NetApi) GetSelfFwEnforcedPolicyRulesList() (*NetSelfFwEnforcedPolicyRulesList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/self/fwEnforcedPolicyRules"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetSelfFwEnforcedPolicyRulesList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSelfFwStagedPolicyRules
//
//
// Firewall policy rule entry.
//
// id is for ID of the resource.
func (a NetApi) GetSelfFwStagedPolicyRules(id string) (*NetSelfFwStagedPolicyRules, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/self/fwStagedPolicyRules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetSelfFwStagedPolicyRules)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSelfFwStagedPolicyRulesList
//
//
// Firewall policy rule entry..
func (a NetApi) GetSelfFwStagedPolicyRulesList() (*NetSelfFwStagedPolicyRulesList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/self/fwStagedPolicyRules"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetSelfFwStagedPolicyRulesList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSelfList
//
//
// Self-IP address configuration..
func (a NetApi) GetSelfList() (*NetSelfList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/self"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetSelfList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetServicePolicy
//
//
// Service Policy configuration.
//
// id is for ID of the resource.
func (a NetApi) GetServicePolicy(id string) (*NetServicePolicy, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/servicePolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetServicePolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetServicePolicyList
//
//
// Service Policy configuration..
func (a NetApi) GetServicePolicyList() (*NetServicePolicyList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/servicePolicy"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetServicePolicyList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetStp
//
//
// STP configuration.
//
// id is for ID of the resource.
func (a NetApi) GetStp(id string) (*NetStp, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/stp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetStp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetStpGlobals
//
//
// Global STP configuration, applies to all STP configuration items.
//
// id is for ID of the resource.
func (a NetApi) GetStpGlobals(id string) (*NetStpGlobals, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/stpGlobals/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetStpGlobals)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetStpGlobalsList
//
//
// Global STP configuration, applies to all STP configuration items..
func (a NetApi) GetStpGlobalsList() (*NetStpGlobalsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/stpGlobals"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetStpGlobalsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetStpList
//
//
// STP configuration..
func (a NetApi) GetStpList() (*NetStpList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/stp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetStpList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTimerPolicy
//
//
// Timer Policy configuration.
//
// id is for ID of the resource.
func (a NetApi) GetTimerPolicy(id string) (*NetTimerPolicy, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/timerPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTimerPolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTimerPolicyList
//
//
// Timer Policy configuration..
func (a NetApi) GetTimerPolicyList() (*NetTimerPolicyList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/timerPolicy"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTimerPolicyList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTmInterface
//
//
// Interface configuration and statistics.
//
// id is for ID of the resource.
func (a NetApi) GetTmInterface(id string) (*NetTmInterface, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tmInterface/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTmInterface)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTmInterfaceList
//
//
// Interface configuration and statistics..
func (a NetApi) GetTmInterfaceList() (*NetTmInterfaceList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tmInterface"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTmInterfaceList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTrunk
//
//
// Trunk configuration and statistics.
//
// id is for ID of the resource.
func (a NetApi) GetTrunk(id string) (*NetTrunk, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/trunk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTrunk)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTrunkList
//
//
// Trunk configuration and statistics..
func (a NetApi) GetTrunkList() (*NetTrunkList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/trunk"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTrunkList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnels
//
//
// Tunnel configuration.
//
// id is for ID of the resource.
func (a NetApi) GetTunnels(id string) (*NetTunnels, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnels)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsEtherip
//
//
// EtherIP tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) GetTunnelsEtherip(id string) (*NetTunnelsEtherip, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/etherip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsEtherip)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsEtheripList
//
//
// EtherIP tunnel profile configuration..
func (a NetApi) GetTunnelsEtheripList() (*NetTunnelsEtheripList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/etherip"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsEtheripList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsFec
//
//
// FEC tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) GetTunnelsFec(id string) (*NetTunnelsFec, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/fec/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsFec)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsFecList
//
//
// FEC tunnel profile configuration..
func (a NetApi) GetTunnelsFecList() (*NetTunnelsFecList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/fec"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsFecList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsFecStat
//
//
// FEC tunnel statistic.
//
// id is for ID of the resource.
func (a NetApi) GetTunnelsFecStat(id string) (*NetTunnelsFecStat, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/fecStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsFecStat)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsFecStatList
//
//
// FEC tunnel statistic..
func (a NetApi) GetTunnelsFecStatList() (*NetTunnelsFecStatList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/fecStat"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsFecStatList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsGeneve
//
//
// Geneve tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) GetTunnelsGeneve(id string) (*NetTunnelsGeneve, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/geneve/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsGeneve)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsGeneveList
//
//
// Geneve tunnel profile configuration..
func (a NetApi) GetTunnelsGeneveList() (*NetTunnelsGeneveList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/geneve"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsGeneveList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsGre
//
//
// GRE tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) GetTunnelsGre(id string) (*NetTunnelsGre, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/gre/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsGre)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsGreList
//
//
// GRE tunnel profile configuration..
func (a NetApi) GetTunnelsGreList() (*NetTunnelsGreList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/gre"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsGreList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsIpip
//
//
// IPIP tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) GetTunnelsIpip(id string) (*NetTunnelsIpip, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/ipip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsIpip)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsIpipList
//
//
// IPIP tunnel profile configuration..
func (a NetApi) GetTunnelsIpipList() (*NetTunnelsIpipList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/ipip"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsIpipList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsIpsec
//
//
// IPSEC tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) GetTunnelsIpsec(id string) (*NetTunnelsIpsec, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/ipsec/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsIpsec)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsIpsecList
//
//
// IPSEC tunnel profile configuration..
func (a NetApi) GetTunnelsIpsecList() (*NetTunnelsIpsecList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/ipsec"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsIpsecList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsList
//
//
// Tunnel configuration..
func (a NetApi) GetTunnelsList() (*NetTunnelsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsMap
//
//
// MAP tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) GetTunnelsMap(id string) (*NetTunnelsMap, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/map/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsMap)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsMapList
//
//
// MAP tunnel profile configuration..
func (a NetApi) GetTunnelsMapList() (*NetTunnelsMapList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/map"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsMapList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsPpp
//
//
// PPP tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) GetTunnelsPpp(id string) (*NetTunnelsPpp, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/ppp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsPpp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsPppList
//
//
// PPP tunnel profile configuration..
func (a NetApi) GetTunnelsPppList() (*NetTunnelsPppList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/ppp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsPppList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsTcpForward
//
//
// .
//
// id is for ID of the resource.
func (a NetApi) GetTunnelsTcpForward(id string) (*NetTunnelsTcpForward, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/tcpForward/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsTcpForward)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsTcpForwardList
//
//
// ..
func (a NetApi) GetTunnelsTcpForwardList() (*NetTunnelsTcpForwardList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/tcpForward"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsTcpForwardList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsTunnel
//
//
// Tunnel configuration.
//
// id is for ID of the resource.
func (a NetApi) GetTunnelsTunnel(id string) (*NetTunnelsTunnel, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/tunnel/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsTunnel)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsTunnelList
//
//
// Tunnel configuration..
func (a NetApi) GetTunnelsTunnelList() (*NetTunnelsTunnelList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/tunnel"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsTunnelList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsV6rd
//
//
// 6RD tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) GetTunnelsV6rd(id string) (*NetTunnelsV6rd, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/v6rd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsV6rd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsV6rdList
//
//
// 6RD tunnel profile configuration..
func (a NetApi) GetTunnelsV6rdList() (*NetTunnelsV6rdList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/v6rd"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsV6rdList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsVxlan
//
//
// VXLAN tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) GetTunnelsVxlan(id string) (*NetTunnelsVxlan, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/vxlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsVxlan)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsVxlanList
//
//
// VXLAN tunnel profile configuration..
func (a NetApi) GetTunnelsVxlanList() (*NetTunnelsVxlanList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/vxlan"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsVxlanList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsWccp
//
//
// WCCP tunnel profile configuration.
//
// id is for ID of the resource.
func (a NetApi) GetTunnelsWccp(id string) (*NetTunnelsWccp, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/wccp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsWccp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTunnelsWccpList
//
//
// WCCP tunnel profile configuration..
func (a NetApi) GetTunnelsWccpList() (*NetTunnelsWccpList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/wccp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsWccpList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetVlan
//
//
// VLAN configuration and statistics.
//
// id is for ID of the resource.
func (a NetApi) GetVlan(id string) (*NetVlan, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/vlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetVlan)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetVlanAllowed
//
//
// Available VLANs which can be used by the system.
//
// id is for ID of the resource.
func (a NetApi) GetVlanAllowed(id string) (*NetVlanAllowed, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/vlanAllowed/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetVlanAllowed)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetVlanAllowedList
//
//
// Available VLANs which can be used by the system..
func (a NetApi) GetVlanAllowedList() (*NetVlanAllowedList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/vlanAllowed"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetVlanAllowedList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetVlanGroup
//
//
// VLAN group configuration.
//
// id is for ID of the resource.
func (a NetApi) GetVlanGroup(id string) (*NetVlanGroup, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/vlanGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetVlanGroup)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetVlanGroupList
//
//
// VLAN group configuration..
func (a NetApi) GetVlanGroupList() (*NetVlanGroupList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/vlanGroup"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetVlanGroupList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetVlanInterfaces
//
//
// Specifies which interfaces you want this VLAN to use for traffic management..
//
// id is for ID of the resource.
func (a NetApi) GetVlanInterfaces(id string) (*NetVlanInterfaces, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/vlan/interfaces/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetVlanInterfaces)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetVlanInterfacesList
//
//
// Specifies which interfaces you want this VLAN to use for traffic management...
func (a NetApi) GetVlanInterfacesList() (*NetVlanInterfacesList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/vlan/interfaces"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetVlanInterfacesList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetVlanList
//
//
// VLAN configuration and statistics..
func (a NetApi) GetVlanList() (*NetVlanList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/vlan"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetVlanList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetWccp
//
//
// WCCP configuration.
//
// id is for ID of the resource.
func (a NetApi) GetWccp(id string) (*NetWccp, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/wccp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetWccp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetWccpList
//
//
// WCCP configuration..
func (a NetApi) GetWccpList() (*NetWccpList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/wccp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetWccpList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetWccpServices
//
//
// .
//
// id is for ID of the resource.
func (a NetApi) GetWccpServices(id string) (*NetWccpServices, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/wccp/services/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetWccpServices)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetWccpServicesList
//
//
// ..
func (a NetApi) GetWccpServicesList() (*NetWccpServicesList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/wccp/services"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetWccpServicesList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchArp
//
//
// Manage the Address Resolution Protocol (ARP) table.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchArp(id string, object NetArp) (*NetArp, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/arp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetArp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchBwcPolicy
//
//
// Bandwidth control policy for traffic flow..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchBwcPolicy(id string, object NetBwcPolicy) (*NetBwcPolicy, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/policy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwcPolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchBwcPriorityGroup
//
//
// Bandwidth traffic group for bandwidth policy traffic flows..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchBwcPriorityGroup(id string, object NetBwcPriorityGroup) (*NetBwcPriorityGroup, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/priorityGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwcPriorityGroup)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchBwcPriorityGroupPriorityClasses
//
//
// Bandwidth traffic classes in the bandwidth traffic group..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchBwcPriorityGroupPriorityClasses(id string, object NetBwcPriorityGroupPriorityClasses) (*NetBwcPriorityGroupPriorityClasses, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/priorityGroup/priorityClasses/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwcPriorityGroupPriorityClasses)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchBwcProbe
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchBwcProbe(id string, object NetBwcProbe) (*NetBwcProbe, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/probe/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwcProbe)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchCosGlobalSettings
//
//
// Configures the global configuration for class of service..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchCosGlobalSettings(id string, object NetCosGlobalSettings) (*NetCosGlobalSettings, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/globalSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCosGlobalSettings)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchCosMap8021p
//
//
// Configures vlan 8021.p tag to traffic priority mapping..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchCosMap8021p(id string, object NetCosMap8021p) (*NetCosMap8021p, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/map_8021p/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCosMap8021p)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchCosMapDscp
//
//
// Configures IP DSCP field to traffic priority mapping..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchCosMapDscp(id string, object NetCosMapDscp) (*NetCosMapDscp, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/mapDscp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCosMapDscp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchCosTrafficPriority
//
//
// Configures a traffic priority object..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchCosTrafficPriority(id string, object NetCosTrafficPriority) (*NetCosTrafficPriority, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/trafficPriority/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCosTrafficPriority)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchDagGlobals
//
//
// Global disaggregation settings.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchDagGlobals(id string, object NetDagGlobals) (*NetDagGlobals, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/dagGlobals/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetDagGlobals)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchDnsResolver
//
//
// DNS Resolver object..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchDnsResolver(id string, object NetDnsResolver) (*NetDnsResolver, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/dnsResolver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetDnsResolver)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchFdbTunnel
//
//
// Tunnel forwarding database configuration and status.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchFdbTunnel(id string, object NetFdbTunnel) (*NetFdbTunnel, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/fdb/tunnel/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetFdbTunnel)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchFdbTunnelRecords
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchFdbTunnelRecords(id string, object NetFdbTunnelRecords) (*NetFdbTunnelRecords, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/fdb/tunnel/records/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetFdbTunnelRecords)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchFdbVlan
//
//
// VLAN forwarding database configuration and status.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchFdbVlan(id string, object NetFdbVlan) (*NetFdbVlan, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/fdb/vlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetFdbVlan)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchIpsecIkeDaemon
//
//
// Configure global setting for ike agent..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchIpsecIkeDaemon(id string, object NetIpsecIkeDaemon) (*NetIpsecIkeDaemon, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ikeDaemon/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecIkeDaemon)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchIpsecIkePeer
//
//
// Specifies IKE phase 1 parameters for remote ike peers..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchIpsecIkePeer(id string, object NetIpsecIkePeer) (*NetIpsecIkePeer, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ikePeer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecIkePeer)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchIpsecIpsecPolicy
//
//
// Configure IPsec security policy..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchIpsecIpsecPolicy(id string, object NetIpsecIpsecPolicy) (*NetIpsecIpsecPolicy, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ipsecPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecIpsecPolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchIpsecManualSecurityAssociation
//
//
// Specifies manually configured Security Association parameters..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchIpsecManualSecurityAssociation(id string, object NetIpsecManualSecurityAssociation) (*NetIpsecManualSecurityAssociation, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/manualSecurityAssociation/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecManualSecurityAssociation)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchIpsecTrafficSelector
//
//
// Traffic Selector configuration..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchIpsecTrafficSelector(id string, object NetIpsecTrafficSelector) (*NetIpsecTrafficSelector, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/trafficSelector/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecTrafficSelector)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchLldpGlobals
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchLldpGlobals(id string, object NetLldpGlobals) (*NetLldpGlobals, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/lldpGlobals/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetLldpGlobals)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchMulticastGlobals
//
//
// Manage multicast traffic configuration options.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchMulticastGlobals(id string, object NetMulticastGlobals) (*NetMulticastGlobals, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/multicastGlobals/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetMulticastGlobals)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchNdp
//
//
// Manage the IPv6 Neighbor Discovery Protocol (NDP) table..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchNdp(id string, object NetNdp) (*NetNdp, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ndp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetNdp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchPacketFilter
//
//
// Packet filter configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchPacketFilter(id string, object NetPacketFilter) (*NetPacketFilter, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/packetFilter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetPacketFilter)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchPacketFilterTrusted
//
//
// Trusted entities that are exempt from packet filter rules.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchPacketFilterTrusted(id string, object NetPacketFilterTrusted) (*NetPacketFilterTrusted, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/packetFilterTrusted/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetPacketFilterTrusted)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchPortMirror
//
//
// Interface port mirroring configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchPortMirror(id string, object NetPortMirror) (*NetPortMirror, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/portMirror/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetPortMirror)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchRateShapingColorPolicer
//
//
// Color based policer configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchRateShapingColorPolicer(id string, object NetRateShapingColorPolicer) (*NetRateShapingColorPolicer, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/colorPolicer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingColorPolicer)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchRateShapingDropPolicy
//
//
// Drop policy configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchRateShapingDropPolicy(id string, object NetRateShapingDropPolicy) (*NetRateShapingDropPolicy, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/dropPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingDropPolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchRateShapingQueue
//
//
// Queuing method configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchRateShapingQueue(id string, object NetRateShapingQueue) (*NetRateShapingQueue, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/queue/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingQueue)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchRateShapingShapingPolicy
//
//
// Shaping policy configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchRateShapingShapingPolicy(id string, object NetRateShapingShapingPolicy) (*NetRateShapingShapingPolicy, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/shapingPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingShapingPolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchRateShapingTmClass
//
//
// Rate class configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchRateShapingTmClass(id string, object NetRateShapingTmClass) (*NetRateShapingTmClass, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/tmClass/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingTmClass)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchRoute
//
//
// Routing tables and configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchRoute(id string, object NetRoute) (*NetRoute, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/route/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRoute)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchRouteDomain
//
//
// Route domain configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchRouteDomain(id string, object NetRouteDomain) (*NetRouteDomain, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routeDomain/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouteDomain)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchRouterAdvertisement
//
//
// Configures IPv6 prefixes for router advertisement on a VLAN..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchRouterAdvertisement(id string, object NetRouterAdvertisement) (*NetRouterAdvertisement, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routerAdvertisement/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouterAdvertisement)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchRouterAdvertisementPrefixes
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchRouterAdvertisementPrefixes(id string, object NetRouterAdvertisementPrefixes) (*NetRouterAdvertisementPrefixes, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routerAdvertisement/prefixes/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouterAdvertisementPrefixes)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchSelf
//
//
// Self-IP address configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchSelf(id string, object NetSelf) (*NetSelf, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/self/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetSelf)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchSelfAllow
//
//
// The default set of protocol and ports allowed by a self IP.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchSelfAllow(id string, object NetSelfAllow) (*NetSelfAllow, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/selfAllow/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetSelfAllow)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchServicePolicy
//
//
// Service Policy configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchServicePolicy(id string, object NetServicePolicy) (*NetServicePolicy, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/servicePolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetServicePolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchStp
//
//
// STP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchStp(id string, object NetStp) (*NetStp, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/stp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetStp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchStpGlobals
//
//
// Global STP configuration, applies to all STP configuration items.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchStpGlobals(id string, object NetStpGlobals) (*NetStpGlobals, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/stpGlobals/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetStpGlobals)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchTimerPolicy
//
//
// Timer Policy configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchTimerPolicy(id string, object NetTimerPolicy) (*NetTimerPolicy, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/timerPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTimerPolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchTmInterface
//
//
// Interface configuration and statistics.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchTmInterface(id string, object NetTmInterface) (*NetTmInterface, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tmInterface/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTmInterface)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchTrunk
//
//
// Trunk configuration and statistics.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchTrunk(id string, object NetTrunk) (*NetTrunk, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/trunk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTrunk)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchTunnelsEtherip
//
//
// EtherIP tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchTunnelsEtherip(id string, object NetTunnelsEtherip) (*NetTunnelsEtherip, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/etherip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsEtherip)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchTunnelsFec
//
//
// FEC tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchTunnelsFec(id string, object NetTunnelsFec) (*NetTunnelsFec, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/fec/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsFec)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchTunnelsGeneve
//
//
// Geneve tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchTunnelsGeneve(id string, object NetTunnelsGeneve) (*NetTunnelsGeneve, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/geneve/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsGeneve)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchTunnelsGre
//
//
// GRE tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchTunnelsGre(id string, object NetTunnelsGre) (*NetTunnelsGre, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/gre/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsGre)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchTunnelsIpip
//
//
// IPIP tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchTunnelsIpip(id string, object NetTunnelsIpip) (*NetTunnelsIpip, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/ipip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsIpip)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchTunnelsIpsec
//
//
// IPSEC tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchTunnelsIpsec(id string, object NetTunnelsIpsec) (*NetTunnelsIpsec, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/ipsec/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsIpsec)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchTunnelsMap
//
//
// MAP tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchTunnelsMap(id string, object NetTunnelsMap) (*NetTunnelsMap, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/map/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsMap)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchTunnelsPpp
//
//
// PPP tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchTunnelsPpp(id string, object NetTunnelsPpp) (*NetTunnelsPpp, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/ppp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsPpp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchTunnelsTcpForward
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchTunnelsTcpForward(id string, object NetTunnelsTcpForward) (*NetTunnelsTcpForward, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/tcpForward/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsTcpForward)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchTunnelsTunnel
//
//
// Tunnel configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchTunnelsTunnel(id string, object NetTunnelsTunnel) (*NetTunnelsTunnel, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/tunnel/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsTunnel)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchTunnelsV6rd
//
//
// 6RD tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchTunnelsV6rd(id string, object NetTunnelsV6rd) (*NetTunnelsV6rd, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/v6rd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsV6rd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchTunnelsVxlan
//
//
// VXLAN tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchTunnelsVxlan(id string, object NetTunnelsVxlan) (*NetTunnelsVxlan, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/vxlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsVxlan)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchTunnelsWccp
//
//
// WCCP tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchTunnelsWccp(id string, object NetTunnelsWccp) (*NetTunnelsWccp, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/wccp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsWccp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchVlan
//
//
// VLAN configuration and statistics.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchVlan(id string, object NetVlan) (*NetVlan, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/vlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetVlan)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchVlanGroup
//
//
// VLAN group configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchVlanGroup(id string, object NetVlanGroup) (*NetVlanGroup, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/vlanGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetVlanGroup)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchVlanInterfaces
//
//
// Specifies which interfaces you want this VLAN to use for traffic management..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchVlanInterfaces(id string, object NetVlanInterfaces) (*NetVlanInterfaces, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/vlan/interfaces/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetVlanInterfaces)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchWccp
//
//
// WCCP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchWccp(id string, object NetWccp) (*NetWccp, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/wccp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetWccp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchWccpServices
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PatchWccpServices(id string, object NetWccpServices) (*NetWccpServices, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/wccp/services/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetWccpServices)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostArp
//
//
// Manage the Address Resolution Protocol (ARP) table.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostArp(id string, object NetArp) (*NetArp, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/arp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetArp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostBwcPolicy
//
//
// Bandwidth control policy for traffic flow..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostBwcPolicy(id string, object NetBwcPolicy) (*NetBwcPolicy, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/policy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwcPolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostBwcPriorityGroup
//
//
// Bandwidth traffic group for bandwidth policy traffic flows..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostBwcPriorityGroup(id string, object NetBwcPriorityGroup) (*NetBwcPriorityGroup, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/priorityGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwcPriorityGroup)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostBwcPriorityGroupPriorityClasses
//
//
// Bandwidth traffic classes in the bandwidth traffic group..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostBwcPriorityGroupPriorityClasses(id string, object NetBwcPriorityGroupPriorityClasses) (*NetBwcPriorityGroupPriorityClasses, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/priorityGroup/priorityClasses/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwcPriorityGroupPriorityClasses)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostBwcProbe
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostBwcProbe(id string, object NetBwcProbe) (*NetBwcProbe, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/probe/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwcProbe)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostCosMap8021p
//
//
// Configures vlan 8021.p tag to traffic priority mapping..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostCosMap8021p(id string, object NetCosMap8021p) (*NetCosMap8021p, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/map_8021p/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCosMap8021p)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostCosMapDscp
//
//
// Configures IP DSCP field to traffic priority mapping..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostCosMapDscp(id string, object NetCosMapDscp) (*NetCosMapDscp, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/mapDscp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCosMapDscp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostCosTrafficPriority
//
//
// Configures a traffic priority object..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostCosTrafficPriority(id string, object NetCosTrafficPriority) (*NetCosTrafficPriority, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/trafficPriority/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCosTrafficPriority)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostDnsResolver
//
//
// DNS Resolver object..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostDnsResolver(id string, object NetDnsResolver) (*NetDnsResolver, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/dnsResolver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetDnsResolver)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostFdbTunnelRecords
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostFdbTunnelRecords(id string, object NetFdbTunnelRecords) (*NetFdbTunnelRecords, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/fdb/tunnel/records/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetFdbTunnelRecords)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostIkeEvtStat
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostIkeEvtStat(id string, object NetIkeEvtStat) (*NetIkeEvtStat, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ikeEvtStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIkeEvtStat)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostIkeMsgStat
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostIkeMsgStat(id string, object NetIkeMsgStat) (*NetIkeMsgStat, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ikeMsgStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIkeMsgStat)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostInterfaceCos
//
//
// Interface COS (Class of Service) related statistics.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostInterfaceCos(id string, object NetInterfaceCos) (*NetInterfaceCos, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/interfaceCos/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetInterfaceCos)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostIpsecIkePeer
//
//
// Specifies IKE phase 1 parameters for remote ike peers..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostIpsecIkePeer(id string, object NetIpsecIkePeer) (*NetIpsecIkePeer, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ikePeer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecIkePeer)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostIpsecIpsecPolicy
//
//
// Configure IPsec security policy..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostIpsecIpsecPolicy(id string, object NetIpsecIpsecPolicy) (*NetIpsecIpsecPolicy, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ipsecPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecIpsecPolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostIpsecManualSecurityAssociation
//
//
// Specifies manually configured Security Association parameters..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostIpsecManualSecurityAssociation(id string, object NetIpsecManualSecurityAssociation) (*NetIpsecManualSecurityAssociation, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/manualSecurityAssociation/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecManualSecurityAssociation)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostIpsecStat
//
//
// IPSec statistics.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostIpsecStat(id string, object NetIpsecStat) (*NetIpsecStat, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsecStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecStat)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostIpsecTrafficSelector
//
//
// Traffic Selector configuration..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostIpsecTrafficSelector(id string, object NetIpsecTrafficSelector) (*NetIpsecTrafficSelector, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/trafficSelector/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecTrafficSelector)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostNdp
//
//
// Manage the IPv6 Neighbor Discovery Protocol (NDP) table..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostNdp(id string, object NetNdp) (*NetNdp, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ndp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetNdp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostPacketFilter
//
//
// Packet filter configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostPacketFilter(id string, object NetPacketFilter) (*NetPacketFilter, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/packetFilter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetPacketFilter)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostPortMirror
//
//
// Interface port mirroring configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostPortMirror(id string, object NetPortMirror) (*NetPortMirror, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/portMirror/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetPortMirror)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostRateShapingColorPolicer
//
//
// Color based policer configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostRateShapingColorPolicer(id string, object NetRateShapingColorPolicer) (*NetRateShapingColorPolicer, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/colorPolicer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingColorPolicer)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostRateShapingDropPolicy
//
//
// Drop policy configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostRateShapingDropPolicy(id string, object NetRateShapingDropPolicy) (*NetRateShapingDropPolicy, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/dropPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingDropPolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostRateShapingQueue
//
//
// Queuing method configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostRateShapingQueue(id string, object NetRateShapingQueue) (*NetRateShapingQueue, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/queue/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingQueue)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostRateShapingShapingPolicy
//
//
// Shaping policy configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostRateShapingShapingPolicy(id string, object NetRateShapingShapingPolicy) (*NetRateShapingShapingPolicy, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/shapingPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingShapingPolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostRateShapingTmClass
//
//
// Rate class configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostRateShapingTmClass(id string, object NetRateShapingTmClass) (*NetRateShapingTmClass, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/tmClass/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingTmClass)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostRoute
//
//
// Routing tables and configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostRoute(id string, object NetRoute) (*NetRoute, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/route/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRoute)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostRouteDomain
//
//
// Route domain configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostRouteDomain(id string, object NetRouteDomain) (*NetRouteDomain, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routeDomain/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouteDomain)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostRouteDomainFwEnforcedPolicyRules
//
//
// Firewall policy rule entry.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostRouteDomainFwEnforcedPolicyRules(id string, object NetRouteDomainFwEnforcedPolicyRules) (*NetRouteDomainFwEnforcedPolicyRules, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routeDomain/fwEnforcedPolicyRules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouteDomainFwEnforcedPolicyRules)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostRouteDomainFwStagedPolicyRules
//
//
// Firewall policy rule entry.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostRouteDomainFwStagedPolicyRules(id string, object NetRouteDomainFwStagedPolicyRules) (*NetRouteDomainFwStagedPolicyRules, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routeDomain/fwStagedPolicyRules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouteDomainFwStagedPolicyRules)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostRouterAdvertisement
//
//
// Configures IPv6 prefixes for router advertisement on a VLAN..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostRouterAdvertisement(id string, object NetRouterAdvertisement) (*NetRouterAdvertisement, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routerAdvertisement/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouterAdvertisement)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostRouterAdvertisementPrefixes
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostRouterAdvertisementPrefixes(id string, object NetRouterAdvertisementPrefixes) (*NetRouterAdvertisementPrefixes, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routerAdvertisement/prefixes/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouterAdvertisementPrefixes)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostRstCause
//
//
// TCP/IP Reset Cause statistics..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostRstCause(id string, object NetRstCause) (*NetRstCause, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rstCause/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRstCause)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostSelf
//
//
// Self-IP address configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostSelf(id string, object NetSelf) (*NetSelf, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/self/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetSelf)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostSelfFwEnforcedPolicyRules
//
//
// Firewall policy rule entry.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostSelfFwEnforcedPolicyRules(id string, object NetSelfFwEnforcedPolicyRules) (*NetSelfFwEnforcedPolicyRules, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/self/fwEnforcedPolicyRules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetSelfFwEnforcedPolicyRules)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostSelfFwStagedPolicyRules
//
//
// Firewall policy rule entry.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostSelfFwStagedPolicyRules(id string, object NetSelfFwStagedPolicyRules) (*NetSelfFwStagedPolicyRules, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/self/fwStagedPolicyRules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetSelfFwStagedPolicyRules)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostServicePolicy
//
//
// Service Policy configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostServicePolicy(id string, object NetServicePolicy) (*NetServicePolicy, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/servicePolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetServicePolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostStp
//
//
// STP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostStp(id string, object NetStp) (*NetStp, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/stp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetStp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostTimerPolicy
//
//
// Timer Policy configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostTimerPolicy(id string, object NetTimerPolicy) (*NetTimerPolicy, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/timerPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTimerPolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostTmInterface
//
//
// Interface configuration and statistics.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostTmInterface(id string, object NetTmInterface) (*NetTmInterface, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tmInterface/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTmInterface)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostTrunk
//
//
// Trunk configuration and statistics.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostTrunk(id string, object NetTrunk) (*NetTrunk, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/trunk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTrunk)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostTunnelsEtherip
//
//
// EtherIP tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostTunnelsEtherip(id string, object NetTunnelsEtherip) (*NetTunnelsEtherip, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/etherip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsEtherip)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostTunnelsFec
//
//
// FEC tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostTunnelsFec(id string, object NetTunnelsFec) (*NetTunnelsFec, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/fec/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsFec)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostTunnelsGeneve
//
//
// Geneve tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostTunnelsGeneve(id string, object NetTunnelsGeneve) (*NetTunnelsGeneve, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/geneve/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsGeneve)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostTunnelsGre
//
//
// GRE tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostTunnelsGre(id string, object NetTunnelsGre) (*NetTunnelsGre, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/gre/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsGre)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostTunnelsIpip
//
//
// IPIP tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostTunnelsIpip(id string, object NetTunnelsIpip) (*NetTunnelsIpip, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/ipip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsIpip)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostTunnelsIpsec
//
//
// IPSEC tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostTunnelsIpsec(id string, object NetTunnelsIpsec) (*NetTunnelsIpsec, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/ipsec/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsIpsec)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostTunnelsMap
//
//
// MAP tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostTunnelsMap(id string, object NetTunnelsMap) (*NetTunnelsMap, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/map/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsMap)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostTunnelsPpp
//
//
// PPP tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostTunnelsPpp(id string, object NetTunnelsPpp) (*NetTunnelsPpp, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/ppp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsPpp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostTunnelsTcpForward
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostTunnelsTcpForward(id string, object NetTunnelsTcpForward) (*NetTunnelsTcpForward, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/tcpForward/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsTcpForward)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostTunnelsTunnel
//
//
// Tunnel configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostTunnelsTunnel(id string, object NetTunnelsTunnel) (*NetTunnelsTunnel, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/tunnel/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsTunnel)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostTunnelsV6rd
//
//
// 6RD tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostTunnelsV6rd(id string, object NetTunnelsV6rd) (*NetTunnelsV6rd, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/v6rd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsV6rd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostTunnelsVxlan
//
//
// VXLAN tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostTunnelsVxlan(id string, object NetTunnelsVxlan) (*NetTunnelsVxlan, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/vxlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsVxlan)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostTunnelsWccp
//
//
// WCCP tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostTunnelsWccp(id string, object NetTunnelsWccp) (*NetTunnelsWccp, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/wccp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsWccp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostVlan
//
//
// VLAN configuration and statistics.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostVlan(id string, object NetVlan) (*NetVlan, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/vlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetVlan)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostVlanGroup
//
//
// VLAN group configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostVlanGroup(id string, object NetVlanGroup) (*NetVlanGroup, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/vlanGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetVlanGroup)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostVlanInterfaces
//
//
// Specifies which interfaces you want this VLAN to use for traffic management..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostVlanInterfaces(id string, object NetVlanInterfaces) (*NetVlanInterfaces, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/vlan/interfaces/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetVlanInterfaces)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostWccp
//
//
// WCCP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostWccp(id string, object NetWccp) (*NetWccp, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/wccp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetWccp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostWccpServices
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PostWccpServices(id string, object NetWccpServices) (*NetWccpServices, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/wccp/services/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetWccpServices)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutArp
//
//
// Manage the Address Resolution Protocol (ARP) table.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutArp(id string, object NetArp) (*NetArp, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/arp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetArp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutBwcPolicy
//
//
// Bandwidth control policy for traffic flow..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutBwcPolicy(id string, object NetBwcPolicy) (*NetBwcPolicy, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/policy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwcPolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutBwcPriorityGroup
//
//
// Bandwidth traffic group for bandwidth policy traffic flows..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutBwcPriorityGroup(id string, object NetBwcPriorityGroup) (*NetBwcPriorityGroup, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/priorityGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwcPriorityGroup)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutBwcPriorityGroupPriorityClasses
//
//
// Bandwidth traffic classes in the bandwidth traffic group..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutBwcPriorityGroupPriorityClasses(id string, object NetBwcPriorityGroupPriorityClasses) (*NetBwcPriorityGroupPriorityClasses, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/priorityGroup/priorityClasses/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwcPriorityGroupPriorityClasses)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutBwcProbe
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutBwcProbe(id string, object NetBwcProbe) (*NetBwcProbe, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/bwc/probe/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetBwcProbe)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutCosGlobalSettings
//
//
// Configures the global configuration for class of service..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutCosGlobalSettings(id string, object NetCosGlobalSettings) (*NetCosGlobalSettings, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/globalSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCosGlobalSettings)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutCosMap8021p
//
//
// Configures vlan 8021.p tag to traffic priority mapping..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutCosMap8021p(id string, object NetCosMap8021p) (*NetCosMap8021p, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/map_8021p/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCosMap8021p)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutCosMapDscp
//
//
// Configures IP DSCP field to traffic priority mapping..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutCosMapDscp(id string, object NetCosMapDscp) (*NetCosMapDscp, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/mapDscp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCosMapDscp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutCosTrafficPriority
//
//
// Configures a traffic priority object..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutCosTrafficPriority(id string, object NetCosTrafficPriority) (*NetCosTrafficPriority, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/cos/trafficPriority/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetCosTrafficPriority)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutDagGlobals
//
//
// Global disaggregation settings.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutDagGlobals(id string, object NetDagGlobals) (*NetDagGlobals, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/dagGlobals/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetDagGlobals)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutDnsResolver
//
//
// DNS Resolver object..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutDnsResolver(id string, object NetDnsResolver) (*NetDnsResolver, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/dnsResolver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetDnsResolver)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutFdbTunnel
//
//
// Tunnel forwarding database configuration and status.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutFdbTunnel(id string, object NetFdbTunnel) (*NetFdbTunnel, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/fdb/tunnel/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetFdbTunnel)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutFdbTunnelRecords
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutFdbTunnelRecords(id string, object NetFdbTunnelRecords) (*NetFdbTunnelRecords, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/fdb/tunnel/records/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetFdbTunnelRecords)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutFdbVlan
//
//
// VLAN forwarding database configuration and status.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutFdbVlan(id string, object NetFdbVlan) (*NetFdbVlan, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/fdb/vlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetFdbVlan)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutIpsecIkeDaemon
//
//
// Configure global setting for ike agent..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutIpsecIkeDaemon(id string, object NetIpsecIkeDaemon) (*NetIpsecIkeDaemon, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ikeDaemon/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecIkeDaemon)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutIpsecIkePeer
//
//
// Specifies IKE phase 1 parameters for remote ike peers..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutIpsecIkePeer(id string, object NetIpsecIkePeer) (*NetIpsecIkePeer, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ikePeer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecIkePeer)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutIpsecIpsecPolicy
//
//
// Configure IPsec security policy..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutIpsecIpsecPolicy(id string, object NetIpsecIpsecPolicy) (*NetIpsecIpsecPolicy, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/ipsecPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecIpsecPolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutIpsecManualSecurityAssociation
//
//
// Specifies manually configured Security Association parameters..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutIpsecManualSecurityAssociation(id string, object NetIpsecManualSecurityAssociation) (*NetIpsecManualSecurityAssociation, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/manualSecurityAssociation/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecManualSecurityAssociation)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutIpsecTrafficSelector
//
//
// Traffic Selector configuration..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutIpsecTrafficSelector(id string, object NetIpsecTrafficSelector) (*NetIpsecTrafficSelector, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ipsec/trafficSelector/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetIpsecTrafficSelector)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutLldpGlobals
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutLldpGlobals(id string, object NetLldpGlobals) (*NetLldpGlobals, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/lldpGlobals/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetLldpGlobals)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutMulticastGlobals
//
//
// Manage multicast traffic configuration options.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutMulticastGlobals(id string, object NetMulticastGlobals) (*NetMulticastGlobals, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/multicastGlobals/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetMulticastGlobals)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutNdp
//
//
// Manage the IPv6 Neighbor Discovery Protocol (NDP) table..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutNdp(id string, object NetNdp) (*NetNdp, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/ndp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetNdp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutPacketFilter
//
//
// Packet filter configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutPacketFilter(id string, object NetPacketFilter) (*NetPacketFilter, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/packetFilter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetPacketFilter)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutPacketFilterTrusted
//
//
// Trusted entities that are exempt from packet filter rules.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutPacketFilterTrusted(id string, object NetPacketFilterTrusted) (*NetPacketFilterTrusted, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/packetFilterTrusted/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetPacketFilterTrusted)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutPortMirror
//
//
// Interface port mirroring configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutPortMirror(id string, object NetPortMirror) (*NetPortMirror, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/portMirror/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetPortMirror)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutRateShapingColorPolicer
//
//
// Color based policer configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutRateShapingColorPolicer(id string, object NetRateShapingColorPolicer) (*NetRateShapingColorPolicer, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/colorPolicer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingColorPolicer)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutRateShapingDropPolicy
//
//
// Drop policy configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutRateShapingDropPolicy(id string, object NetRateShapingDropPolicy) (*NetRateShapingDropPolicy, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/dropPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingDropPolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutRateShapingQueue
//
//
// Queuing method configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutRateShapingQueue(id string, object NetRateShapingQueue) (*NetRateShapingQueue, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/queue/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingQueue)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutRateShapingShapingPolicy
//
//
// Shaping policy configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutRateShapingShapingPolicy(id string, object NetRateShapingShapingPolicy) (*NetRateShapingShapingPolicy, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/shapingPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingShapingPolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutRateShapingTmClass
//
//
// Rate class configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutRateShapingTmClass(id string, object NetRateShapingTmClass) (*NetRateShapingTmClass, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/rateShaping/tmClass/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRateShapingTmClass)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutRoute
//
//
// Routing tables and configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutRoute(id string, object NetRoute) (*NetRoute, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/route/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRoute)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutRouteDomain
//
//
// Route domain configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutRouteDomain(id string, object NetRouteDomain) (*NetRouteDomain, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routeDomain/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouteDomain)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutRouterAdvertisement
//
//
// Configures IPv6 prefixes for router advertisement on a VLAN..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutRouterAdvertisement(id string, object NetRouterAdvertisement) (*NetRouterAdvertisement, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routerAdvertisement/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouterAdvertisement)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutRouterAdvertisementPrefixes
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutRouterAdvertisementPrefixes(id string, object NetRouterAdvertisementPrefixes) (*NetRouterAdvertisementPrefixes, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/routerAdvertisement/prefixes/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetRouterAdvertisementPrefixes)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutSelf
//
//
// Self-IP address configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutSelf(id string, object NetSelf) (*NetSelf, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/self/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetSelf)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutSelfAllow
//
//
// The default set of protocol and ports allowed by a self IP.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutSelfAllow(id string, object NetSelfAllow) (*NetSelfAllow, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/selfAllow/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetSelfAllow)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutServicePolicy
//
//
// Service Policy configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutServicePolicy(id string, object NetServicePolicy) (*NetServicePolicy, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/servicePolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetServicePolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutStp
//
//
// STP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutStp(id string, object NetStp) (*NetStp, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/stp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetStp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutStpGlobals
//
//
// Global STP configuration, applies to all STP configuration items.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutStpGlobals(id string, object NetStpGlobals) (*NetStpGlobals, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/stpGlobals/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetStpGlobals)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutTimerPolicy
//
//
// Timer Policy configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutTimerPolicy(id string, object NetTimerPolicy) (*NetTimerPolicy, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/timerPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTimerPolicy)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutTmInterface
//
//
// Interface configuration and statistics.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutTmInterface(id string, object NetTmInterface) (*NetTmInterface, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tmInterface/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTmInterface)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutTrunk
//
//
// Trunk configuration and statistics.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutTrunk(id string, object NetTrunk) (*NetTrunk, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/trunk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTrunk)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutTunnelsEtherip
//
//
// EtherIP tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutTunnelsEtherip(id string, object NetTunnelsEtherip) (*NetTunnelsEtherip, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/etherip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsEtherip)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutTunnelsFec
//
//
// FEC tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutTunnelsFec(id string, object NetTunnelsFec) (*NetTunnelsFec, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/fec/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsFec)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutTunnelsGeneve
//
//
// Geneve tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutTunnelsGeneve(id string, object NetTunnelsGeneve) (*NetTunnelsGeneve, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/geneve/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsGeneve)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutTunnelsGre
//
//
// GRE tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutTunnelsGre(id string, object NetTunnelsGre) (*NetTunnelsGre, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/gre/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsGre)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutTunnelsIpip
//
//
// IPIP tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutTunnelsIpip(id string, object NetTunnelsIpip) (*NetTunnelsIpip, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/ipip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsIpip)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutTunnelsIpsec
//
//
// IPSEC tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutTunnelsIpsec(id string, object NetTunnelsIpsec) (*NetTunnelsIpsec, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/ipsec/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsIpsec)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutTunnelsMap
//
//
// MAP tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutTunnelsMap(id string, object NetTunnelsMap) (*NetTunnelsMap, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/map/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsMap)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutTunnelsPpp
//
//
// PPP tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutTunnelsPpp(id string, object NetTunnelsPpp) (*NetTunnelsPpp, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/ppp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsPpp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutTunnelsTcpForward
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutTunnelsTcpForward(id string, object NetTunnelsTcpForward) (*NetTunnelsTcpForward, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/tcpForward/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsTcpForward)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutTunnelsTunnel
//
//
// Tunnel configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutTunnelsTunnel(id string, object NetTunnelsTunnel) (*NetTunnelsTunnel, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/tunnel/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsTunnel)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutTunnelsV6rd
//
//
// 6RD tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutTunnelsV6rd(id string, object NetTunnelsV6rd) (*NetTunnelsV6rd, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/v6rd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsV6rd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutTunnelsVxlan
//
//
// VXLAN tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutTunnelsVxlan(id string, object NetTunnelsVxlan) (*NetTunnelsVxlan, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/vxlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsVxlan)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutTunnelsWccp
//
//
// WCCP tunnel profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutTunnelsWccp(id string, object NetTunnelsWccp) (*NetTunnelsWccp, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/tunnels/wccp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetTunnelsWccp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutVlan
//
//
// VLAN configuration and statistics.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutVlan(id string, object NetVlan) (*NetVlan, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/vlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetVlan)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutVlanGroup
//
//
// VLAN group configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutVlanGroup(id string, object NetVlanGroup) (*NetVlanGroup, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/vlanGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetVlanGroup)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutVlanInterfaces
//
//
// Specifies which interfaces you want this VLAN to use for traffic management..
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutVlanInterfaces(id string, object NetVlanInterfaces) (*NetVlanInterfaces, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/vlan/interfaces/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetVlanInterfaces)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutWccp
//
//
// WCCP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutWccp(id string, object NetWccp) (*NetWccp, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/wccp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetWccp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutWccpServices
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a NetApi) PutWccpServices(id string, object NetWccpServices) (*NetWccpServices, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/net/wccp/services/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(NetWccpServices)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}
