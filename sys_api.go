/*
 * BigIP iControl REST
 *
 * REST API for F5 BigIP. List of operations is not complete, nor known to be accurate.
 *
 * OpenAPI spec version: 12.0
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package f5api

import (
	"errors"
	"fmt"
	"net/url"
	"strings"

	"encoding/json"
)

// This class holds all the API methods for the Sys API sub tree
type SysApi struct {
	configuration *configuration
}

func unused_import_hack_SysApi() {
	strings.Replace("a", "a", fmt.Sprintf("%v", nil), -1)
}

// DeleteApplicationAplScript
//
//
// Scripts included by an application template.
//
// id is for ID of the resource.
func (a SysApi) DeleteApplicationAplScript(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/aplScript/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteApplicationAplScript")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteApplicationCustomStat
//
//
// Derived iStats.
//
// id is for ID of the resource.
func (a SysApi) DeleteApplicationCustomStat(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/customStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteApplicationCustomStat")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteApplicationService
//
//
// Application configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteApplicationService(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/service/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteApplicationService")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteApplicationTemplate
//
//
// Application templates.
//
// id is for ID of the resource.
func (a SysApi) DeleteApplicationTemplate(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/template/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteApplicationTemplate")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteConfig
//
//
// Save and load system configuration files.
//
// id is for ID of the resource.
func (a SysApi) DeleteConfig(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/config/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteConnection
//
//
// Displays or deletes active connections on the BIG-IP system.
//
// id is for ID of the resource.
func (a SysApi) DeleteConnection(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/connection/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteConnection")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteCryptoCert
//
//
// Certificate configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteCryptoCert(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/cert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteCryptoCert")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteCryptoClient
//
//
// Crypto client configuration..
//
// id is for ID of the resource.
func (a SysApi) DeleteCryptoClient(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/client/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteCryptoClient")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteCryptoCrl
//
//
// Certificate revocation list configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteCryptoCrl(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/crl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteCryptoCrl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteCryptoCsr
//
//
// Certificate Signing Request configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteCryptoCsr(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/csr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteCryptoCsr")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteCryptoFipsByHandle
//
//
// Manipulate FIPS key by its handle..
//
// id is for ID of the resource.
func (a SysApi) DeleteCryptoFipsByHandle(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/byHandle/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteCryptoFipsByHandle")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteCryptoFipsExternalHsm
//
//
// FIPS external hsm specific configuration..
//
// id is for ID of the resource.
func (a SysApi) DeleteCryptoFipsExternalHsm(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/externalHsm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteCryptoFipsExternalHsm")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteCryptoKey
//
//
// Key configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteCryptoKey(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/key/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteCryptoKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteCryptoServer
//
//
// Crypto server configuration..
//
// id is for ID of the resource.
func (a SysApi) DeleteCryptoServer(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/server/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteCryptoServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteDiskApplicationVolume
//
//
// Application Volume Configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteDiskApplicationVolume(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/applicationVolume/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteDiskApplicationVolume")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteEcmCloudProvider
//
//
// Describes the properties of all the cloud-providers.
//
// id is for ID of the resource.
func (a SysApi) DeleteEcmCloudProvider(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/cloudProvider/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteEcmCloudProvider")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteFileApacheSslCert
//
//
// SSL certificates management.
//
// id is for ID of the resource.
func (a SysApi) DeleteFileApacheSslCert(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/apacheSslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteFileApacheSslCert")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteFileDashboardViewset
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) DeleteFileDashboardViewset(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dashboardViewset/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteFileDashboardViewset")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteFileDataGroup
//
//
// External Data Group files management.
//
// id is for ID of the resource.
func (a SysApi) DeleteFileDataGroup(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dataGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteFileDataGroup")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteFileDeviceCapabilitiesDb
//
//
// Device capabilities DB file management.
//
// id is for ID of the resource.
func (a SysApi) DeleteFileDeviceCapabilitiesDb(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/deviceCapabilitiesDb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteFileDeviceCapabilitiesDb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteFileExternalMonitor
//
//
// External Monitor files management.
//
// id is for ID of the resource.
func (a SysApi) DeleteFileExternalMonitor(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/externalMonitor/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteFileExternalMonitor")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteFileIfile
//
//
// iFile files management.
//
// id is for ID of the resource.
func (a SysApi) DeleteFileIfile(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/ifile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteFileIfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteFileSslCert
//
//
// SSL certificates management.
//
// id is for ID of the resource.
func (a SysApi) DeleteFileSslCert(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteFileSslCert")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteFileSslCrl
//
//
// SSL CRL files management.
//
// id is for ID of the resource.
func (a SysApi) DeleteFileSslCrl(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCrl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteFileSslCrl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteFileSslCsr
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) DeleteFileSslCsr(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCsr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteFileSslCsr")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteFileSslKey
//
//
// SSL certificate keys management.
//
// id is for ID of the resource.
func (a SysApi) DeleteFileSslKey(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteFileSslKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteFixConnection
//
//
// FIX connection level stats.
//
// id is for ID of the resource.
func (a SysApi) DeleteFixConnection(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fixConnection/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteFixConnection")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteFolder
//
//
// Folder configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteFolder(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/folder/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteFolder")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteHaGroup
//
//
// Specifies the ha group used to calculate the failover score..
//
// id is for ID of the resource.
func (a SysApi) DeleteHaGroup(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteHaGroup")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteIcallHandlerPeriodic
//
//
// iCall periodic handler.
//
// id is for ID of the resource.
func (a SysApi) DeleteIcallHandlerPeriodic(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/periodic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteIcallHandlerPeriodic")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteIcallHandlerPerpetual
//
//
// iCall perpetual handler.
//
// id is for ID of the resource.
func (a SysApi) DeleteIcallHandlerPerpetual(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteIcallHandlerPerpetual")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteIcallHandlerPerpetualSubscriptions
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) DeleteIcallHandlerPerpetualSubscriptions(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/subscriptions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteIcallHandlerPerpetualSubscriptions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteIcallHandlerTriggered
//
//
// iCall event-triggered event handler.
//
// id is for ID of the resource.
func (a SysApi) DeleteIcallHandlerTriggered(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteIcallHandlerTriggered")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteIcallHandlerTriggeredSubscriptions
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) DeleteIcallHandlerTriggeredSubscriptions(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/subscriptions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteIcallHandlerTriggeredSubscriptions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteIcallIstatsTrigger
//
//
// Event trigger for iStats.
//
// id is for ID of the resource.
func (a SysApi) DeleteIcallIstatsTrigger(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/istatsTrigger/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteIcallIstatsTrigger")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteIcallScript
//
//
// iCall script.
//
// id is for ID of the resource.
func (a SysApi) DeleteIcallScript(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/script/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteIcallScript")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteIpfixElement
//
//
// IPFIX element configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteIpfixElement(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/element/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteIpfixElement")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteLogConfigDestinationArcsight
//
//
// Format messages to the ArcSight specification.
//
// id is for ID of the resource.
func (a SysApi) DeleteLogConfigDestinationArcsight(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/arcsight/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteLogConfigDestinationArcsight")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteLogConfigDestinationIpfix
//
//
// Formats logs into IPFIX messages and transmits them to a pool of IPFIX Collectors.
//
// id is for ID of the resource.
func (a SysApi) DeleteLogConfigDestinationIpfix(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/ipfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteLogConfigDestinationIpfix")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteLogConfigDestinationManagementPort
//
//
// Forwards messages to a destination through the management port.
//
// id is for ID of the resource.
func (a SysApi) DeleteLogConfigDestinationManagementPort(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/managementPort/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteLogConfigDestinationManagementPort")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteLogConfigDestinationRemoteHighSpeedLog
//
//
// Forwards messages to a pool.
//
// id is for ID of the resource.
func (a SysApi) DeleteLogConfigDestinationRemoteHighSpeedLog(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteHighSpeedLog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteLogConfigDestinationRemoteHighSpeedLog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteLogConfigDestinationRemoteSyslog
//
//
// Format messages to the Syslog format for remote logging.
//
// id is for ID of the resource.
func (a SysApi) DeleteLogConfigDestinationRemoteSyslog(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteSyslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteLogConfigDestinationRemoteSyslog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteLogConfigDestinationSplunk
//
//
// Format messages to the Splunk specification.
//
// id is for ID of the resource.
func (a SysApi) DeleteLogConfigDestinationSplunk(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/splunk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteLogConfigDestinationSplunk")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteLogConfigFilter
//
//
// Selectively route logs to log publishers.
//
// id is for ID of the resource.
func (a SysApi) DeleteLogConfigFilter(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/filter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteLogConfigFilter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteLogConfigPublisher
//
//
// List of log destinations.
//
// id is for ID of the resource.
func (a SysApi) DeleteLogConfigPublisher(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/publisher/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteLogConfigPublisher")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteLtcfgClassFields
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) DeleteLtcfgClassFields(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgClass/fields/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteLtcfgClassFields")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteLtcfgInstanceFields
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) DeleteLtcfgInstanceFields(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgInstance/fields/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteLtcfgInstanceFields")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteManagementIp
//
//
// Management port address configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteManagementIp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementIp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteManagementIp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteManagementRoute
//
//
// Route configuration for the management interface.
//
// id is for ID of the resource.
func (a SysApi) DeleteManagementRoute(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementRoute/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteManagementRoute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteNtpRestrict
//
//
// A restrict line in the NTP configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteNtpRestrict(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ntp/restrict/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteNtpRestrict")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeletePptpCallInfo
//
//
// Displays or deletes active pptp-calls on the BIG-IP system.
//
// id is for ID of the resource.
func (a SysApi) DeletePptpCallInfo(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/pptpCallInfo/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeletePptpCallInfo")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteSflowReceiver
//
//
// sFlow receiver configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteSflowReceiver(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/receiver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteSflowReceiver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteSmtpServer
//
//
// SMTP configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteSmtpServer(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/smtpServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteSmtpServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteSnmpCommunities
//
//
// Specifies SNMP community strings and limits them to specific oid subsets..
//
// id is for ID of the resource.
func (a SysApi) DeleteSnmpCommunities(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/communities/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteSnmpCommunities")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteSnmpTraps
//
//
// Generic interface for configuring SNMP traps..
//
// id is for ID of the resource.
func (a SysApi) DeleteSnmpTraps(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/traps/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteSnmpTraps")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteSnmpUsers
//
//
// Specifies user account information for use with SNMPv3..
//
// id is for ID of the resource.
func (a SysApi) DeleteSnmpUsers(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/users/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteSnmpUsers")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteSoftwareHotfix
//
//
// Manage hotfix images.
//
// id is for ID of the resource.
func (a SysApi) DeleteSoftwareHotfix(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/hotfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteSoftwareHotfix")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteSoftwareImage
//
//
// Manage software images.
//
// id is for ID of the resource.
func (a SysApi) DeleteSoftwareImage(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/image/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteSoftwareImage")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteSoftwareSignature
//
//
// Manage software signatures.
//
// id is for ID of the resource.
func (a SysApi) DeleteSoftwareSignature(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/signature/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteSoftwareSignature")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteSoftwareVolume
//
//
// Manage software volumes, or reboot to a specific volume.
//
// id is for ID of the resource.
func (a SysApi) DeleteSoftwareVolume(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/volume/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteSoftwareVolume")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteUcs
//
//
// Save and restore configuration from UCS files.
//
// id is for ID of the resource.
func (a SysApi) DeleteUcs(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ucs/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteUcs")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteUrlDbUrlCategory
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) DeleteUrlDbUrlCategory(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/urlCategory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling SysApi->DeleteUrlDbUrlCategory")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// GetApplication
//
//
// Configure an application.
//
// id is for ID of the resource.
func (a SysApi) GetApplication(id string) (*SysApplication, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysApplication), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetApplication")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysApplication)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetApplicationAplScript
//
//
// Scripts included by an application template.
//
// id is for ID of the resource.
func (a SysApi) GetApplicationAplScript(id string) (*SysApplicationAplScript, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/aplScript/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysApplicationAplScript), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetApplicationAplScript")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysApplicationAplScript)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetApplicationAplScriptList
//
//
// Scripts included by an application template..
func (a SysApi) GetApplicationAplScriptList() (*SysApplicationAplScriptList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/aplScript"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysApplicationAplScriptList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetApplicationCustomStat
//
//
// Derived iStats.
//
// id is for ID of the resource.
func (a SysApi) GetApplicationCustomStat(id string) (*SysApplicationCustomStat, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/customStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysApplicationCustomStat), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetApplicationCustomStat")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysApplicationCustomStat)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetApplicationCustomStatList
//
//
// Derived iStats..
func (a SysApi) GetApplicationCustomStatList() (*SysApplicationCustomStatList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/customStat"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysApplicationCustomStatList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetApplicationList
//
//
// Configure an application..
func (a SysApi) GetApplicationList() (*SysApplicationList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysApplicationList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetApplicationService
//
//
// Application configuration.
//
// id is for ID of the resource.
func (a SysApi) GetApplicationService(id string) (*SysApplicationService, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/service/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysApplicationService), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetApplicationService")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysApplicationService)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetApplicationServiceList
//
//
// Application configuration..
func (a SysApi) GetApplicationServiceList() (*SysApplicationServiceList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/service"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysApplicationServiceList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetApplicationTemplate
//
//
// Application templates.
//
// id is for ID of the resource.
func (a SysApi) GetApplicationTemplate(id string) (*SysApplicationTemplate, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/template/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysApplicationTemplate), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetApplicationTemplate")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysApplicationTemplate)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetApplicationTemplateActions
//
//
// Manage the set of actions associated with an application template..
//
// id is for ID of the resource.
func (a SysApi) GetApplicationTemplateActions(id string) (*SysApplicationTemplateActions, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/template/actions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysApplicationTemplateActions), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetApplicationTemplateActions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysApplicationTemplateActions)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetApplicationTemplateActionsList
//
//
// Manage the set of actions associated with an application template...
func (a SysApi) GetApplicationTemplateActionsList() (*SysApplicationTemplateActionsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/template/actions"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysApplicationTemplateActionsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetApplicationTemplateList
//
//
// Application templates..
func (a SysApi) GetApplicationTemplateList() (*SysApplicationTemplateList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/template"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysApplicationTemplateList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAutoscaleGroup
//
//
// Autoscale group information for Amazon Web Services(AWS)..
//
// id is for ID of the resource.
func (a SysApi) GetAutoscaleGroup(id string) (*SysAutoscaleGroup, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/autoscaleGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysAutoscaleGroup), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetAutoscaleGroup")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysAutoscaleGroup)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAutoscaleGroupList
//
//
// Autoscale group information for Amazon Web Services(AWS)...
func (a SysApi) GetAutoscaleGroupList() (*SysAutoscaleGroupList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/autoscaleGroup"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysAutoscaleGroupList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationSignatureList
//
//
// ..
func (a SysApi) GetClassificationSignatureList() (*SysClassificationSignatureList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/classificationSignature"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysClassificationSignatureList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClock
//
//
// Display the current date and time.
//
// id is for ID of the resource.
func (a SysApi) GetClock(id string) (*SysClock, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/clock/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysClock), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetClock")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysClock)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClockList
//
//
// Display the current date and time..
func (a SysApi) GetClockList() (*SysClockList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/clock"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysClockList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCluster
//
//
// Cluster configuration.
//
// id is for ID of the resource.
func (a SysApi) GetCluster(id string) (*SysCluster, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/cluster/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCluster), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetCluster")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCluster)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClusterList
//
//
// Cluster configuration..
func (a SysApi) GetClusterList() (*SysClusterList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/cluster"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysClusterList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetConfig
//
//
// Save and load system configuration files.
//
// id is for ID of the resource.
func (a SysApi) GetConfig(id string) (*SysConfig, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/config/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysConfig), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetConfigDiff
//
//
// View the difference between two SCF files, or a file to running configuration.
//
// id is for ID of the resource.
func (a SysApi) GetConfigDiff(id string) (*SysConfigDiff, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/configDiff/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysConfigDiff), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetConfigDiff")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysConfigDiff)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetConfigDiffList
//
//
// View the difference between two SCF files, or a file to running configuration..
func (a SysApi) GetConfigDiffList() (*SysConfigDiffList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/configDiff"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysConfigDiffList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetConfigList
//
//
// Save and load system configuration files..
func (a SysApi) GetConfigList() (*SysConfigList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/config"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysConfigList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetConnection
//
//
// Displays or deletes active connections on the BIG-IP system.
//
// id is for ID of the resource.
func (a SysApi) GetConnection(id string) (*SysConnection, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/connection/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysConnection), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetConnection")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysConnection)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetConnectionList
//
//
// Displays or deletes active connections on the BIG-IP system..
func (a SysApi) GetConnectionList() (*SysConnectionList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/connection"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysConnectionList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetConsole
//
//
// Configure the serial console.
//
// id is for ID of the resource.
func (a SysApi) GetConsole(id string) (*SysConsole, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/console/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysConsole), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetConsole")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysConsole)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetConsoleList
//
//
// Configure the serial console..
func (a SysApi) GetConsoleList() (*SysConsoleList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/console"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysConsoleList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCpu
//
//
// CPU statistics of system overall performance and on management hosts..
//
// id is for ID of the resource.
func (a SysApi) GetCpu(id string) (*SysCpu, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/cpu/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCpu), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetCpu")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCpu)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCpuList
//
//
// CPU statistics of system overall performance and on management hosts...
func (a SysApi) GetCpuList() (*SysCpuList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/cpu"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCpuList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCrypto
//
//
// Manage cryptographic objects such as keys and certificates..
//
// id is for ID of the resource.
func (a SysApi) GetCrypto(id string) (*SysCrypto, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCrypto), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetCrypto")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCrypto)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoCert
//
//
// Certificate configuration.
//
// id is for ID of the resource.
func (a SysApi) GetCryptoCert(id string) (*SysCryptoCert, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/cert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoCert), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetCryptoCert")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoCert)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoCertList
//
//
// Certificate configuration..
func (a SysApi) GetCryptoCertList() (*SysCryptoCertList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/cert"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoCertList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoCheckCertList
//
//
// Certificate expiration check utility..
func (a SysApi) GetCryptoCheckCertList() (*SysCryptoCheckCertList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/checkCert"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoCheckCertList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoClient
//
//
// Crypto client configuration..
//
// id is for ID of the resource.
func (a SysApi) GetCryptoClient(id string) (*SysCryptoClient, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/client/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoClient), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetCryptoClient")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoClient)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoClientList
//
//
// Crypto client configuration...
func (a SysApi) GetCryptoClientList() (*SysCryptoClientList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/client"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoClientList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoCrl
//
//
// Certificate revocation list configuration.
//
// id is for ID of the resource.
func (a SysApi) GetCryptoCrl(id string) (*SysCryptoCrl, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/crl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoCrl), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetCryptoCrl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoCrl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoCrlList
//
//
// Certificate revocation list configuration..
func (a SysApi) GetCryptoCrlList() (*SysCryptoCrlList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/crl"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoCrlList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoCsr
//
//
// Certificate Signing Request configuration.
//
// id is for ID of the resource.
func (a SysApi) GetCryptoCsr(id string) (*SysCryptoCsr, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/csr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoCsr), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetCryptoCsr")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoCsr)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoCsrList
//
//
// Certificate Signing Request configuration..
func (a SysApi) GetCryptoCsrList() (*SysCryptoCsrList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/csr"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoCsrList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoFips
//
//
// FIPS specific configuration..
//
// id is for ID of the resource.
func (a SysApi) GetCryptoFips(id string) (*SysCryptoFips, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoFips), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetCryptoFips")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoFips)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoFipsByHandleList
//
//
// Manipulate FIPS key by its handle...
func (a SysApi) GetCryptoFipsByHandleList() (*SysCryptoFipsByHandleList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/byHandle"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoFipsByHandleList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoFipsExternalHsm
//
//
// FIPS external hsm specific configuration..
//
// id is for ID of the resource.
func (a SysApi) GetCryptoFipsExternalHsm(id string) (*SysCryptoFipsExternalHsm, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/externalHsm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoFipsExternalHsm), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetCryptoFipsExternalHsm")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoFipsExternalHsm)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoFipsExternalHsmList
//
//
// FIPS external hsm specific configuration...
func (a SysApi) GetCryptoFipsExternalHsmList() (*SysCryptoFipsExternalHsmList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/externalHsm"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoFipsExternalHsmList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoFipsKey
//
//
// FIPS key specific configuration..
//
// id is for ID of the resource.
func (a SysApi) GetCryptoFipsKey(id string) (*SysCryptoFipsKey, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/key/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoFipsKey), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetCryptoFipsKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoFipsKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoFipsKeyList
//
//
// FIPS key specific configuration...
func (a SysApi) GetCryptoFipsKeyList() (*SysCryptoFipsKeyList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/key"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoFipsKeyList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoFipsList
//
//
// FIPS specific configuration...
func (a SysApi) GetCryptoFipsList() (*SysCryptoFipsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoFipsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoKey
//
//
// Key configuration.
//
// id is for ID of the resource.
func (a SysApi) GetCryptoKey(id string) (*SysCryptoKey, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/key/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoKey), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetCryptoKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoKeyList
//
//
// Key configuration..
func (a SysApi) GetCryptoKeyList() (*SysCryptoKeyList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/key"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoKeyList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoList
//
//
// Manage cryptographic objects such as keys and certificates...
func (a SysApi) GetCryptoList() (*SysCryptoList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoMasterKey
//
//
// Displays internal encryption key information on a system..
//
// id is for ID of the resource.
func (a SysApi) GetCryptoMasterKey(id string) (*SysCryptoMasterKey, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/masterKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoMasterKey), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetCryptoMasterKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoMasterKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoMasterKeyList
//
//
// Displays internal encryption key information on a system...
func (a SysApi) GetCryptoMasterKeyList() (*SysCryptoMasterKeyList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/masterKey"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoMasterKeyList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoPkcs12List
//
//
// PKCS12 configuration..
func (a SysApi) GetCryptoPkcs12List() (*SysCryptoPkcs12List, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/pkcs12"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoPkcs12List)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoServer
//
//
// Crypto server configuration..
//
// id is for ID of the resource.
func (a SysApi) GetCryptoServer(id string) (*SysCryptoServer, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/server/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoServer), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetCryptoServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoServer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetCryptoServerList
//
//
// Crypto server configuration...
func (a SysApi) GetCryptoServerList() (*SysCryptoServerList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/server"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysCryptoServerList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDaemonHa
//
//
// System daemon HA configuration.
//
// id is for ID of the resource.
func (a SysApi) GetDaemonHa(id string) (*SysDaemonHa, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonHa/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonHa), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetDaemonHa")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDaemonHa)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDaemonHaList
//
//
// System daemon HA configuration..
func (a SysApi) GetDaemonHaList() (*SysDaemonHaList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonHa"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDaemonHaList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDaemonLogSettings
//
//
// Daemon log configuration.
//
// id is for ID of the resource.
func (a SysApi) GetDaemonLogSettings(id string) (*SysDaemonLogSettings, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonLogSettings), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetDaemonLogSettings")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDaemonLogSettings)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDaemonLogSettingsClusterd
//
//
// The clusterd daemon configuration on the system..
//
// id is for ID of the resource.
func (a SysApi) GetDaemonLogSettingsClusterd(id string) (*SysDaemonLogSettingsClusterd, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/clusterd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonLogSettingsClusterd), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetDaemonLogSettingsClusterd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDaemonLogSettingsClusterd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDaemonLogSettingsClusterdList
//
//
// The clusterd daemon configuration on the system...
func (a SysApi) GetDaemonLogSettingsClusterdList() (*SysDaemonLogSettingsClusterdList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/clusterd"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDaemonLogSettingsClusterdList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDaemonLogSettingsCsyncd
//
//
// The csyncd daemon configuration on the system..
//
// id is for ID of the resource.
func (a SysApi) GetDaemonLogSettingsCsyncd(id string) (*SysDaemonLogSettingsCsyncd, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/csyncd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonLogSettingsCsyncd), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetDaemonLogSettingsCsyncd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDaemonLogSettingsCsyncd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDaemonLogSettingsCsyncdList
//
//
// The csyncd daemon configuration on the system...
func (a SysApi) GetDaemonLogSettingsCsyncdList() (*SysDaemonLogSettingsCsyncdList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/csyncd"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDaemonLogSettingsCsyncdList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDaemonLogSettingsIcrd
//
//
// The icrd daemon configuration on the system..
//
// id is for ID of the resource.
func (a SysApi) GetDaemonLogSettingsIcrd(id string) (*SysDaemonLogSettingsIcrd, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/icrd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonLogSettingsIcrd), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetDaemonLogSettingsIcrd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDaemonLogSettingsIcrd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDaemonLogSettingsIcrdList
//
//
// The icrd daemon configuration on the system...
func (a SysApi) GetDaemonLogSettingsIcrdList() (*SysDaemonLogSettingsIcrdList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/icrd"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDaemonLogSettingsIcrdList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDaemonLogSettingsLind
//
//
// The lind daemon configuration on the system..
//
// id is for ID of the resource.
func (a SysApi) GetDaemonLogSettingsLind(id string) (*SysDaemonLogSettingsLind, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/lind/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonLogSettingsLind), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetDaemonLogSettingsLind")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDaemonLogSettingsLind)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDaemonLogSettingsLindList
//
//
// The lind daemon configuration on the system...
func (a SysApi) GetDaemonLogSettingsLindList() (*SysDaemonLogSettingsLindList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/lind"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDaemonLogSettingsLindList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDaemonLogSettingsList
//
//
// Daemon log configuration..
func (a SysApi) GetDaemonLogSettingsList() (*SysDaemonLogSettingsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDaemonLogSettingsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDaemonLogSettingsMcpd
//
//
// The mcpd daemon configuration on the system..
//
// id is for ID of the resource.
func (a SysApi) GetDaemonLogSettingsMcpd(id string) (*SysDaemonLogSettingsMcpd, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/mcpd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonLogSettingsMcpd), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetDaemonLogSettingsMcpd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDaemonLogSettingsMcpd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDaemonLogSettingsMcpdList
//
//
// The mcpd daemon configuration on the system...
func (a SysApi) GetDaemonLogSettingsMcpdList() (*SysDaemonLogSettingsMcpdList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/mcpd"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDaemonLogSettingsMcpdList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDaemonLogSettingsTmm
//
//
// The tmm daemon configuration on the system..
//
// id is for ID of the resource.
func (a SysApi) GetDaemonLogSettingsTmm(id string) (*SysDaemonLogSettingsTmm, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/tmm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonLogSettingsTmm), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetDaemonLogSettingsTmm")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDaemonLogSettingsTmm)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDaemonLogSettingsTmmList
//
//
// The tmm daemon configuration on the system...
func (a SysApi) GetDaemonLogSettingsTmmList() (*SysDaemonLogSettingsTmmList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/tmm"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDaemonLogSettingsTmmList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDatastor
//
//
// Optimization data storage configuration.
//
// id is for ID of the resource.
func (a SysApi) GetDatastor(id string) (*SysDatastor, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/datastor/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDatastor), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetDatastor")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDatastor)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDatastorList
//
//
// Optimization data storage configuration..
func (a SysApi) GetDatastorList() (*SysDatastorList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/datastor"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDatastorList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDb
//
//
// General system properties.
//
// id is for ID of the resource.
func (a SysApi) GetDb(id string) (*SysDb, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/db/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDb), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetDb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDbList
//
//
// General system properties..
func (a SysApi) GetDbList() (*SysDbList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/db"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDbList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDisk
//
//
// Manage disk configuration and utilization.
//
// id is for ID of the resource.
func (a SysApi) GetDisk(id string) (*SysDisk, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDisk), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetDisk")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDisk)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDiskApplicationVolume
//
//
// Application Volume Configuration.
//
// id is for ID of the resource.
func (a SysApi) GetDiskApplicationVolume(id string) (*SysDiskApplicationVolume, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/applicationVolume/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDiskApplicationVolume), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetDiskApplicationVolume")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDiskApplicationVolume)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDiskApplicationVolumeList
//
//
// Application Volume Configuration..
func (a SysApi) GetDiskApplicationVolumeList() (*SysDiskApplicationVolumeList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/applicationVolume"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDiskApplicationVolumeList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDiskDirectory
//
//
// System directory resize operations..
//
// id is for ID of the resource.
func (a SysApi) GetDiskDirectory(id string) (*SysDiskDirectory, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/directory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDiskDirectory), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetDiskDirectory")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDiskDirectory)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDiskDirectoryList
//
//
// System directory resize operations...
func (a SysApi) GetDiskDirectoryList() (*SysDiskDirectoryList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/directory"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDiskDirectoryList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDiskList
//
//
// Manage disk configuration and utilization..
func (a SysApi) GetDiskList() (*SysDiskList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDiskList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDiskLogicalDisk
//
//
// Logical Disk Configuration.
//
// id is for ID of the resource.
func (a SysApi) GetDiskLogicalDisk(id string) (*SysDiskLogicalDisk, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/logicalDisk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDiskLogicalDisk), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetDiskLogicalDisk")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDiskLogicalDisk)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDiskLogicalDiskList
//
//
// Logical Disk Configuration..
func (a SysApi) GetDiskLogicalDiskList() (*SysDiskLogicalDiskList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/logicalDisk"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDiskLogicalDiskList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDns
//
//
// DNS configuration.
//
// id is for ID of the resource.
func (a SysApi) GetDns(id string) (*SysDns, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/dns/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDns), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetDns")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDns)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsList
//
//
// DNS configuration..
func (a SysApi) GetDnsList() (*SysDnsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/dns"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysDnsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetEcm
//
//
// Configures the Elastic Compute Manager(ECM).
//
// id is for ID of the resource.
func (a SysApi) GetEcm(id string) (*SysEcm, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysEcm), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetEcm")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysEcm)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetEcmCloudProvider
//
//
// Describes the properties of all the cloud-providers.
//
// id is for ID of the resource.
func (a SysApi) GetEcmCloudProvider(id string) (*SysEcmCloudProvider, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/cloudProvider/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysEcmCloudProvider), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetEcmCloudProvider")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysEcmCloudProvider)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetEcmCloudProviderList
//
//
// Describes the properties of all the cloud-providers..
func (a SysApi) GetEcmCloudProviderList() (*SysEcmCloudProviderList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/cloudProvider"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysEcmCloudProviderList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetEcmConfig
//
//
// Specifies the ecm configuration.
//
// id is for ID of the resource.
func (a SysApi) GetEcmConfig(id string) (*SysEcmConfig, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/config/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysEcmConfig), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetEcmConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysEcmConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetEcmConfigList
//
//
// Specifies the ecm configuration..
func (a SysApi) GetEcmConfigList() (*SysEcmConfigList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/config"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysEcmConfigList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetEcmList
//
//
// Configures the Elastic Compute Manager(ECM)..
func (a SysApi) GetEcmList() (*SysEcmList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysEcmList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFailover
//
//
// Redundant system failover state.
//
// id is for ID of the resource.
func (a SysApi) GetFailover(id string) (*SysFailover, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/failover/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFailover), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFailover")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFailover)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFailoverList
//
//
// Redundant system failover state..
func (a SysApi) GetFailoverList() (*SysFailoverList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/failover"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFailoverList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFeatureModule
//
//
// Feature module configuration.
//
// id is for ID of the resource.
func (a SysApi) GetFeatureModule(id string) (*SysFeatureModule, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/featureModule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFeatureModule), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFeatureModule")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFeatureModule)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFeatureModuleList
//
//
// Feature module configuration..
func (a SysApi) GetFeatureModuleList() (*SysFeatureModuleList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/featureModule"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFeatureModuleList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFile
//
//
// System files management.
//
// id is for ID of the resource.
func (a SysApi) GetFile(id string) (*SysFile, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFile), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileApacheSslCert
//
//
// SSL certificates management.
//
// id is for ID of the resource.
func (a SysApi) GetFileApacheSslCert(id string) (*SysFileApacheSslCert, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/apacheSslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileApacheSslCert), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFileApacheSslCert")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileApacheSslCert)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileApacheSslCertBundleCertificates
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetFileApacheSslCertBundleCertificates(id string) (*SysFileApacheSslCertBundleCertificates, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/apacheSslCert/bundleCertificates/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileApacheSslCertBundleCertificates), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFileApacheSslCertBundleCertificates")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileApacheSslCertBundleCertificates)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileApacheSslCertBundleCertificatesList
//
//
// ..
func (a SysApi) GetFileApacheSslCertBundleCertificatesList() (*SysFileApacheSslCertBundleCertificatesList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/apacheSslCert/bundleCertificates"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileApacheSslCertBundleCertificatesList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileApacheSslCertList
//
//
// SSL certificates management..
func (a SysApi) GetFileApacheSslCertList() (*SysFileApacheSslCertList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/apacheSslCert"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileApacheSslCertList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileDashboardViewset
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetFileDashboardViewset(id string) (*SysFileDashboardViewset, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dashboardViewset/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileDashboardViewset), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFileDashboardViewset")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileDashboardViewset)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileDashboardViewsetList
//
//
// ..
func (a SysApi) GetFileDashboardViewsetList() (*SysFileDashboardViewsetList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dashboardViewset"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileDashboardViewsetList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileDataGroup
//
//
// External Data Group files management.
//
// id is for ID of the resource.
func (a SysApi) GetFileDataGroup(id string) (*SysFileDataGroup, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dataGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileDataGroup), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFileDataGroup")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileDataGroup)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileDataGroupList
//
//
// External Data Group files management..
func (a SysApi) GetFileDataGroupList() (*SysFileDataGroupList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dataGroup"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileDataGroupList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileDeviceCapabilitiesDb
//
//
// Device capabilities DB file management.
//
// id is for ID of the resource.
func (a SysApi) GetFileDeviceCapabilitiesDb(id string) (*SysFileDeviceCapabilitiesDb, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/deviceCapabilitiesDb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileDeviceCapabilitiesDb), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFileDeviceCapabilitiesDb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileDeviceCapabilitiesDb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileDeviceCapabilitiesDbList
//
//
// Device capabilities DB file management..
func (a SysApi) GetFileDeviceCapabilitiesDbList() (*SysFileDeviceCapabilitiesDbList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/deviceCapabilitiesDb"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileDeviceCapabilitiesDbList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileExternalMonitor
//
//
// External Monitor files management.
//
// id is for ID of the resource.
func (a SysApi) GetFileExternalMonitor(id string) (*SysFileExternalMonitor, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/externalMonitor/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileExternalMonitor), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFileExternalMonitor")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileExternalMonitor)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileExternalMonitorList
//
//
// External Monitor files management..
func (a SysApi) GetFileExternalMonitorList() (*SysFileExternalMonitorList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/externalMonitor"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileExternalMonitorList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileIfile
//
//
// iFile files management.
//
// id is for ID of the resource.
func (a SysApi) GetFileIfile(id string) (*SysFileIfile, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/ifile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileIfile), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFileIfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileIfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileIfileList
//
//
// iFile files management..
func (a SysApi) GetFileIfileList() (*SysFileIfileList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/ifile"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileIfileList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileList
//
//
// System files management..
func (a SysApi) GetFileList() (*SysFileList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileSslCert
//
//
// SSL certificates management.
//
// id is for ID of the resource.
func (a SysApi) GetFileSslCert(id string) (*SysFileSslCert, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSslCert), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFileSslCert")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileSslCert)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileSslCertBundleCertificates
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetFileSslCertBundleCertificates(id string) (*SysFileSslCertBundleCertificates, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCert/bundleCertificates/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSslCertBundleCertificates), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFileSslCertBundleCertificates")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileSslCertBundleCertificates)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileSslCertBundleCertificatesList
//
//
// ..
func (a SysApi) GetFileSslCertBundleCertificatesList() (*SysFileSslCertBundleCertificatesList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCert/bundleCertificates"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileSslCertBundleCertificatesList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileSslCertList
//
//
// SSL certificates management..
func (a SysApi) GetFileSslCertList() (*SysFileSslCertList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCert"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileSslCertList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileSslCrl
//
//
// SSL CRL files management.
//
// id is for ID of the resource.
func (a SysApi) GetFileSslCrl(id string) (*SysFileSslCrl, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCrl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSslCrl), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFileSslCrl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileSslCrl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileSslCrlList
//
//
// SSL CRL files management..
func (a SysApi) GetFileSslCrlList() (*SysFileSslCrlList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCrl"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileSslCrlList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileSslCsr
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetFileSslCsr(id string) (*SysFileSslCsr, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCsr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSslCsr), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFileSslCsr")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileSslCsr)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileSslCsrList
//
//
// ..
func (a SysApi) GetFileSslCsrList() (*SysFileSslCsrList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCsr"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileSslCsrList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileSslKey
//
//
// SSL certificate keys management.
//
// id is for ID of the resource.
func (a SysApi) GetFileSslKey(id string) (*SysFileSslKey, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSslKey), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFileSslKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileSslKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileSslKeyList
//
//
// SSL certificate keys management..
func (a SysApi) GetFileSslKeyList() (*SysFileSslKeyList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslKey"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileSslKeyList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileSystemSslCert
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetFileSystemSslCert(id string) (*SysFileSystemSslCert, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/systemSslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSystemSslCert), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFileSystemSslCert")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileSystemSslCert)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileSystemSslCertBundleCertificates
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetFileSystemSslCertBundleCertificates(id string) (*SysFileSystemSslCertBundleCertificates, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/systemSslCert/bundleCertificates/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSystemSslCertBundleCertificates), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFileSystemSslCertBundleCertificates")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileSystemSslCertBundleCertificates)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileSystemSslCertBundleCertificatesList
//
//
// ..
func (a SysApi) GetFileSystemSslCertBundleCertificatesList() (*SysFileSystemSslCertBundleCertificatesList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/systemSslCert/bundleCertificates"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileSystemSslCertBundleCertificatesList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileSystemSslCertList
//
//
// ..
func (a SysApi) GetFileSystemSslCertList() (*SysFileSystemSslCertList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/systemSslCert"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileSystemSslCertList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileSystemSslKey
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetFileSystemSslKey(id string) (*SysFileSystemSslKey, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/systemSslKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSystemSslKey), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFileSystemSslKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileSystemSslKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFileSystemSslKeyList
//
//
// ..
func (a SysApi) GetFileSystemSslKeyList() (*SysFileSystemSslKeyList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/systemSslKey"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFileSystemSslKeyList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFixConnection
//
//
// FIX connection level stats.
//
// id is for ID of the resource.
func (a SysApi) GetFixConnection(id string) (*SysFixConnection, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fixConnection/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFixConnection), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFixConnection")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFixConnection)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFixConnectionList
//
//
// FIX connection level stats..
func (a SysApi) GetFixConnectionList() (*SysFixConnectionList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fixConnection"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFixConnectionList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFolder
//
//
// Folder configuration.
//
// id is for ID of the resource.
func (a SysApi) GetFolder(id string) (*SysFolder, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/folder/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFolder), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFolder")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFolder)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFolderList
//
//
// Folder configuration..
func (a SysApi) GetFolderList() (*SysFolderList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/folder"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFolderList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFpga
//
//
// FPGA(Field-Programmable Gate Array) firmware configuration.
//
// id is for ID of the resource.
func (a SysApi) GetFpga(id string) (*SysFpga, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fpga/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFpga), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFpga")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFpga)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFpgaFirmwareConfig
//
//
// The current FPGA firmware configuration.
//
// id is for ID of the resource.
func (a SysApi) GetFpgaFirmwareConfig(id string) (*SysFpgaFirmwareConfig, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fpga/firmwareConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFpgaFirmwareConfig), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFpgaFirmwareConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFpgaFirmwareConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFpgaFirmwareConfigList
//
//
// The current FPGA firmware configuration..
func (a SysApi) GetFpgaFirmwareConfigList() (*SysFpgaFirmwareConfigList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fpga/firmwareConfig"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFpgaFirmwareConfigList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFpgaInfo
//
//
// FPGA firmware information on the system.
//
// id is for ID of the resource.
func (a SysApi) GetFpgaInfo(id string) (*SysFpgaInfo, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fpga/info/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFpgaInfo), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetFpgaInfo")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFpgaInfo)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFpgaInfoList
//
//
// FPGA firmware information on the system..
func (a SysApi) GetFpgaInfoList() (*SysFpgaInfoList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fpga/info"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFpgaInfoList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetFpgaList
//
//
// FPGA(Field-Programmable Gate Array) firmware configuration..
func (a SysApi) GetFpgaList() (*SysFpgaList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fpga"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysFpgaList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetGeoipList
//
//
// Load GeoIP data files..
func (a SysApi) GetGeoipList() (*SysGeoipList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/geoip"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysGeoipList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetGlobalSettings
//
//
// General system settings.
//
// id is for ID of the resource.
func (a SysApi) GetGlobalSettings(id string) (*SysGlobalSettings, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/globalSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysGlobalSettings), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetGlobalSettings")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysGlobalSettings)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetGlobalSettingsList
//
//
// General system settings..
func (a SysApi) GetGlobalSettingsList() (*SysGlobalSettingsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/globalSettings"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysGlobalSettingsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHaGroup
//
//
// Specifies the ha group used to calculate the failover score..
//
// id is for ID of the resource.
func (a SysApi) GetHaGroup(id string) (*SysHaGroup, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysHaGroup), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetHaGroup")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysHaGroup)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHaGroupList
//
//
// Specifies the ha group used to calculate the failover score...
func (a SysApi) GetHaGroupList() (*SysHaGroupList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haGroup"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysHaGroupList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHaMirror
//
//
// Statistics for connection mirroring..
//
// id is for ID of the resource.
func (a SysApi) GetHaMirror(id string) (*SysHaMirror, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haMirror/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysHaMirror), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetHaMirror")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysHaMirror)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHaMirrorList
//
//
// Statistics for connection mirroring...
func (a SysApi) GetHaMirrorList() (*SysHaMirrorList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haMirror"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysHaMirrorList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHaStatus
//
//
// Displays the settings and status for high availability on a system..
//
// id is for ID of the resource.
func (a SysApi) GetHaStatus(id string) (*SysHaStatus, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haStatus/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysHaStatus), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetHaStatus")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysHaStatus)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHaStatusList
//
//
// Displays the settings and status for high availability on a system...
func (a SysApi) GetHaStatusList() (*SysHaStatusList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haStatus"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysHaStatusList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHardware
//
//
// View hardware information.
//
// id is for ID of the resource.
func (a SysApi) GetHardware(id string) (*SysHardware, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/hardware/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysHardware), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetHardware")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysHardware)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHardwareList
//
//
// View hardware information..
func (a SysApi) GetHardwareList() (*SysHardwareList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/hardware"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysHardwareList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHostInfo
//
//
// Host statistics, including system memory, CPU, and processor.
//
// id is for ID of the resource.
func (a SysApi) GetHostInfo(id string) (*SysHostInfo, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/hostInfo/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysHostInfo), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetHostInfo")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysHostInfo)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHostInfoList
//
//
// Host statistics, including system memory, CPU, and processor..
func (a SysApi) GetHostInfoList() (*SysHostInfoList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/hostInfo"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysHostInfoList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHttpd
//
//
// HTTPD configuration.
//
// id is for ID of the resource.
func (a SysApi) GetHttpd(id string) (*SysHttpd, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/httpd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysHttpd), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetHttpd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysHttpd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHttpdList
//
//
// HTTPD configuration..
func (a SysApi) GetHttpdList() (*SysHttpdList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/httpd"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysHttpdList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHypervisorInfo
//
//
// Configuration settings proposed by the vCMP hypervisor. (vCMP guest only).
//
// id is for ID of the resource.
func (a SysApi) GetHypervisorInfo(id string) (*SysHypervisorInfo, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/hypervisorInfo/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysHypervisorInfo), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetHypervisorInfo")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysHypervisorInfo)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHypervisorInfoList
//
//
// Configuration settings proposed by the vCMP hypervisor. (vCMP guest only)..
func (a SysApi) GetHypervisorInfoList() (*SysHypervisorInfoList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/hypervisorInfo"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysHypervisorInfoList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcall
//
//
// Manage iCall configuration items.
//
// id is for ID of the resource.
func (a SysApi) GetIcall(id string) (*SysIcall, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcall), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetIcall")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcall)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcallEventList
//
//
// iCall event..
func (a SysApi) GetIcallEventList() (*SysIcallEventList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/event"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcallEventList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcallHandler
//
//
// Manage the iCall event handler configuration items.
//
// id is for ID of the resource.
func (a SysApi) GetIcallHandler(id string) (*SysIcallHandler, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallHandler), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetIcallHandler")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcallHandler)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcallHandlerList
//
//
// Manage the iCall event handler configuration items..
func (a SysApi) GetIcallHandlerList() (*SysIcallHandlerList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcallHandlerList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcallHandlerPeriodic
//
//
// iCall periodic handler.
//
// id is for ID of the resource.
func (a SysApi) GetIcallHandlerPeriodic(id string) (*SysIcallHandlerPeriodic, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/periodic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallHandlerPeriodic), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetIcallHandlerPeriodic")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcallHandlerPeriodic)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcallHandlerPeriodicList
//
//
// iCall periodic handler..
func (a SysApi) GetIcallHandlerPeriodicList() (*SysIcallHandlerPeriodicList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/periodic"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcallHandlerPeriodicList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcallHandlerPerpetual
//
//
// iCall perpetual handler.
//
// id is for ID of the resource.
func (a SysApi) GetIcallHandlerPerpetual(id string) (*SysIcallHandlerPerpetual, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallHandlerPerpetual), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetIcallHandlerPerpetual")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcallHandlerPerpetual)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcallHandlerPerpetualList
//
//
// iCall perpetual handler..
func (a SysApi) GetIcallHandlerPerpetualList() (*SysIcallHandlerPerpetualList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcallHandlerPerpetualList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcallHandlerPerpetualSubscriptions
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetIcallHandlerPerpetualSubscriptions(id string) (*SysIcallHandlerPerpetualSubscriptions, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/subscriptions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallHandlerPerpetualSubscriptions), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetIcallHandlerPerpetualSubscriptions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcallHandlerPerpetualSubscriptions)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcallHandlerPerpetualSubscriptionsList
//
//
// ..
func (a SysApi) GetIcallHandlerPerpetualSubscriptionsList() (*SysIcallHandlerPerpetualSubscriptionsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/subscriptions"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcallHandlerPerpetualSubscriptionsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcallHandlerTriggered
//
//
// iCall event-triggered event handler.
//
// id is for ID of the resource.
func (a SysApi) GetIcallHandlerTriggered(id string) (*SysIcallHandlerTriggered, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallHandlerTriggered), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetIcallHandlerTriggered")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcallHandlerTriggered)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcallHandlerTriggeredList
//
//
// iCall event-triggered event handler..
func (a SysApi) GetIcallHandlerTriggeredList() (*SysIcallHandlerTriggeredList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcallHandlerTriggeredList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcallHandlerTriggeredSubscriptions
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetIcallHandlerTriggeredSubscriptions(id string) (*SysIcallHandlerTriggeredSubscriptions, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/subscriptions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallHandlerTriggeredSubscriptions), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetIcallHandlerTriggeredSubscriptions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcallHandlerTriggeredSubscriptions)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcallHandlerTriggeredSubscriptionsList
//
//
// ..
func (a SysApi) GetIcallHandlerTriggeredSubscriptionsList() (*SysIcallHandlerTriggeredSubscriptionsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/subscriptions"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcallHandlerTriggeredSubscriptionsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcallIstatsTrigger
//
//
// Event trigger for iStats.
//
// id is for ID of the resource.
func (a SysApi) GetIcallIstatsTrigger(id string) (*SysIcallIstatsTrigger, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/istatsTrigger/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallIstatsTrigger), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetIcallIstatsTrigger")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcallIstatsTrigger)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcallIstatsTriggerList
//
//
// Event trigger for iStats..
func (a SysApi) GetIcallIstatsTriggerList() (*SysIcallIstatsTriggerList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/istatsTrigger"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcallIstatsTriggerList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcallList
//
//
// Manage iCall configuration items..
func (a SysApi) GetIcallList() (*SysIcallList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcallList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcallPublisher
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetIcallPublisher(id string) (*SysIcallPublisher, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/publisher/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallPublisher), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetIcallPublisher")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcallPublisher)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcallPublisherList
//
//
// ..
func (a SysApi) GetIcallPublisherList() (*SysIcallPublisherList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/publisher"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcallPublisherList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcallScript
//
//
// iCall script.
//
// id is for ID of the resource.
func (a SysApi) GetIcallScript(id string) (*SysIcallScript, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/script/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallScript), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetIcallScript")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcallScript)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcallScriptList
//
//
// iCall script..
func (a SysApi) GetIcallScriptList() (*SysIcallScriptList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/script"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcallScriptList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcmpStat
//
//
// Standard ICMP statistics, including ICMPv4 packets and errors, and ICMPv6 packets and errors..
//
// id is for ID of the resource.
func (a SysApi) GetIcmpStat(id string) (*SysIcmpStat, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icmpStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcmpStat), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetIcmpStat")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcmpStat)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcmpStatList
//
//
// Standard ICMP statistics, including ICMPv4 packets and errors, and ICMPv6 packets and errors...
func (a SysApi) GetIcmpStatList() (*SysIcmpStatList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icmpStat"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcmpStatList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcontrolSoap
//
//
// iControl SOAP configuration.
//
// id is for ID of the resource.
func (a SysApi) GetIcontrolSoap(id string) (*SysIcontrolSoap, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icontrolSoap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcontrolSoap), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetIcontrolSoap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcontrolSoap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIcontrolSoapList
//
//
// iControl SOAP configuration..
func (a SysApi) GetIcontrolSoapList() (*SysIcontrolSoapList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icontrolSoap"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIcontrolSoapList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIpAddress
//
//
// View configured IP addresses.
//
// id is for ID of the resource.
func (a SysApi) GetIpAddress(id string) (*SysIpAddress, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipAddress/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIpAddress), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetIpAddress")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIpAddress)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIpAddressList
//
//
// View configured IP addresses..
func (a SysApi) GetIpAddressList() (*SysIpAddressList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipAddress"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIpAddressList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIpStat
//
//
// Standard IP statistics, including IPv4 and IPv6 packets, fragments, fragments reassembled, and errors..
//
// id is for ID of the resource.
func (a SysApi) GetIpStat(id string) (*SysIpStat, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIpStat), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetIpStat")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIpStat)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIpStatList
//
//
// Standard IP statistics, including IPv4 and IPv6 packets, fragments, fragments reassembled, and errors...
func (a SysApi) GetIpStatList() (*SysIpStatList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipStat"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIpStatList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIpfix
//
//
// Manages the common ipfix interface.
//
// id is for ID of the resource.
func (a SysApi) GetIpfix(id string) (*SysIpfix, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIpfix), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetIpfix")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIpfix)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIpfixDestination
//
//
// IPFIX destination statistics, including Template and Data Record counts.
//
// id is for ID of the resource.
func (a SysApi) GetIpfixDestination(id string) (*SysIpfixDestination, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/destination/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIpfixDestination), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetIpfixDestination")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIpfixDestination)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIpfixDestinationList
//
//
// IPFIX destination statistics, including Template and Data Record counts..
func (a SysApi) GetIpfixDestinationList() (*SysIpfixDestinationList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/destination"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIpfixDestinationList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIpfixElement
//
//
// IPFIX element configuration.
//
// id is for ID of the resource.
func (a SysApi) GetIpfixElement(id string) (*SysIpfixElement, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/element/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIpfixElement), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetIpfixElement")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIpfixElement)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIpfixElementList
//
//
// IPFIX element configuration..
func (a SysApi) GetIpfixElementList() (*SysIpfixElementList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/element"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIpfixElementList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIpfixIrules
//
//
// IPFIX iRules statistics, including allocated and outstanding memory.
//
// id is for ID of the resource.
func (a SysApi) GetIpfixIrules(id string) (*SysIpfixIrules, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/irules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIpfixIrules), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetIpfixIrules")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIpfixIrules)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIpfixIrulesList
//
//
// IPFIX iRules statistics, including allocated and outstanding memory..
func (a SysApi) GetIpfixIrulesList() (*SysIpfixIrulesList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/irules"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIpfixIrulesList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIpfixList
//
//
// Manages the common ipfix interface..
func (a SysApi) GetIpfixList() (*SysIpfixList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIpfixList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIprepList
//
//
// ..
func (a SysApi) GetIprepList() (*SysIprepList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/iprep"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIprepList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIprepStatus
//
//
// Display the IP reputation database update status.
//
// id is for ID of the resource.
func (a SysApi) GetIprepStatus(id string) (*SysIprepStatus, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/iprepStatus/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIprepStatus), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetIprepStatus")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIprepStatus)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIprepStatusList
//
//
// Display the IP reputation database update status..
func (a SysApi) GetIprepStatusList() (*SysIprepStatusList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/iprepStatus"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysIprepStatusList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLicense
//
//
// Manage the system license.
//
// id is for ID of the resource.
func (a SysApi) GetLicense(id string) (*SysLicense, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/license/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLicense), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetLicense")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLicense)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLicenseList
//
//
// Manage the system license..
func (a SysApi) GetLicenseList() (*SysLicenseList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/license"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLicenseList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLog
//
//
// View system log files.
//
// id is for ID of the resource.
func (a SysApi) GetLog(id string) (*SysLog, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/log/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLog), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetLog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLog)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfig
//
//
// Manages the common logging interface.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfig(id string) (*SysLogConfig, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfig), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetLogConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigDestination
//
//
// Log Destination configuration.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigDestination(id string) (*SysLogConfigDestination, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestination), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetLogConfigDestination")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigDestination)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigDestinationAlertd
//
//
// Forwards messages to the AlertD daemon.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigDestinationAlertd(id string) (*SysLogConfigDestinationAlertd, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/alertd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationAlertd), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetLogConfigDestinationAlertd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigDestinationAlertd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigDestinationAlertdList
//
//
// Forwards messages to the AlertD daemon..
func (a SysApi) GetLogConfigDestinationAlertdList() (*SysLogConfigDestinationAlertdList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/alertd"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigDestinationAlertdList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigDestinationArcsight
//
//
// Format messages to the ArcSight specification.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigDestinationArcsight(id string) (*SysLogConfigDestinationArcsight, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/arcsight/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationArcsight), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetLogConfigDestinationArcsight")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigDestinationArcsight)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigDestinationArcsightList
//
//
// Format messages to the ArcSight specification..
func (a SysApi) GetLogConfigDestinationArcsightList() (*SysLogConfigDestinationArcsightList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/arcsight"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigDestinationArcsightList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigDestinationIpfix
//
//
// Formats logs into IPFIX messages and transmits them to a pool of IPFIX Collectors.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigDestinationIpfix(id string) (*SysLogConfigDestinationIpfix, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/ipfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationIpfix), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetLogConfigDestinationIpfix")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigDestinationIpfix)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigDestinationIpfixList
//
//
// Formats logs into IPFIX messages and transmits them to a pool of IPFIX Collectors..
func (a SysApi) GetLogConfigDestinationIpfixList() (*SysLogConfigDestinationIpfixList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/ipfix"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigDestinationIpfixList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigDestinationList
//
//
// Log Destination configuration..
func (a SysApi) GetLogConfigDestinationList() (*SysLogConfigDestinationList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigDestinationList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigDestinationLocalDatabase
//
//
// Forwards messages to the local database.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigDestinationLocalDatabase(id string) (*SysLogConfigDestinationLocalDatabase, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/localDatabase/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationLocalDatabase), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetLogConfigDestinationLocalDatabase")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigDestinationLocalDatabase)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigDestinationLocalDatabaseList
//
//
// Forwards messages to the local database..
func (a SysApi) GetLogConfigDestinationLocalDatabaseList() (*SysLogConfigDestinationLocalDatabaseList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/localDatabase"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigDestinationLocalDatabaseList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigDestinationLocalSyslog
//
//
// Forwards messages to the local Syslog-ng process.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigDestinationLocalSyslog(id string) (*SysLogConfigDestinationLocalSyslog, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/localSyslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationLocalSyslog), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetLogConfigDestinationLocalSyslog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigDestinationLocalSyslog)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigDestinationLocalSyslogList
//
//
// Forwards messages to the local Syslog-ng process..
func (a SysApi) GetLogConfigDestinationLocalSyslogList() (*SysLogConfigDestinationLocalSyslogList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/localSyslog"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigDestinationLocalSyslogList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigDestinationManagementPort
//
//
// Forwards messages to a destination through the management port.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigDestinationManagementPort(id string) (*SysLogConfigDestinationManagementPort, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/managementPort/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationManagementPort), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetLogConfigDestinationManagementPort")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigDestinationManagementPort)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigDestinationManagementPortList
//
//
// Forwards messages to a destination through the management port..
func (a SysApi) GetLogConfigDestinationManagementPortList() (*SysLogConfigDestinationManagementPortList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/managementPort"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigDestinationManagementPortList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigDestinationRemoteHighSpeedLog
//
//
// Forwards messages to a pool.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigDestinationRemoteHighSpeedLog(id string) (*SysLogConfigDestinationRemoteHighSpeedLog, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteHighSpeedLog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationRemoteHighSpeedLog), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetLogConfigDestinationRemoteHighSpeedLog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigDestinationRemoteHighSpeedLog)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigDestinationRemoteHighSpeedLogList
//
//
// Forwards messages to a pool..
func (a SysApi) GetLogConfigDestinationRemoteHighSpeedLogList() (*SysLogConfigDestinationRemoteHighSpeedLogList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteHighSpeedLog"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigDestinationRemoteHighSpeedLogList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigDestinationRemoteSyslog
//
//
// Format messages to the Syslog format for remote logging.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigDestinationRemoteSyslog(id string) (*SysLogConfigDestinationRemoteSyslog, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteSyslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationRemoteSyslog), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetLogConfigDestinationRemoteSyslog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigDestinationRemoteSyslog)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigDestinationRemoteSyslogList
//
//
// Format messages to the Syslog format for remote logging..
func (a SysApi) GetLogConfigDestinationRemoteSyslogList() (*SysLogConfigDestinationRemoteSyslogList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteSyslog"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigDestinationRemoteSyslogList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigDestinationSplunk
//
//
// Format messages to the Splunk specification.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigDestinationSplunk(id string) (*SysLogConfigDestinationSplunk, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/splunk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationSplunk), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetLogConfigDestinationSplunk")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigDestinationSplunk)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigDestinationSplunkList
//
//
// Format messages to the Splunk specification..
func (a SysApi) GetLogConfigDestinationSplunkList() (*SysLogConfigDestinationSplunkList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/splunk"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigDestinationSplunkList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigFilter
//
//
// Selectively route logs to log publishers.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigFilter(id string) (*SysLogConfigFilter, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/filter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigFilter), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetLogConfigFilter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigFilter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigFilterList
//
//
// Selectively route logs to log publishers..
func (a SysApi) GetLogConfigFilterList() (*SysLogConfigFilterList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/filter"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigFilterList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigList
//
//
// Manages the common logging interface..
func (a SysApi) GetLogConfigList() (*SysLogConfigList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigPublisher
//
//
// List of log destinations.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigPublisher(id string) (*SysLogConfigPublisher, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/publisher/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigPublisher), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetLogConfigPublisher")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigPublisher)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogConfigPublisherList
//
//
// List of log destinations..
func (a SysApi) GetLogConfigPublisherList() (*SysLogConfigPublisherList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/publisher"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogConfigPublisherList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogList
//
//
// View system log files..
func (a SysApi) GetLogList() (*SysLogList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/log"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogRotate
//
//
// Log rotation configuration.
//
// id is for ID of the resource.
func (a SysApi) GetLogRotate(id string) (*SysLogRotate, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logRotate/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogRotate), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetLogRotate")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogRotate)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLogRotateList
//
//
// Log rotation configuration..
func (a SysApi) GetLogRotateList() (*SysLogRotateList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logRotate"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLogRotateList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLtcfgClassFields
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetLtcfgClassFields(id string) (*SysLtcfgClassFields, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgClass/fields/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLtcfgClassFields), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetLtcfgClassFields")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLtcfgClassFields)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLtcfgClassFieldsList
//
//
// ..
func (a SysApi) GetLtcfgClassFieldsList() (*SysLtcfgClassFieldsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgClass/fields"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLtcfgClassFieldsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLtcfgClassList
//
//
// ..
func (a SysApi) GetLtcfgClassList() (*SysLtcfgClassList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgClass"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLtcfgClassList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLtcfgInstanceFields
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetLtcfgInstanceFields(id string) (*SysLtcfgInstanceFields, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgInstance/fields/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLtcfgInstanceFields), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetLtcfgInstanceFields")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLtcfgInstanceFields)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLtcfgInstanceFieldsList
//
//
// ..
func (a SysApi) GetLtcfgInstanceFieldsList() (*SysLtcfgInstanceFieldsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgInstance/fields"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLtcfgInstanceFieldsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLtcfgInstanceList
//
//
// ..
func (a SysApi) GetLtcfgInstanceList() (*SysLtcfgInstanceList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgInstance"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysLtcfgInstanceList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMacAddress
//
//
// View MAC addresses attached to the system.
//
// id is for ID of the resource.
func (a SysApi) GetMacAddress(id string) (*SysMacAddress, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/macAddress/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysMacAddress), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetMacAddress")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysMacAddress)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMacAddressList
//
//
// View MAC addresses attached to the system..
func (a SysApi) GetMacAddressList() (*SysMacAddressList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/macAddress"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysMacAddressList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetManagementDhcp
//
//
// DHCP configuration for the management interface.
//
// id is for ID of the resource.
func (a SysApi) GetManagementDhcp(id string) (*SysManagementDhcp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementDhcp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysManagementDhcp), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetManagementDhcp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysManagementDhcp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetManagementDhcpList
//
//
// DHCP configuration for the management interface..
func (a SysApi) GetManagementDhcpList() (*SysManagementDhcpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementDhcp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysManagementDhcpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetManagementIp
//
//
// Management port address configuration.
//
// id is for ID of the resource.
func (a SysApi) GetManagementIp(id string) (*SysManagementIp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementIp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysManagementIp), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetManagementIp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysManagementIp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetManagementIpList
//
//
// Management port address configuration..
func (a SysApi) GetManagementIpList() (*SysManagementIpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementIp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysManagementIpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetManagementOvsdb
//
//
// OVSDB configuration.
//
// id is for ID of the resource.
func (a SysApi) GetManagementOvsdb(id string) (*SysManagementOvsdb, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementOvsdb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysManagementOvsdb), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetManagementOvsdb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysManagementOvsdb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetManagementOvsdbList
//
//
// OVSDB configuration..
func (a SysApi) GetManagementOvsdbList() (*SysManagementOvsdbList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementOvsdb"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysManagementOvsdbList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetManagementRoute
//
//
// Route configuration for the management interface.
//
// id is for ID of the resource.
func (a SysApi) GetManagementRoute(id string) (*SysManagementRoute, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementRoute/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysManagementRoute), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetManagementRoute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysManagementRoute)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetManagementRouteList
//
//
// Route configuration for the management interface..
func (a SysApi) GetManagementRouteList() (*SysManagementRouteList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementRoute"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysManagementRouteList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMcpState
//
//
// Displays Master Control Program (mcp) state..
//
// id is for ID of the resource.
func (a SysApi) GetMcpState(id string) (*SysMcpState, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/mcpState/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysMcpState), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetMcpState")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysMcpState)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMcpStateList
//
//
// Displays Master Control Program (mcp) state...
func (a SysApi) GetMcpStateList() (*SysMcpStateList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/mcpState"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysMcpStateList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMemory
//
//
// Memory statistics of system overall performance, on management hosts and traffic management modules, and on individual subsystem.
//
// id is for ID of the resource.
func (a SysApi) GetMemory(id string) (*SysMemory, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/memory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysMemory), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetMemory")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysMemory)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMemoryList
//
//
// Memory statistics of system overall performance, on management hosts and traffic management modules, and on individual subsystem..
func (a SysApi) GetMemoryList() (*SysMemoryList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/memory"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysMemoryList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetNtp
//
//
// NTP configuration.
//
// id is for ID of the resource.
func (a SysApi) GetNtp(id string) (*SysNtp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ntp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysNtp), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetNtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysNtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetNtpList
//
//
// NTP configuration..
func (a SysApi) GetNtpList() (*SysNtpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ntp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysNtpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetNtpRestrict
//
//
// A restrict line in the NTP configuration.
//
// id is for ID of the resource.
func (a SysApi) GetNtpRestrict(id string) (*SysNtpRestrict, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ntp/restrict/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysNtpRestrict), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetNtpRestrict")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysNtpRestrict)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetNtpRestrictList
//
//
// A restrict line in the NTP configuration..
func (a SysApi) GetNtpRestrictList() (*SysNtpRestrictList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ntp/restrict"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysNtpRestrictList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetOutboundSmtp
//
//
// Configuration for outbound email sent by the TMOS system.
//
// id is for ID of the resource.
func (a SysApi) GetOutboundSmtp(id string) (*SysOutboundSmtp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/outboundSmtp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysOutboundSmtp), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetOutboundSmtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysOutboundSmtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetOutboundSmtpList
//
//
// Configuration for outbound email sent by the TMOS system..
func (a SysApi) GetOutboundSmtpList() (*SysOutboundSmtpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/outboundSmtp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysOutboundSmtpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPerformance
//
//
// System performance statistics.
//
// id is for ID of the resource.
func (a SysApi) GetPerformance(id string) (*SysPerformance, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysPerformance), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetPerformance")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPerformance)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPerformanceAllStats
//
//
// View or reset all available performance statistics.
//
// id is for ID of the resource.
func (a SysApi) GetPerformanceAllStats(id string) (*SysPerformanceAllStats, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/allStats/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysPerformanceAllStats), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetPerformanceAllStats")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPerformanceAllStats)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPerformanceAllStatsList
//
//
// View or reset all available performance statistics..
func (a SysApi) GetPerformanceAllStatsList() (*SysPerformanceAllStatsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/allStats"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPerformanceAllStatsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPerformanceConnections
//
//
// View active connection statistics.
//
// id is for ID of the resource.
func (a SysApi) GetPerformanceConnections(id string) (*SysPerformanceConnections, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/connections/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysPerformanceConnections), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetPerformanceConnections")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPerformanceConnections)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPerformanceConnectionsList
//
//
// View active connection statistics..
func (a SysApi) GetPerformanceConnectionsList() (*SysPerformanceConnectionsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/connections"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPerformanceConnectionsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPerformanceDnsexpress
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetPerformanceDnsexpress(id string) (*SysPerformanceDnsexpress, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/dnsexpress/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysPerformanceDnsexpress), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetPerformanceDnsexpress")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPerformanceDnsexpress)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPerformanceDnsexpressList
//
//
// ..
func (a SysApi) GetPerformanceDnsexpressList() (*SysPerformanceDnsexpressList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/dnsexpress"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPerformanceDnsexpressList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPerformanceDnssec
//
//
// View DNSSEC signing request/response rate statistics.
//
// id is for ID of the resource.
func (a SysApi) GetPerformanceDnssec(id string) (*SysPerformanceDnssec, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/dnssec/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysPerformanceDnssec), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetPerformanceDnssec")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPerformanceDnssec)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPerformanceDnssecList
//
//
// View DNSSEC signing request/response rate statistics..
func (a SysApi) GetPerformanceDnssecList() (*SysPerformanceDnssecList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/dnssec"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPerformanceDnssecList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPerformanceGtm
//
//
// View GTM request/response rate statistics.
//
// id is for ID of the resource.
func (a SysApi) GetPerformanceGtm(id string) (*SysPerformanceGtm, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/gtm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysPerformanceGtm), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetPerformanceGtm")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPerformanceGtm)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPerformanceGtmList
//
//
// View GTM request/response rate statistics..
func (a SysApi) GetPerformanceGtmList() (*SysPerformanceGtmList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/gtm"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPerformanceGtmList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPerformanceList
//
//
// System performance statistics..
func (a SysApi) GetPerformanceList() (*SysPerformanceList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPerformanceList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPerformanceRamcache
//
//
// View RAM Cache utilization.
//
// id is for ID of the resource.
func (a SysApi) GetPerformanceRamcache(id string) (*SysPerformanceRamcache, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/ramcache/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysPerformanceRamcache), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetPerformanceRamcache")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPerformanceRamcache)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPerformanceRamcacheList
//
//
// View RAM Cache utilization..
func (a SysApi) GetPerformanceRamcacheList() (*SysPerformanceRamcacheList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/ramcache"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPerformanceRamcacheList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPerformanceSystem
//
//
// View system CPU and memory usage.
//
// id is for ID of the resource.
func (a SysApi) GetPerformanceSystem(id string) (*SysPerformanceSystem, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/system/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysPerformanceSystem), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetPerformanceSystem")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPerformanceSystem)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPerformanceSystemList
//
//
// View system CPU and memory usage..
func (a SysApi) GetPerformanceSystemList() (*SysPerformanceSystemList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/system"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPerformanceSystemList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPerformanceThroughput
//
//
// View throughput statistics and SSL transactions/sec.
//
// id is for ID of the resource.
func (a SysApi) GetPerformanceThroughput(id string) (*SysPerformanceThroughput, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/throughput/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysPerformanceThroughput), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetPerformanceThroughput")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPerformanceThroughput)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPerformanceThroughputList
//
//
// View throughput statistics and SSL transactions/sec..
func (a SysApi) GetPerformanceThroughputList() (*SysPerformanceThroughputList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/throughput"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPerformanceThroughputList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPptpCallInfo
//
//
// Displays or deletes active pptp-calls on the BIG-IP system.
//
// id is for ID of the resource.
func (a SysApi) GetPptpCallInfo(id string) (*SysPptpCallInfo, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/pptpCallInfo/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysPptpCallInfo), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetPptpCallInfo")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPptpCallInfo)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPptpCallInfoList
//
//
// Displays or deletes active pptp-calls on the BIG-IP system..
func (a SysApi) GetPptpCallInfoList() (*SysPptpCallInfoList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/pptpCallInfo"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPptpCallInfoList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProcInfo
//
//
// Display process status.
//
// id is for ID of the resource.
func (a SysApi) GetProcInfo(id string) (*SysProcInfo, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/procInfo/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysProcInfo), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetProcInfo")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysProcInfo)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProcInfoList
//
//
// Display process status..
func (a SysApi) GetProcInfoList() (*SysProcInfoList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/procInfo"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysProcInfoList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProvision
//
//
// Module resource configuration.
//
// id is for ID of the resource.
func (a SysApi) GetProvision(id string) (*SysProvision, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/provision/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysProvision), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetProvision")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysProvision)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProvisionList
//
//
// Module resource configuration..
func (a SysApi) GetProvisionList() (*SysProvisionList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/provision"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysProvisionList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPvaTraffic
//
//
// Packet Velocity Acceleration Engine&#39;s (PVA) traffic statistics..
//
// id is for ID of the resource.
func (a SysApi) GetPvaTraffic(id string) (*SysPvaTraffic, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/pvaTraffic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysPvaTraffic), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetPvaTraffic")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPvaTraffic)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPvaTrafficList
//
//
// Packet Velocity Acceleration Engine&#39;s (PVA) traffic statistics...
func (a SysApi) GetPvaTrafficList() (*SysPvaTrafficList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/pvaTraffic"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysPvaTrafficList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetRaid
//
//
// Manage disk arrays.
//
// id is for ID of the resource.
func (a SysApi) GetRaid(id string) (*SysRaid, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysRaid), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetRaid")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysRaid)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetRaidArray
//
//
// Manage the disk array.
//
// id is for ID of the resource.
func (a SysApi) GetRaidArray(id string) (*SysRaidArray, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/array/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysRaidArray), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetRaidArray")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysRaidArray)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetRaidArrayList
//
//
// Manage the disk array..
func (a SysApi) GetRaidArrayList() (*SysRaidArrayList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/array"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysRaidArrayList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetRaidBay
//
//
// Manage drive bays.
//
// id is for ID of the resource.
func (a SysApi) GetRaidBay(id string) (*SysRaidBay, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/bay/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysRaidBay), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetRaidBay")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysRaidBay)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetRaidBayList
//
//
// Manage drive bays..
func (a SysApi) GetRaidBayList() (*SysRaidBayList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/bay"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysRaidBayList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetRaidDisk
//
//
// View disk drive status.
//
// id is for ID of the resource.
func (a SysApi) GetRaidDisk(id string) (*SysRaidDisk, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/disk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysRaidDisk), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetRaidDisk")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysRaidDisk)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetRaidDiskList
//
//
// View disk drive status..
func (a SysApi) GetRaidDiskList() (*SysRaidDiskList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/disk"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysRaidDiskList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetRaidList
//
//
// Manage disk arrays..
func (a SysApi) GetRaidList() (*SysRaidList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysRaidList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetRestrictedModuleList
//
//
// ..
func (a SysApi) GetRestrictedModuleList() (*SysRestrictedModuleList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/restrictedModule"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysRestrictedModuleList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetScriptd
//
//
// scriptd daemon configuration.
//
// id is for ID of the resource.
func (a SysApi) GetScriptd(id string) (*SysScriptd, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/scriptd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysScriptd), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetScriptd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysScriptd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetScriptdList
//
//
// scriptd daemon configuration..
func (a SysApi) GetScriptdList() (*SysScriptdList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/scriptd"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysScriptdList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetService
//
//
// Controls the BIG-IP system services..
//
// id is for ID of the resource.
func (a SysApi) GetService(id string) (*SysService, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/service/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysService), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetService")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysService)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetServiceList
//
//
// Controls the BIG-IP system services...
func (a SysApi) GetServiceList() (*SysServiceList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/service"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysServiceList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflow
//
//
// sFlow configuration.
//
// id is for ID of the resource.
func (a SysApi) GetSflow(id string) (*SysSflow, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflow), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSflow")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflow)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowDataSource
//
//
// The status of sFlow data sources.
//
// id is for ID of the resource.
func (a SysApi) GetSflowDataSource(id string) (*SysSflowDataSource, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/dataSource/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowDataSource), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSflowDataSource")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowDataSource)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowDataSourceHttp
//
//
// The status of HTTP sFlow data sources.
//
// id is for ID of the resource.
func (a SysApi) GetSflowDataSourceHttp(id string) (*SysSflowDataSourceHttp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/dataSource/http/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowDataSourceHttp), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSflowDataSourceHttp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowDataSourceHttp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowDataSourceHttpList
//
//
// The status of HTTP sFlow data sources..
func (a SysApi) GetSflowDataSourceHttpList() (*SysSflowDataSourceHttpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/dataSource/http"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowDataSourceHttpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowDataSourceList
//
//
// The status of sFlow data sources..
func (a SysApi) GetSflowDataSourceList() (*SysSflowDataSourceList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/dataSource"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowDataSourceList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowDataSourceSystem
//
//
// The status of system sFlow data sources.
//
// id is for ID of the resource.
func (a SysApi) GetSflowDataSourceSystem(id string) (*SysSflowDataSourceSystem, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/dataSource/system/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowDataSourceSystem), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSflowDataSourceSystem")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowDataSourceSystem)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowDataSourceSystemList
//
//
// The status of system sFlow data sources..
func (a SysApi) GetSflowDataSourceSystemList() (*SysSflowDataSourceSystemList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/dataSource/system"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowDataSourceSystemList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowDataSourceTmInterface
//
//
// The status of sFlow data sources (interfaces).
//
// id is for ID of the resource.
func (a SysApi) GetSflowDataSourceTmInterface(id string) (*SysSflowDataSourceTmInterface, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/dataSource/tmInterface/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowDataSourceTmInterface), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSflowDataSourceTmInterface")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowDataSourceTmInterface)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowDataSourceTmInterfaceList
//
//
// The status of sFlow data sources (interfaces)..
func (a SysApi) GetSflowDataSourceTmInterfaceList() (*SysSflowDataSourceTmInterfaceList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/dataSource/tmInterface"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowDataSourceTmInterfaceList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowDataSourceVlan
//
//
// The status of sFlow data sources (VLANs).
//
// id is for ID of the resource.
func (a SysApi) GetSflowDataSourceVlan(id string) (*SysSflowDataSourceVlan, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/dataSource/vlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowDataSourceVlan), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSflowDataSourceVlan")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowDataSourceVlan)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowDataSourceVlanList
//
//
// The status of sFlow data sources (VLANs)..
func (a SysApi) GetSflowDataSourceVlanList() (*SysSflowDataSourceVlanList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/dataSource/vlan"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowDataSourceVlanList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowGlobalSettings
//
//
// Global sFlow configuration.
//
// id is for ID of the resource.
func (a SysApi) GetSflowGlobalSettings(id string) (*SysSflowGlobalSettings, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowGlobalSettings), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSflowGlobalSettings")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowGlobalSettings)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowGlobalSettingsHttp
//
//
// Global HTTP sFlow configuration.
//
// id is for ID of the resource.
func (a SysApi) GetSflowGlobalSettingsHttp(id string) (*SysSflowGlobalSettingsHttp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/http/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowGlobalSettingsHttp), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSflowGlobalSettingsHttp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowGlobalSettingsHttp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowGlobalSettingsHttpList
//
//
// Global HTTP sFlow configuration..
func (a SysApi) GetSflowGlobalSettingsHttpList() (*SysSflowGlobalSettingsHttpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/http"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowGlobalSettingsHttpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowGlobalSettingsList
//
//
// Global sFlow configuration..
func (a SysApi) GetSflowGlobalSettingsList() (*SysSflowGlobalSettingsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowGlobalSettingsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowGlobalSettingsSystem
//
//
// Global system sFlow configuration.
//
// id is for ID of the resource.
func (a SysApi) GetSflowGlobalSettingsSystem(id string) (*SysSflowGlobalSettingsSystem, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/system/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowGlobalSettingsSystem), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSflowGlobalSettingsSystem")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowGlobalSettingsSystem)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowGlobalSettingsSystemList
//
//
// Global system sFlow configuration..
func (a SysApi) GetSflowGlobalSettingsSystemList() (*SysSflowGlobalSettingsSystemList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/system"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowGlobalSettingsSystemList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowGlobalSettingsTmInterface
//
//
// Global sFlow configuration for interfaces.
//
// id is for ID of the resource.
func (a SysApi) GetSflowGlobalSettingsTmInterface(id string) (*SysSflowGlobalSettingsTmInterface, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/tmInterface/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowGlobalSettingsTmInterface), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSflowGlobalSettingsTmInterface")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowGlobalSettingsTmInterface)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowGlobalSettingsTmInterfaceList
//
//
// Global sFlow configuration for interfaces..
func (a SysApi) GetSflowGlobalSettingsTmInterfaceList() (*SysSflowGlobalSettingsTmInterfaceList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/tmInterface"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowGlobalSettingsTmInterfaceList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowGlobalSettingsVlan
//
//
// Global sFlow configuration for VLANs.
//
// id is for ID of the resource.
func (a SysApi) GetSflowGlobalSettingsVlan(id string) (*SysSflowGlobalSettingsVlan, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/vlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowGlobalSettingsVlan), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSflowGlobalSettingsVlan")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowGlobalSettingsVlan)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowGlobalSettingsVlanList
//
//
// Global sFlow configuration for VLANs..
func (a SysApi) GetSflowGlobalSettingsVlanList() (*SysSflowGlobalSettingsVlanList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/vlan"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowGlobalSettingsVlanList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowList
//
//
// sFlow configuration..
func (a SysApi) GetSflowList() (*SysSflowList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowReceiver
//
//
// sFlow receiver configuration.
//
// id is for ID of the resource.
func (a SysApi) GetSflowReceiver(id string) (*SysSflowReceiver, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/receiver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowReceiver), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSflowReceiver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowReceiver)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSflowReceiverList
//
//
// sFlow receiver configuration..
func (a SysApi) GetSflowReceiverList() (*SysSflowReceiverList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/receiver"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSflowReceiverList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSmtpServer
//
//
// SMTP configuration.
//
// id is for ID of the resource.
func (a SysApi) GetSmtpServer(id string) (*SysSmtpServer, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/smtpServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSmtpServer), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSmtpServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSmtpServer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSmtpServerList
//
//
// SMTP configuration..
func (a SysApi) GetSmtpServerList() (*SysSmtpServerList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/smtpServer"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSmtpServerList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSnmp
//
//
// SNMP agent config.
//
// id is for ID of the resource.
func (a SysApi) GetSnmp(id string) (*SysSnmp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSnmp), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSnmp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSnmp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSnmpCommunities
//
//
// Specifies SNMP community strings and limits them to specific oid subsets..
//
// id is for ID of the resource.
func (a SysApi) GetSnmpCommunities(id string) (*SysSnmpCommunities, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/communities/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSnmpCommunities), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSnmpCommunities")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSnmpCommunities)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSnmpCommunitiesList
//
//
// Specifies SNMP community strings and limits them to specific oid subsets...
func (a SysApi) GetSnmpCommunitiesList() (*SysSnmpCommunitiesList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/communities"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSnmpCommunitiesList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSnmpList
//
//
// SNMP agent config..
func (a SysApi) GetSnmpList() (*SysSnmpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSnmpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSnmpTraps
//
//
// Generic interface for configuring SNMP traps..
//
// id is for ID of the resource.
func (a SysApi) GetSnmpTraps(id string) (*SysSnmpTraps, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/traps/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSnmpTraps), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSnmpTraps")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSnmpTraps)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSnmpTrapsList
//
//
// Generic interface for configuring SNMP traps...
func (a SysApi) GetSnmpTrapsList() (*SysSnmpTrapsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/traps"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSnmpTrapsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSnmpUsers
//
//
// Specifies user account information for use with SNMPv3..
//
// id is for ID of the resource.
func (a SysApi) GetSnmpUsers(id string) (*SysSnmpUsers, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/users/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSnmpUsers), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSnmpUsers")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSnmpUsers)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSnmpUsersList
//
//
// Specifies user account information for use with SNMPv3...
func (a SysApi) GetSnmpUsersList() (*SysSnmpUsersList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/users"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSnmpUsersList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSoftware
//
//
// Software Installation and Volume Management.
//
// id is for ID of the resource.
func (a SysApi) GetSoftware(id string) (*SysSoftware, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSoftware), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSoftware")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSoftware)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSoftwareBlockDeviceHotfix
//
//
// Manage block device hotfix images.
//
// id is for ID of the resource.
func (a SysApi) GetSoftwareBlockDeviceHotfix(id string) (*SysSoftwareBlockDeviceHotfix, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/blockDeviceHotfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSoftwareBlockDeviceHotfix), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSoftwareBlockDeviceHotfix")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSoftwareBlockDeviceHotfix)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSoftwareBlockDeviceHotfixList
//
//
// Manage block device hotfix images..
func (a SysApi) GetSoftwareBlockDeviceHotfixList() (*SysSoftwareBlockDeviceHotfixList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/blockDeviceHotfix"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSoftwareBlockDeviceHotfixList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSoftwareBlockDeviceImage
//
//
// Manage block device software images.
//
// id is for ID of the resource.
func (a SysApi) GetSoftwareBlockDeviceImage(id string) (*SysSoftwareBlockDeviceImage, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/blockDeviceImage/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSoftwareBlockDeviceImage), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSoftwareBlockDeviceImage")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSoftwareBlockDeviceImage)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSoftwareBlockDeviceImageList
//
//
// Manage block device software images..
func (a SysApi) GetSoftwareBlockDeviceImageList() (*SysSoftwareBlockDeviceImageList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/blockDeviceImage"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSoftwareBlockDeviceImageList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSoftwareHotfix
//
//
// Manage hotfix images.
//
// id is for ID of the resource.
func (a SysApi) GetSoftwareHotfix(id string) (*SysSoftwareHotfix, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/hotfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSoftwareHotfix), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSoftwareHotfix")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSoftwareHotfix)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSoftwareHotfixList
//
//
// Manage hotfix images..
func (a SysApi) GetSoftwareHotfixList() (*SysSoftwareHotfixList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/hotfix"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSoftwareHotfixList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSoftwareImage
//
//
// Manage software images.
//
// id is for ID of the resource.
func (a SysApi) GetSoftwareImage(id string) (*SysSoftwareImage, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/image/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSoftwareImage), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSoftwareImage")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSoftwareImage)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSoftwareImageList
//
//
// Manage software images..
func (a SysApi) GetSoftwareImageList() (*SysSoftwareImageList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/image"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSoftwareImageList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSoftwareList
//
//
// Software Installation and Volume Management..
func (a SysApi) GetSoftwareList() (*SysSoftwareList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSoftwareList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSoftwareSignature
//
//
// Manage software signatures.
//
// id is for ID of the resource.
func (a SysApi) GetSoftwareSignature(id string) (*SysSoftwareSignature, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/signature/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSoftwareSignature), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSoftwareSignature")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSoftwareSignature)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSoftwareSignatureList
//
//
// Manage software signatures..
func (a SysApi) GetSoftwareSignatureList() (*SysSoftwareSignatureList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/signature"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSoftwareSignatureList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSoftwareStatus
//
//
// Status for software volumes.
//
// id is for ID of the resource.
func (a SysApi) GetSoftwareStatus(id string) (*SysSoftwareStatus, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/status/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSoftwareStatus), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSoftwareStatus")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSoftwareStatus)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSoftwareStatusList
//
//
// Status for software volumes..
func (a SysApi) GetSoftwareStatusList() (*SysSoftwareStatusList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/status"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSoftwareStatusList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSoftwareUpdate
//
//
// Manage software update checking.
//
// id is for ID of the resource.
func (a SysApi) GetSoftwareUpdate(id string) (*SysSoftwareUpdate, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/update/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSoftwareUpdate), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSoftwareUpdate")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSoftwareUpdate)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSoftwareUpdateList
//
//
// Manage software update checking..
func (a SysApi) GetSoftwareUpdateList() (*SysSoftwareUpdateList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/update"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSoftwareUpdateList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSoftwareUpdateStatus
//
//
// Display update check results.
//
// id is for ID of the resource.
func (a SysApi) GetSoftwareUpdateStatus(id string) (*SysSoftwareUpdateStatus, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/updateStatus/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSoftwareUpdateStatus), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSoftwareUpdateStatus")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSoftwareUpdateStatus)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSoftwareUpdateStatusList
//
//
// Display update check results..
func (a SysApi) GetSoftwareUpdateStatusList() (*SysSoftwareUpdateStatusList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/updateStatus"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSoftwareUpdateStatusList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSoftwareVolume
//
//
// Manage software volumes, or reboot to a specific volume.
//
// id is for ID of the resource.
func (a SysApi) GetSoftwareVolume(id string) (*SysSoftwareVolume, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/volume/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSoftwareVolume), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSoftwareVolume")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSoftwareVolume)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSoftwareVolumeList
//
//
// Manage software volumes, or reboot to a specific volume..
func (a SysApi) GetSoftwareVolumeList() (*SysSoftwareVolumeList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/volume"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSoftwareVolumeList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSshd
//
//
// SSHD configuration.
//
// id is for ID of the resource.
func (a SysApi) GetSshd(id string) (*SysSshd, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sshd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSshd), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSshd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSshd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSshdList
//
//
// SSHD configuration..
func (a SysApi) GetSshdList() (*SysSshdList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sshd"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSshdList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetStateMirroring
//
//
// Redundant system connection mirroring configuration.
//
// id is for ID of the resource.
func (a SysApi) GetStateMirroring(id string) (*SysStateMirroring, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/stateMirroring/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysStateMirroring), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetStateMirroring")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysStateMirroring)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetStateMirroringList
//
//
// Redundant system connection mirroring configuration..
func (a SysApi) GetStateMirroringList() (*SysStateMirroringList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/stateMirroring"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysStateMirroringList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSyncSysFiles
//
//
// Sync System Files.
//
// id is for ID of the resource.
func (a SysApi) GetSyncSysFiles(id string) (*SysSyncSysFiles, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/syncSysFiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSyncSysFiles), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSyncSysFiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSyncSysFiles)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSyncSysFilesList
//
//
// Sync System Files..
func (a SysApi) GetSyncSysFilesList() (*SysSyncSysFilesList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/syncSysFiles"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSyncSysFilesList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSyslog
//
//
// System logging configuration.
//
// id is for ID of the resource.
func (a SysApi) GetSyslog(id string) (*SysSyslog, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/syslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSyslog), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetSyslog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSyslog)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSyslogList
//
//
// System logging configuration..
func (a SysApi) GetSyslogList() (*SysSyslogList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/syslog"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysSyslogList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetTmmInfo
//
//
// Traffic management statistics, including process, memory, and CPU usage..
//
// id is for ID of the resource.
func (a SysApi) GetTmmInfo(id string) (*SysTmmInfo, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/tmmInfo/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysTmmInfo), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetTmmInfo")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysTmmInfo)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetTmmInfoList
//
//
// Traffic management statistics, including process, memory, and CPU usage...
func (a SysApi) GetTmmInfoList() (*SysTmmInfoList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/tmmInfo"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysTmmInfoList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetTmmTraffic
//
//
// Traffic management statistics, including traffic information, error, and connections redirected..
//
// id is for ID of the resource.
func (a SysApi) GetTmmTraffic(id string) (*SysTmmTraffic, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/tmmTraffic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysTmmTraffic), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetTmmTraffic")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysTmmTraffic)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetTmmTrafficList
//
//
// Traffic management statistics, including traffic information, error, and connections redirected...
func (a SysApi) GetTmmTrafficList() (*SysTmmTrafficList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/tmmTraffic"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysTmmTrafficList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetTraffic
//
//
// Global traffic statistics.
//
// id is for ID of the resource.
func (a SysApi) GetTraffic(id string) (*SysTraffic, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/traffic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysTraffic), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetTraffic")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysTraffic)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetTrafficList
//
//
// Global traffic statistics..
func (a SysApi) GetTrafficList() (*SysTrafficList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/traffic"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysTrafficList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetUcs
//
//
// Save and restore configuration from UCS files.
//
// id is for ID of the resource.
func (a SysApi) GetUcs(id string) (*SysUcs, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ucs/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysUcs), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetUcs")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysUcs)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetUcsList
//
//
// Save and restore configuration from UCS files..
func (a SysApi) GetUcsList() (*SysUcsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ucs"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysUcsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetUrlDb
//
//
// URL Database Configuration and Category Management.
//
// id is for ID of the resource.
func (a SysApi) GetUrlDb(id string) (*SysUrlDb, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysUrlDb), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetUrlDb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysUrlDb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetUrlDbDownloadResult
//
//
// URL Database Download Result.
//
// id is for ID of the resource.
func (a SysApi) GetUrlDbDownloadResult(id string) (*SysUrlDbDownloadResult, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/downloadResult/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysUrlDbDownloadResult), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetUrlDbDownloadResult")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysUrlDbDownloadResult)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetUrlDbDownloadResultList
//
//
// URL Database Download Result..
func (a SysApi) GetUrlDbDownloadResultList() (*SysUrlDbDownloadResultList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/downloadResult"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysUrlDbDownloadResultList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetUrlDbDownloadSchedule
//
//
// URL Database Download Schedule.
//
// id is for ID of the resource.
func (a SysApi) GetUrlDbDownloadSchedule(id string) (*SysUrlDbDownloadSchedule, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/downloadSchedule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysUrlDbDownloadSchedule), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetUrlDbDownloadSchedule")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysUrlDbDownloadSchedule)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetUrlDbDownloadScheduleList
//
//
// URL Database Download Schedule..
func (a SysApi) GetUrlDbDownloadScheduleList() (*SysUrlDbDownloadScheduleList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/downloadSchedule"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysUrlDbDownloadScheduleList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetUrlDbList
//
//
// URL Database Configuration and Category Management..
func (a SysApi) GetUrlDbList() (*SysUrlDbList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysUrlDbList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetUrlDbUrlCategory
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetUrlDbUrlCategory(id string) (*SysUrlDbUrlCategory, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/urlCategory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysUrlDbUrlCategory), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetUrlDbUrlCategory")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysUrlDbUrlCategory)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetUrlDbUrlCategoryList
//
//
// ..
func (a SysApi) GetUrlDbUrlCategoryList() (*SysUrlDbUrlCategoryList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/urlCategory"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysUrlDbUrlCategoryList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetVersion
//
//
// View system version and hotfix information.
//
// id is for ID of the resource.
func (a SysApi) GetVersion(id string) (*SysVersion, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/version/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysVersion), nil, errors.New("Missing required parameter 'id' when calling SysApi->GetVersion")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysVersion)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetVersionList
//
//
// View system version and hotfix information..
func (a SysApi) GetVersionList() (*SysVersionList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/version"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(SysVersionList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchApplicationAplScript
//
//
// Scripts included by an application template.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchApplicationAplScript(id string, object SysApplicationAplScript) (*SysApplicationAplScript, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/aplScript/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysApplicationAplScript), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchApplicationAplScript")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysApplicationAplScript), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchApplicationAplScript")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysApplicationAplScript)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchApplicationCustomStat
//
//
// Derived iStats.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchApplicationCustomStat(id string, object SysApplicationCustomStat) (*SysApplicationCustomStat, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/customStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysApplicationCustomStat), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchApplicationCustomStat")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysApplicationCustomStat), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchApplicationCustomStat")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysApplicationCustomStat)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchApplicationService
//
//
// Application configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchApplicationService(id string, object SysApplicationService) (*SysApplicationService, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/service/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysApplicationService), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchApplicationService")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysApplicationService), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchApplicationService")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysApplicationService)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchApplicationTemplate
//
//
// Application templates.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchApplicationTemplate(id string, object SysApplicationTemplate) (*SysApplicationTemplate, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/template/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysApplicationTemplate), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchApplicationTemplate")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysApplicationTemplate), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchApplicationTemplate")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysApplicationTemplate)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchApplicationTemplateActions
//
//
// Manage the set of actions associated with an application template..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchApplicationTemplateActions(id string, object SysApplicationTemplateActions) (*SysApplicationTemplateActions, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/template/actions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysApplicationTemplateActions), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchApplicationTemplateActions")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysApplicationTemplateActions), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchApplicationTemplateActions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysApplicationTemplateActions)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchAutoscaleGroup
//
//
// Autoscale group information for Amazon Web Services(AWS)..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchAutoscaleGroup(id string, object SysAutoscaleGroup) (*SysAutoscaleGroup, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/autoscaleGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysAutoscaleGroup), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchAutoscaleGroup")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysAutoscaleGroup), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchAutoscaleGroup")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysAutoscaleGroup)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchClock
//
//
// Display the current date and time.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchClock(id string, object SysClock) (*SysClock, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/clock/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysClock), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchClock")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysClock), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchClock")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysClock)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchCluster
//
//
// Cluster configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchCluster(id string, object SysCluster) (*SysCluster, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/cluster/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCluster), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchCluster")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysCluster), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchCluster")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysCluster)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchConnection
//
//
// Displays or deletes active connections on the BIG-IP system.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchConnection(id string, object SysConnection) (*SysConnection, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/connection/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysConnection), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchConnection")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysConnection), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchConnection")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysConnection)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchConsole
//
//
// Configure the serial console.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchConsole(id string, object SysConsole) (*SysConsole, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/console/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysConsole), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchConsole")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysConsole), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchConsole")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysConsole)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchCryptoClient
//
//
// Crypto client configuration..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchCryptoClient(id string, object SysCryptoClient) (*SysCryptoClient, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/client/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoClient), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchCryptoClient")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysCryptoClient), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchCryptoClient")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysCryptoClient)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchCryptoFipsExternalHsm
//
//
// FIPS external hsm specific configuration..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchCryptoFipsExternalHsm(id string, object SysCryptoFipsExternalHsm) (*SysCryptoFipsExternalHsm, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/externalHsm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoFipsExternalHsm), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchCryptoFipsExternalHsm")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysCryptoFipsExternalHsm), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchCryptoFipsExternalHsm")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysCryptoFipsExternalHsm)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchCryptoMasterKey
//
//
// Displays internal encryption key information on a system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchCryptoMasterKey(id string, object SysCryptoMasterKey) (*SysCryptoMasterKey, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/masterKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoMasterKey), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchCryptoMasterKey")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysCryptoMasterKey), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchCryptoMasterKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysCryptoMasterKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchCryptoServer
//
//
// Crypto server configuration..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchCryptoServer(id string, object SysCryptoServer) (*SysCryptoServer, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/server/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoServer), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchCryptoServer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysCryptoServer), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchCryptoServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysCryptoServer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDaemonHa
//
//
// System daemon HA configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDaemonHa(id string, object SysDaemonHa) (*SysDaemonHa, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonHa/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonHa), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchDaemonHa")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDaemonHa), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchDaemonHa")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDaemonHa)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDaemonLogSettingsClusterd
//
//
// The clusterd daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDaemonLogSettingsClusterd(id string, object SysDaemonLogSettingsClusterd) (*SysDaemonLogSettingsClusterd, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/clusterd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonLogSettingsClusterd), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchDaemonLogSettingsClusterd")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDaemonLogSettingsClusterd), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchDaemonLogSettingsClusterd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDaemonLogSettingsClusterd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDaemonLogSettingsCsyncd
//
//
// The csyncd daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDaemonLogSettingsCsyncd(id string, object SysDaemonLogSettingsCsyncd) (*SysDaemonLogSettingsCsyncd, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/csyncd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonLogSettingsCsyncd), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchDaemonLogSettingsCsyncd")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDaemonLogSettingsCsyncd), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchDaemonLogSettingsCsyncd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDaemonLogSettingsCsyncd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDaemonLogSettingsIcrd
//
//
// The icrd daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDaemonLogSettingsIcrd(id string, object SysDaemonLogSettingsIcrd) (*SysDaemonLogSettingsIcrd, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/icrd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonLogSettingsIcrd), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchDaemonLogSettingsIcrd")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDaemonLogSettingsIcrd), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchDaemonLogSettingsIcrd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDaemonLogSettingsIcrd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDaemonLogSettingsLind
//
//
// The lind daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDaemonLogSettingsLind(id string, object SysDaemonLogSettingsLind) (*SysDaemonLogSettingsLind, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/lind/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonLogSettingsLind), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchDaemonLogSettingsLind")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDaemonLogSettingsLind), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchDaemonLogSettingsLind")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDaemonLogSettingsLind)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDaemonLogSettingsMcpd
//
//
// The mcpd daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDaemonLogSettingsMcpd(id string, object SysDaemonLogSettingsMcpd) (*SysDaemonLogSettingsMcpd, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/mcpd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonLogSettingsMcpd), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchDaemonLogSettingsMcpd")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDaemonLogSettingsMcpd), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchDaemonLogSettingsMcpd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDaemonLogSettingsMcpd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDaemonLogSettingsTmm
//
//
// The tmm daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDaemonLogSettingsTmm(id string, object SysDaemonLogSettingsTmm) (*SysDaemonLogSettingsTmm, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/tmm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonLogSettingsTmm), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchDaemonLogSettingsTmm")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDaemonLogSettingsTmm), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchDaemonLogSettingsTmm")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDaemonLogSettingsTmm)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDatastor
//
//
// Optimization data storage configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDatastor(id string, object SysDatastor) (*SysDatastor, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/datastor/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDatastor), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchDatastor")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDatastor), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchDatastor")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDatastor)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDb
//
//
// General system properties.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDb(id string, object SysDb) (*SysDb, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/db/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDb), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchDb")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDb), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchDb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDiskDirectory
//
//
// System directory resize operations..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDiskDirectory(id string, object SysDiskDirectory) (*SysDiskDirectory, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/directory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDiskDirectory), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchDiskDirectory")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDiskDirectory), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchDiskDirectory")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDiskDirectory)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDiskLogicalDisk
//
//
// Logical Disk Configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDiskLogicalDisk(id string, object SysDiskLogicalDisk) (*SysDiskLogicalDisk, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/logicalDisk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDiskLogicalDisk), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchDiskLogicalDisk")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDiskLogicalDisk), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchDiskLogicalDisk")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDiskLogicalDisk)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDns
//
//
// DNS configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDns(id string, object SysDns) (*SysDns, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/dns/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDns), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchDns")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDns), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchDns")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDns)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchEcmCloudProvider
//
//
// Describes the properties of all the cloud-providers.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchEcmCloudProvider(id string, object SysEcmCloudProvider) (*SysEcmCloudProvider, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/cloudProvider/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysEcmCloudProvider), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchEcmCloudProvider")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysEcmCloudProvider), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchEcmCloudProvider")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysEcmCloudProvider)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchEcmConfig
//
//
// Specifies the ecm configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchEcmConfig(id string, object SysEcmConfig) (*SysEcmConfig, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/config/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysEcmConfig), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchEcmConfig")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysEcmConfig), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchEcmConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysEcmConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchFeatureModule
//
//
// Feature module configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFeatureModule(id string, object SysFeatureModule) (*SysFeatureModule, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/featureModule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFeatureModule), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchFeatureModule")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFeatureModule), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchFeatureModule")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFeatureModule)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchFileApacheSslCert
//
//
// SSL certificates management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFileApacheSslCert(id string, object SysFileApacheSslCert) (*SysFileApacheSslCert, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/apacheSslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileApacheSslCert), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchFileApacheSslCert")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileApacheSslCert), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchFileApacheSslCert")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileApacheSslCert)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchFileDashboardViewset
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFileDashboardViewset(id string, object SysFileDashboardViewset) (*SysFileDashboardViewset, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dashboardViewset/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileDashboardViewset), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchFileDashboardViewset")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileDashboardViewset), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchFileDashboardViewset")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileDashboardViewset)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchFileDataGroup
//
//
// External Data Group files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFileDataGroup(id string, object SysFileDataGroup) (*SysFileDataGroup, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dataGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileDataGroup), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchFileDataGroup")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileDataGroup), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchFileDataGroup")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileDataGroup)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchFileDeviceCapabilitiesDb
//
//
// Device capabilities DB file management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFileDeviceCapabilitiesDb(id string, object SysFileDeviceCapabilitiesDb) (*SysFileDeviceCapabilitiesDb, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/deviceCapabilitiesDb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileDeviceCapabilitiesDb), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchFileDeviceCapabilitiesDb")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileDeviceCapabilitiesDb), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchFileDeviceCapabilitiesDb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileDeviceCapabilitiesDb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchFileExternalMonitor
//
//
// External Monitor files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFileExternalMonitor(id string, object SysFileExternalMonitor) (*SysFileExternalMonitor, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/externalMonitor/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileExternalMonitor), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchFileExternalMonitor")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileExternalMonitor), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchFileExternalMonitor")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileExternalMonitor)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchFileIfile
//
//
// iFile files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFileIfile(id string, object SysFileIfile) (*SysFileIfile, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/ifile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileIfile), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchFileIfile")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileIfile), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchFileIfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileIfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchFileSslCert
//
//
// SSL certificates management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFileSslCert(id string, object SysFileSslCert) (*SysFileSslCert, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSslCert), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchFileSslCert")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileSslCert), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchFileSslCert")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileSslCert)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchFileSslCrl
//
//
// SSL CRL files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFileSslCrl(id string, object SysFileSslCrl) (*SysFileSslCrl, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCrl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSslCrl), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchFileSslCrl")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileSslCrl), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchFileSslCrl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileSslCrl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchFileSslCsr
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFileSslCsr(id string, object SysFileSslCsr) (*SysFileSslCsr, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCsr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSslCsr), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchFileSslCsr")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileSslCsr), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchFileSslCsr")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileSslCsr)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchFileSslKey
//
//
// SSL certificate keys management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFileSslKey(id string, object SysFileSslKey) (*SysFileSslKey, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSslKey), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchFileSslKey")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileSslKey), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchFileSslKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileSslKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchFixConnection
//
//
// FIX connection level stats.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFixConnection(id string, object SysFixConnection) (*SysFixConnection, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fixConnection/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFixConnection), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchFixConnection")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFixConnection), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchFixConnection")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFixConnection)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchFolder
//
//
// Folder configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFolder(id string, object SysFolder) (*SysFolder, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/folder/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFolder), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchFolder")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFolder), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchFolder")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFolder)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchFpgaFirmwareConfig
//
//
// The current FPGA firmware configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFpgaFirmwareConfig(id string, object SysFpgaFirmwareConfig) (*SysFpgaFirmwareConfig, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fpga/firmwareConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFpgaFirmwareConfig), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchFpgaFirmwareConfig")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFpgaFirmwareConfig), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchFpgaFirmwareConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFpgaFirmwareConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchGlobalSettings
//
//
// General system settings.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchGlobalSettings(id string, object SysGlobalSettings) (*SysGlobalSettings, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/globalSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysGlobalSettings), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchGlobalSettings")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysGlobalSettings), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchGlobalSettings")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysGlobalSettings)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchHaGroup
//
//
// Specifies the ha group used to calculate the failover score..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchHaGroup(id string, object SysHaGroup) (*SysHaGroup, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysHaGroup), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchHaGroup")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysHaGroup), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchHaGroup")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysHaGroup)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchHttpd
//
//
// HTTPD configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchHttpd(id string, object SysHttpd) (*SysHttpd, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/httpd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysHttpd), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchHttpd")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysHttpd), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchHttpd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysHttpd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchIcallHandlerPeriodic
//
//
// iCall periodic handler.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchIcallHandlerPeriodic(id string, object SysIcallHandlerPeriodic) (*SysIcallHandlerPeriodic, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/periodic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallHandlerPeriodic), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchIcallHandlerPeriodic")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallHandlerPeriodic), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchIcallHandlerPeriodic")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallHandlerPeriodic)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchIcallHandlerPerpetual
//
//
// iCall perpetual handler.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchIcallHandlerPerpetual(id string, object SysIcallHandlerPerpetual) (*SysIcallHandlerPerpetual, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallHandlerPerpetual), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchIcallHandlerPerpetual")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallHandlerPerpetual), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchIcallHandlerPerpetual")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallHandlerPerpetual)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchIcallHandlerPerpetualSubscriptions
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchIcallHandlerPerpetualSubscriptions(id string, object SysIcallHandlerPerpetualSubscriptions) (*SysIcallHandlerPerpetualSubscriptions, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/subscriptions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallHandlerPerpetualSubscriptions), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchIcallHandlerPerpetualSubscriptions")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallHandlerPerpetualSubscriptions), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchIcallHandlerPerpetualSubscriptions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallHandlerPerpetualSubscriptions)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchIcallHandlerTriggered
//
//
// iCall event-triggered event handler.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchIcallHandlerTriggered(id string, object SysIcallHandlerTriggered) (*SysIcallHandlerTriggered, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallHandlerTriggered), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchIcallHandlerTriggered")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallHandlerTriggered), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchIcallHandlerTriggered")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallHandlerTriggered)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchIcallHandlerTriggeredSubscriptions
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchIcallHandlerTriggeredSubscriptions(id string, object SysIcallHandlerTriggeredSubscriptions) (*SysIcallHandlerTriggeredSubscriptions, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/subscriptions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallHandlerTriggeredSubscriptions), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchIcallHandlerTriggeredSubscriptions")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallHandlerTriggeredSubscriptions), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchIcallHandlerTriggeredSubscriptions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallHandlerTriggeredSubscriptions)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchIcallIstatsTrigger
//
//
// Event trigger for iStats.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchIcallIstatsTrigger(id string, object SysIcallIstatsTrigger) (*SysIcallIstatsTrigger, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/istatsTrigger/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallIstatsTrigger), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchIcallIstatsTrigger")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallIstatsTrigger), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchIcallIstatsTrigger")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallIstatsTrigger)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchIcallScript
//
//
// iCall script.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchIcallScript(id string, object SysIcallScript) (*SysIcallScript, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/script/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallScript), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchIcallScript")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallScript), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchIcallScript")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallScript)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchIcontrolSoap
//
//
// iControl SOAP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchIcontrolSoap(id string, object SysIcontrolSoap) (*SysIcontrolSoap, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icontrolSoap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcontrolSoap), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchIcontrolSoap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcontrolSoap), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchIcontrolSoap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcontrolSoap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchIpfixElement
//
//
// IPFIX element configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchIpfixElement(id string, object SysIpfixElement) (*SysIpfixElement, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/element/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIpfixElement), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchIpfixElement")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIpfixElement), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchIpfixElement")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIpfixElement)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchLogConfigDestinationAlertd
//
//
// Forwards messages to the AlertD daemon.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigDestinationAlertd(id string, object SysLogConfigDestinationAlertd) (*SysLogConfigDestinationAlertd, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/alertd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationAlertd), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchLogConfigDestinationAlertd")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationAlertd), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchLogConfigDestinationAlertd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationAlertd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchLogConfigDestinationArcsight
//
//
// Format messages to the ArcSight specification.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigDestinationArcsight(id string, object SysLogConfigDestinationArcsight) (*SysLogConfigDestinationArcsight, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/arcsight/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationArcsight), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchLogConfigDestinationArcsight")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationArcsight), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchLogConfigDestinationArcsight")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationArcsight)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchLogConfigDestinationIpfix
//
//
// Formats logs into IPFIX messages and transmits them to a pool of IPFIX Collectors.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigDestinationIpfix(id string, object SysLogConfigDestinationIpfix) (*SysLogConfigDestinationIpfix, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/ipfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationIpfix), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchLogConfigDestinationIpfix")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationIpfix), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchLogConfigDestinationIpfix")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationIpfix)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchLogConfigDestinationLocalDatabase
//
//
// Forwards messages to the local database.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigDestinationLocalDatabase(id string, object SysLogConfigDestinationLocalDatabase) (*SysLogConfigDestinationLocalDatabase, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/localDatabase/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationLocalDatabase), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchLogConfigDestinationLocalDatabase")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationLocalDatabase), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchLogConfigDestinationLocalDatabase")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationLocalDatabase)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchLogConfigDestinationLocalSyslog
//
//
// Forwards messages to the local Syslog-ng process.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigDestinationLocalSyslog(id string, object SysLogConfigDestinationLocalSyslog) (*SysLogConfigDestinationLocalSyslog, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/localSyslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationLocalSyslog), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchLogConfigDestinationLocalSyslog")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationLocalSyslog), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchLogConfigDestinationLocalSyslog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationLocalSyslog)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchLogConfigDestinationManagementPort
//
//
// Forwards messages to a destination through the management port.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigDestinationManagementPort(id string, object SysLogConfigDestinationManagementPort) (*SysLogConfigDestinationManagementPort, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/managementPort/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationManagementPort), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchLogConfigDestinationManagementPort")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationManagementPort), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchLogConfigDestinationManagementPort")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationManagementPort)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchLogConfigDestinationRemoteHighSpeedLog
//
//
// Forwards messages to a pool.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigDestinationRemoteHighSpeedLog(id string, object SysLogConfigDestinationRemoteHighSpeedLog) (*SysLogConfigDestinationRemoteHighSpeedLog, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteHighSpeedLog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationRemoteHighSpeedLog), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchLogConfigDestinationRemoteHighSpeedLog")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationRemoteHighSpeedLog), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchLogConfigDestinationRemoteHighSpeedLog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationRemoteHighSpeedLog)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchLogConfigDestinationRemoteSyslog
//
//
// Format messages to the Syslog format for remote logging.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigDestinationRemoteSyslog(id string, object SysLogConfigDestinationRemoteSyslog) (*SysLogConfigDestinationRemoteSyslog, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteSyslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationRemoteSyslog), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchLogConfigDestinationRemoteSyslog")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationRemoteSyslog), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchLogConfigDestinationRemoteSyslog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationRemoteSyslog)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchLogConfigDestinationSplunk
//
//
// Format messages to the Splunk specification.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigDestinationSplunk(id string, object SysLogConfigDestinationSplunk) (*SysLogConfigDestinationSplunk, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/splunk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationSplunk), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchLogConfigDestinationSplunk")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationSplunk), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchLogConfigDestinationSplunk")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationSplunk)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchLogConfigFilter
//
//
// Selectively route logs to log publishers.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigFilter(id string, object SysLogConfigFilter) (*SysLogConfigFilter, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/filter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigFilter), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchLogConfigFilter")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigFilter), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchLogConfigFilter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigFilter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchLogConfigPublisher
//
//
// List of log destinations.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigPublisher(id string, object SysLogConfigPublisher) (*SysLogConfigPublisher, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/publisher/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigPublisher), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchLogConfigPublisher")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigPublisher), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchLogConfigPublisher")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigPublisher)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchLogRotate
//
//
// Log rotation configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogRotate(id string, object SysLogRotate) (*SysLogRotate, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logRotate/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogRotate), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchLogRotate")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogRotate), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchLogRotate")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogRotate)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchLtcfgClassFields
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLtcfgClassFields(id string, object SysLtcfgClassFields) (*SysLtcfgClassFields, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgClass/fields/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLtcfgClassFields), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchLtcfgClassFields")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLtcfgClassFields), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchLtcfgClassFields")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLtcfgClassFields)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchLtcfgInstanceFields
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLtcfgInstanceFields(id string, object SysLtcfgInstanceFields) (*SysLtcfgInstanceFields, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgInstance/fields/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLtcfgInstanceFields), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchLtcfgInstanceFields")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLtcfgInstanceFields), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchLtcfgInstanceFields")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLtcfgInstanceFields)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchManagementDhcp
//
//
// DHCP configuration for the management interface.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchManagementDhcp(id string, object SysManagementDhcp) (*SysManagementDhcp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementDhcp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysManagementDhcp), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchManagementDhcp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysManagementDhcp), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchManagementDhcp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysManagementDhcp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchManagementIp
//
//
// Management port address configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchManagementIp(id string, object SysManagementIp) (*SysManagementIp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementIp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysManagementIp), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchManagementIp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysManagementIp), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchManagementIp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysManagementIp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchManagementOvsdb
//
//
// OVSDB configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchManagementOvsdb(id string, object SysManagementOvsdb) (*SysManagementOvsdb, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementOvsdb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysManagementOvsdb), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchManagementOvsdb")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysManagementOvsdb), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchManagementOvsdb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysManagementOvsdb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchManagementRoute
//
//
// Route configuration for the management interface.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchManagementRoute(id string, object SysManagementRoute) (*SysManagementRoute, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementRoute/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysManagementRoute), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchManagementRoute")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysManagementRoute), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchManagementRoute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysManagementRoute)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchNtp
//
//
// NTP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchNtp(id string, object SysNtp) (*SysNtp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ntp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysNtp), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchNtp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysNtp), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchNtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysNtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchNtpRestrict
//
//
// A restrict line in the NTP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchNtpRestrict(id string, object SysNtpRestrict) (*SysNtpRestrict, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ntp/restrict/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysNtpRestrict), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchNtpRestrict")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysNtpRestrict), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchNtpRestrict")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysNtpRestrict)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchOutboundSmtp
//
//
// Configuration for outbound email sent by the TMOS system.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchOutboundSmtp(id string, object SysOutboundSmtp) (*SysOutboundSmtp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/outboundSmtp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysOutboundSmtp), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchOutboundSmtp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysOutboundSmtp), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchOutboundSmtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysOutboundSmtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProvision
//
//
// Module resource configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchProvision(id string, object SysProvision) (*SysProvision, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/provision/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysProvision), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchProvision")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysProvision), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchProvision")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysProvision)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchRaidArray
//
//
// Manage the disk array.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchRaidArray(id string, object SysRaidArray) (*SysRaidArray, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/array/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysRaidArray), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchRaidArray")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysRaidArray), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchRaidArray")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysRaidArray)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchRaidBay
//
//
// Manage drive bays.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchRaidBay(id string, object SysRaidBay) (*SysRaidBay, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/bay/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysRaidBay), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchRaidBay")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysRaidBay), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchRaidBay")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysRaidBay)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchScriptd
//
//
// scriptd daemon configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchScriptd(id string, object SysScriptd) (*SysScriptd, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/scriptd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysScriptd), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchScriptd")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysScriptd), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchScriptd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysScriptd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchService
//
//
// Controls the BIG-IP system services..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchService(id string, object SysService) (*SysService, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/service/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysService), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchService")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysService), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchService")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysService)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchSflowGlobalSettingsHttp
//
//
// Global HTTP sFlow configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSflowGlobalSettingsHttp(id string, object SysSflowGlobalSettingsHttp) (*SysSflowGlobalSettingsHttp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/http/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowGlobalSettingsHttp), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchSflowGlobalSettingsHttp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSflowGlobalSettingsHttp), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchSflowGlobalSettingsHttp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSflowGlobalSettingsHttp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchSflowGlobalSettingsSystem
//
//
// Global system sFlow configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSflowGlobalSettingsSystem(id string, object SysSflowGlobalSettingsSystem) (*SysSflowGlobalSettingsSystem, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/system/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowGlobalSettingsSystem), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchSflowGlobalSettingsSystem")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSflowGlobalSettingsSystem), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchSflowGlobalSettingsSystem")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSflowGlobalSettingsSystem)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchSflowGlobalSettingsTmInterface
//
//
// Global sFlow configuration for interfaces.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSflowGlobalSettingsTmInterface(id string, object SysSflowGlobalSettingsTmInterface) (*SysSflowGlobalSettingsTmInterface, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/tmInterface/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowGlobalSettingsTmInterface), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchSflowGlobalSettingsTmInterface")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSflowGlobalSettingsTmInterface), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchSflowGlobalSettingsTmInterface")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSflowGlobalSettingsTmInterface)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchSflowGlobalSettingsVlan
//
//
// Global sFlow configuration for VLANs.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSflowGlobalSettingsVlan(id string, object SysSflowGlobalSettingsVlan) (*SysSflowGlobalSettingsVlan, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/vlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowGlobalSettingsVlan), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchSflowGlobalSettingsVlan")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSflowGlobalSettingsVlan), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchSflowGlobalSettingsVlan")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSflowGlobalSettingsVlan)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchSflowReceiver
//
//
// sFlow receiver configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSflowReceiver(id string, object SysSflowReceiver) (*SysSflowReceiver, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/receiver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowReceiver), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchSflowReceiver")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSflowReceiver), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchSflowReceiver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSflowReceiver)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchSmtpServer
//
//
// SMTP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSmtpServer(id string, object SysSmtpServer) (*SysSmtpServer, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/smtpServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSmtpServer), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchSmtpServer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSmtpServer), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchSmtpServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSmtpServer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchSnmp
//
//
// SNMP agent config.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSnmp(id string, object SysSnmp) (*SysSnmp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSnmp), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchSnmp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSnmp), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchSnmp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSnmp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchSnmpCommunities
//
//
// Specifies SNMP community strings and limits them to specific oid subsets..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSnmpCommunities(id string, object SysSnmpCommunities) (*SysSnmpCommunities, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/communities/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSnmpCommunities), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchSnmpCommunities")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSnmpCommunities), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchSnmpCommunities")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSnmpCommunities)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchSnmpTraps
//
//
// Generic interface for configuring SNMP traps..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSnmpTraps(id string, object SysSnmpTraps) (*SysSnmpTraps, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/traps/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSnmpTraps), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchSnmpTraps")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSnmpTraps), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchSnmpTraps")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSnmpTraps)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchSnmpUsers
//
//
// Specifies user account information for use with SNMPv3..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSnmpUsers(id string, object SysSnmpUsers) (*SysSnmpUsers, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/users/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSnmpUsers), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchSnmpUsers")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSnmpUsers), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchSnmpUsers")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSnmpUsers)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchSoftwareUpdate
//
//
// Manage software update checking.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSoftwareUpdate(id string, object SysSoftwareUpdate) (*SysSoftwareUpdate, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/update/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSoftwareUpdate), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchSoftwareUpdate")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSoftwareUpdate), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchSoftwareUpdate")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSoftwareUpdate)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchSshd
//
//
// SSHD configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSshd(id string, object SysSshd) (*SysSshd, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sshd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSshd), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchSshd")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSshd), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchSshd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSshd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchStateMirroring
//
//
// Redundant system connection mirroring configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchStateMirroring(id string, object SysStateMirroring) (*SysStateMirroring, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/stateMirroring/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysStateMirroring), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchStateMirroring")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysStateMirroring), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchStateMirroring")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysStateMirroring)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchSyslog
//
//
// System logging configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSyslog(id string, object SysSyslog) (*SysSyslog, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/syslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSyslog), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchSyslog")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSyslog), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchSyslog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSyslog)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchUrlDbDownloadSchedule
//
//
// URL Database Download Schedule.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchUrlDbDownloadSchedule(id string, object SysUrlDbDownloadSchedule) (*SysUrlDbDownloadSchedule, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/downloadSchedule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysUrlDbDownloadSchedule), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchUrlDbDownloadSchedule")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysUrlDbDownloadSchedule), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchUrlDbDownloadSchedule")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysUrlDbDownloadSchedule)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchUrlDbUrlCategory
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchUrlDbUrlCategory(id string, object SysUrlDbUrlCategory) (*SysUrlDbUrlCategory, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/urlCategory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysUrlDbUrlCategory), nil, errors.New("Missing required parameter 'id' when calling SysApi->PatchUrlDbUrlCategory")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysUrlDbUrlCategory), nil, errors.New("Missing required parameter 'object' when calling SysApi->PatchUrlDbUrlCategory")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysUrlDbUrlCategory)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostApplicationAplScript
//
//
// Scripts included by an application template.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostApplicationAplScript(id string, object SysApplicationAplScript) (*SysApplicationAplScript, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/aplScript/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysApplicationAplScript), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostApplicationAplScript")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysApplicationAplScript), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostApplicationAplScript")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysApplicationAplScript)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostApplicationCustomStat
//
//
// Derived iStats.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostApplicationCustomStat(id string, object SysApplicationCustomStat) (*SysApplicationCustomStat, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/customStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysApplicationCustomStat), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostApplicationCustomStat")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysApplicationCustomStat), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostApplicationCustomStat")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysApplicationCustomStat)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostApplicationService
//
//
// Application configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostApplicationService(id string, object SysApplicationService) (*SysApplicationService, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/service/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysApplicationService), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostApplicationService")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysApplicationService), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostApplicationService")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysApplicationService)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostApplicationTemplate
//
//
// Application templates.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostApplicationTemplate(id string, object SysApplicationTemplate) (*SysApplicationTemplate, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/template/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysApplicationTemplate), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostApplicationTemplate")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysApplicationTemplate), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostApplicationTemplate")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysApplicationTemplate)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostClassificationSignature
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostClassificationSignature(id string, object SysClassificationSignature) (*SysClassificationSignature, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/classificationSignature/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysClassificationSignature), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostClassificationSignature")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysClassificationSignature), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostClassificationSignature")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysClassificationSignature)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostConfig
//
//
// Save and load system configuration files.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostConfig(id string, object SysConfig) (*SysConfig, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/config/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysConfig), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostConfig")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysConfig), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostCryptoCert
//
//
// Certificate configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostCryptoCert(id string, object SysCryptoCert) (*SysCryptoCert, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/cert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoCert), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostCryptoCert")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysCryptoCert), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostCryptoCert")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysCryptoCert)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostCryptoCheckCert
//
//
// Certificate expiration check utility.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostCryptoCheckCert(id string, object SysCryptoCheckCert) (*SysCryptoCheckCert, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/checkCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoCheckCert), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostCryptoCheckCert")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysCryptoCheckCert), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostCryptoCheckCert")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysCryptoCheckCert)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostCryptoClient
//
//
// Crypto client configuration..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostCryptoClient(id string, object SysCryptoClient) (*SysCryptoClient, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/client/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoClient), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostCryptoClient")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysCryptoClient), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostCryptoClient")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysCryptoClient)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostCryptoCrl
//
//
// Certificate revocation list configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostCryptoCrl(id string, object SysCryptoCrl) (*SysCryptoCrl, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/crl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoCrl), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostCryptoCrl")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysCryptoCrl), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostCryptoCrl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysCryptoCrl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostCryptoCsr
//
//
// Certificate Signing Request configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostCryptoCsr(id string, object SysCryptoCsr) (*SysCryptoCsr, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/csr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoCsr), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostCryptoCsr")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysCryptoCsr), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostCryptoCsr")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysCryptoCsr)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostCryptoFipsExternalHsm
//
//
// FIPS external hsm specific configuration..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostCryptoFipsExternalHsm(id string, object SysCryptoFipsExternalHsm) (*SysCryptoFipsExternalHsm, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/externalHsm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoFipsExternalHsm), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostCryptoFipsExternalHsm")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysCryptoFipsExternalHsm), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostCryptoFipsExternalHsm")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysCryptoFipsExternalHsm)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostCryptoKey
//
//
// Key configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostCryptoKey(id string, object SysCryptoKey) (*SysCryptoKey, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/key/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoKey), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostCryptoKey")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysCryptoKey), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostCryptoKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysCryptoKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostCryptoMasterKey
//
//
// Displays internal encryption key information on a system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostCryptoMasterKey(id string, object SysCryptoMasterKey) (*SysCryptoMasterKey, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/masterKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoMasterKey), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostCryptoMasterKey")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysCryptoMasterKey), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostCryptoMasterKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysCryptoMasterKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostCryptoPkcs12
//
//
// PKCS12 configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostCryptoPkcs12(id string, object SysCryptoPkcs12) (*SysCryptoPkcs12, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/pkcs12/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoPkcs12), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostCryptoPkcs12")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysCryptoPkcs12), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostCryptoPkcs12")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysCryptoPkcs12)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostCryptoServer
//
//
// Crypto server configuration..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostCryptoServer(id string, object SysCryptoServer) (*SysCryptoServer, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/server/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoServer), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostCryptoServer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysCryptoServer), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostCryptoServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysCryptoServer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostEcmCloudProvider
//
//
// Describes the properties of all the cloud-providers.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostEcmCloudProvider(id string, object SysEcmCloudProvider) (*SysEcmCloudProvider, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/cloudProvider/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysEcmCloudProvider), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostEcmCloudProvider")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysEcmCloudProvider), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostEcmCloudProvider")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysEcmCloudProvider)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostFailover
//
//
// Redundant system failover state.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFailover(id string, object SysFailover) (*SysFailover, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/failover/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFailover), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostFailover")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFailover), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostFailover")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFailover)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostFileApacheSslCert
//
//
// SSL certificates management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileApacheSslCert(id string, object SysFileApacheSslCert) (*SysFileApacheSslCert, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/apacheSslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileApacheSslCert), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostFileApacheSslCert")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileApacheSslCert), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostFileApacheSslCert")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileApacheSslCert)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostFileDashboardViewset
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileDashboardViewset(id string, object SysFileDashboardViewset) (*SysFileDashboardViewset, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dashboardViewset/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileDashboardViewset), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostFileDashboardViewset")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileDashboardViewset), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostFileDashboardViewset")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileDashboardViewset)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostFileDataGroup
//
//
// External Data Group files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileDataGroup(id string, object SysFileDataGroup) (*SysFileDataGroup, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dataGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileDataGroup), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostFileDataGroup")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileDataGroup), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostFileDataGroup")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileDataGroup)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostFileDeviceCapabilitiesDb
//
//
// Device capabilities DB file management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileDeviceCapabilitiesDb(id string, object SysFileDeviceCapabilitiesDb) (*SysFileDeviceCapabilitiesDb, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/deviceCapabilitiesDb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileDeviceCapabilitiesDb), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostFileDeviceCapabilitiesDb")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileDeviceCapabilitiesDb), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostFileDeviceCapabilitiesDb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileDeviceCapabilitiesDb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostFileExternalMonitor
//
//
// External Monitor files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileExternalMonitor(id string, object SysFileExternalMonitor) (*SysFileExternalMonitor, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/externalMonitor/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileExternalMonitor), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostFileExternalMonitor")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileExternalMonitor), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostFileExternalMonitor")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileExternalMonitor)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostFileIfile
//
//
// iFile files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileIfile(id string, object SysFileIfile) (*SysFileIfile, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/ifile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileIfile), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostFileIfile")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileIfile), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostFileIfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileIfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostFileSslCert
//
//
// SSL certificates management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileSslCert(id string, object SysFileSslCert) (*SysFileSslCert, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSslCert), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostFileSslCert")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileSslCert), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostFileSslCert")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileSslCert)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostFileSslCrl
//
//
// SSL CRL files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileSslCrl(id string, object SysFileSslCrl) (*SysFileSslCrl, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCrl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSslCrl), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostFileSslCrl")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileSslCrl), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostFileSslCrl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileSslCrl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostFileSslCsr
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileSslCsr(id string, object SysFileSslCsr) (*SysFileSslCsr, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCsr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSslCsr), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostFileSslCsr")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileSslCsr), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostFileSslCsr")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileSslCsr)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostFileSslKey
//
//
// SSL certificate keys management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileSslKey(id string, object SysFileSslKey) (*SysFileSslKey, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSslKey), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostFileSslKey")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileSslKey), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostFileSslKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileSslKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostFileSystemSslCert
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileSystemSslCert(id string, object SysFileSystemSslCert) (*SysFileSystemSslCert, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/systemSslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSystemSslCert), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostFileSystemSslCert")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileSystemSslCert), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostFileSystemSslCert")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileSystemSslCert)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostFileSystemSslKey
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileSystemSslKey(id string, object SysFileSystemSslKey) (*SysFileSystemSslKey, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/systemSslKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSystemSslKey), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostFileSystemSslKey")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileSystemSslKey), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostFileSystemSslKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileSystemSslKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostFolder
//
//
// Folder configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFolder(id string, object SysFolder) (*SysFolder, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/folder/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFolder), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostFolder")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFolder), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostFolder")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFolder)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostFpgaFirmwareConfig
//
//
// The current FPGA firmware configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFpgaFirmwareConfig(id string, object SysFpgaFirmwareConfig) (*SysFpgaFirmwareConfig, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fpga/firmwareConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFpgaFirmwareConfig), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostFpgaFirmwareConfig")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFpgaFirmwareConfig), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostFpgaFirmwareConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFpgaFirmwareConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostGeoip
//
//
// Load GeoIP data files.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostGeoip(id string, object SysGeoip) (*SysGeoip, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/geoip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysGeoip), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostGeoip")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysGeoip), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostGeoip")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysGeoip)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostHaGroup
//
//
// Specifies the ha group used to calculate the failover score..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostHaGroup(id string, object SysHaGroup) (*SysHaGroup, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysHaGroup), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostHaGroup")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysHaGroup), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostHaGroup")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysHaGroup)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostHaMirror
//
//
// Statistics for connection mirroring..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostHaMirror(id string, object SysHaMirror) (*SysHaMirror, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haMirror/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysHaMirror), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostHaMirror")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysHaMirror), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostHaMirror")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysHaMirror)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostIcallEvent
//
//
// iCall event.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIcallEvent(id string, object SysIcallEvent) (*SysIcallEvent, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/event/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallEvent), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostIcallEvent")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallEvent), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostIcallEvent")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallEvent)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostIcallHandlerPeriodic
//
//
// iCall periodic handler.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIcallHandlerPeriodic(id string, object SysIcallHandlerPeriodic) (*SysIcallHandlerPeriodic, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/periodic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallHandlerPeriodic), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostIcallHandlerPeriodic")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallHandlerPeriodic), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostIcallHandlerPeriodic")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallHandlerPeriodic)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostIcallHandlerPerpetual
//
//
// iCall perpetual handler.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIcallHandlerPerpetual(id string, object SysIcallHandlerPerpetual) (*SysIcallHandlerPerpetual, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallHandlerPerpetual), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostIcallHandlerPerpetual")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallHandlerPerpetual), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostIcallHandlerPerpetual")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallHandlerPerpetual)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostIcallHandlerPerpetualSubscriptions
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIcallHandlerPerpetualSubscriptions(id string, object SysIcallHandlerPerpetualSubscriptions) (*SysIcallHandlerPerpetualSubscriptions, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/subscriptions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallHandlerPerpetualSubscriptions), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostIcallHandlerPerpetualSubscriptions")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallHandlerPerpetualSubscriptions), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostIcallHandlerPerpetualSubscriptions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallHandlerPerpetualSubscriptions)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostIcallHandlerTriggered
//
//
// iCall event-triggered event handler.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIcallHandlerTriggered(id string, object SysIcallHandlerTriggered) (*SysIcallHandlerTriggered, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallHandlerTriggered), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostIcallHandlerTriggered")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallHandlerTriggered), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostIcallHandlerTriggered")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallHandlerTriggered)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostIcallHandlerTriggeredSubscriptions
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIcallHandlerTriggeredSubscriptions(id string, object SysIcallHandlerTriggeredSubscriptions) (*SysIcallHandlerTriggeredSubscriptions, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/subscriptions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallHandlerTriggeredSubscriptions), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostIcallHandlerTriggeredSubscriptions")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallHandlerTriggeredSubscriptions), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostIcallHandlerTriggeredSubscriptions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallHandlerTriggeredSubscriptions)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostIcallIstatsTrigger
//
//
// Event trigger for iStats.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIcallIstatsTrigger(id string, object SysIcallIstatsTrigger) (*SysIcallIstatsTrigger, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/istatsTrigger/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallIstatsTrigger), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostIcallIstatsTrigger")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallIstatsTrigger), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostIcallIstatsTrigger")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallIstatsTrigger)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostIcallScript
//
//
// iCall script.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIcallScript(id string, object SysIcallScript) (*SysIcallScript, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/script/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallScript), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostIcallScript")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallScript), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostIcallScript")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallScript)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostIcmpStat
//
//
// Standard ICMP statistics, including ICMPv4 packets and errors, and ICMPv6 packets and errors..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIcmpStat(id string, object SysIcmpStat) (*SysIcmpStat, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icmpStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcmpStat), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostIcmpStat")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcmpStat), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostIcmpStat")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcmpStat)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostIpStat
//
//
// Standard IP statistics, including IPv4 and IPv6 packets, fragments, fragments reassembled, and errors..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIpStat(id string, object SysIpStat) (*SysIpStat, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIpStat), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostIpStat")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIpStat), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostIpStat")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIpStat)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostIpfixDestination
//
//
// IPFIX destination statistics, including Template and Data Record counts.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIpfixDestination(id string, object SysIpfixDestination) (*SysIpfixDestination, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/destination/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIpfixDestination), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostIpfixDestination")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIpfixDestination), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostIpfixDestination")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIpfixDestination)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostIpfixElement
//
//
// IPFIX element configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIpfixElement(id string, object SysIpfixElement) (*SysIpfixElement, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/element/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIpfixElement), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostIpfixElement")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIpfixElement), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostIpfixElement")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIpfixElement)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostIpfixIrules
//
//
// IPFIX iRules statistics, including allocated and outstanding memory.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIpfixIrules(id string, object SysIpfixIrules) (*SysIpfixIrules, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/irules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIpfixIrules), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostIpfixIrules")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIpfixIrules), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostIpfixIrules")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIpfixIrules)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostIprep
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIprep(id string, object SysIprep) (*SysIprep, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/iprep/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIprep), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostIprep")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIprep), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostIprep")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIprep)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostLicense
//
//
// Manage the system license.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLicense(id string, object SysLicense) (*SysLicense, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/license/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLicense), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostLicense")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLicense), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostLicense")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLicense)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostLogConfigDestinationAlertd
//
//
// Forwards messages to the AlertD daemon.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigDestinationAlertd(id string, object SysLogConfigDestinationAlertd) (*SysLogConfigDestinationAlertd, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/alertd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationAlertd), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostLogConfigDestinationAlertd")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationAlertd), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostLogConfigDestinationAlertd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationAlertd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostLogConfigDestinationArcsight
//
//
// Format messages to the ArcSight specification.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigDestinationArcsight(id string, object SysLogConfigDestinationArcsight) (*SysLogConfigDestinationArcsight, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/arcsight/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationArcsight), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostLogConfigDestinationArcsight")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationArcsight), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostLogConfigDestinationArcsight")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationArcsight)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostLogConfigDestinationIpfix
//
//
// Formats logs into IPFIX messages and transmits them to a pool of IPFIX Collectors.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigDestinationIpfix(id string, object SysLogConfigDestinationIpfix) (*SysLogConfigDestinationIpfix, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/ipfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationIpfix), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostLogConfigDestinationIpfix")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationIpfix), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostLogConfigDestinationIpfix")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationIpfix)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostLogConfigDestinationLocalDatabase
//
//
// Forwards messages to the local database.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigDestinationLocalDatabase(id string, object SysLogConfigDestinationLocalDatabase) (*SysLogConfigDestinationLocalDatabase, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/localDatabase/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationLocalDatabase), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostLogConfigDestinationLocalDatabase")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationLocalDatabase), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostLogConfigDestinationLocalDatabase")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationLocalDatabase)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostLogConfigDestinationLocalSyslog
//
//
// Forwards messages to the local Syslog-ng process.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigDestinationLocalSyslog(id string, object SysLogConfigDestinationLocalSyslog) (*SysLogConfigDestinationLocalSyslog, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/localSyslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationLocalSyslog), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostLogConfigDestinationLocalSyslog")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationLocalSyslog), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostLogConfigDestinationLocalSyslog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationLocalSyslog)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostLogConfigDestinationManagementPort
//
//
// Forwards messages to a destination through the management port.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigDestinationManagementPort(id string, object SysLogConfigDestinationManagementPort) (*SysLogConfigDestinationManagementPort, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/managementPort/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationManagementPort), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostLogConfigDestinationManagementPort")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationManagementPort), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostLogConfigDestinationManagementPort")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationManagementPort)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostLogConfigDestinationRemoteHighSpeedLog
//
//
// Forwards messages to a pool.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigDestinationRemoteHighSpeedLog(id string, object SysLogConfigDestinationRemoteHighSpeedLog) (*SysLogConfigDestinationRemoteHighSpeedLog, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteHighSpeedLog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationRemoteHighSpeedLog), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostLogConfigDestinationRemoteHighSpeedLog")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationRemoteHighSpeedLog), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostLogConfigDestinationRemoteHighSpeedLog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationRemoteHighSpeedLog)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostLogConfigDestinationRemoteSyslog
//
//
// Format messages to the Syslog format for remote logging.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigDestinationRemoteSyslog(id string, object SysLogConfigDestinationRemoteSyslog) (*SysLogConfigDestinationRemoteSyslog, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteSyslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationRemoteSyslog), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostLogConfigDestinationRemoteSyslog")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationRemoteSyslog), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostLogConfigDestinationRemoteSyslog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationRemoteSyslog)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostLogConfigDestinationSplunk
//
//
// Format messages to the Splunk specification.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigDestinationSplunk(id string, object SysLogConfigDestinationSplunk) (*SysLogConfigDestinationSplunk, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/splunk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationSplunk), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostLogConfigDestinationSplunk")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationSplunk), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostLogConfigDestinationSplunk")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationSplunk)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostLogConfigFilter
//
//
// Selectively route logs to log publishers.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigFilter(id string, object SysLogConfigFilter) (*SysLogConfigFilter, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/filter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigFilter), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostLogConfigFilter")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigFilter), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostLogConfigFilter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigFilter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostLogConfigPublisher
//
//
// List of log destinations.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigPublisher(id string, object SysLogConfigPublisher) (*SysLogConfigPublisher, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/publisher/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigPublisher), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostLogConfigPublisher")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigPublisher), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostLogConfigPublisher")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigPublisher)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostLtcfgClass
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLtcfgClass(id string, object SysLtcfgClass) (*SysLtcfgClass, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgClass/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLtcfgClass), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostLtcfgClass")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLtcfgClass), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostLtcfgClass")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLtcfgClass)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostLtcfgClassFields
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLtcfgClassFields(id string, object SysLtcfgClassFields) (*SysLtcfgClassFields, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgClass/fields/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLtcfgClassFields), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostLtcfgClassFields")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLtcfgClassFields), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostLtcfgClassFields")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLtcfgClassFields)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostLtcfgInstance
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLtcfgInstance(id string, object SysLtcfgInstance) (*SysLtcfgInstance, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgInstance/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLtcfgInstance), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostLtcfgInstance")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLtcfgInstance), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostLtcfgInstance")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLtcfgInstance)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostLtcfgInstanceFields
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLtcfgInstanceFields(id string, object SysLtcfgInstanceFields) (*SysLtcfgInstanceFields, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgInstance/fields/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLtcfgInstanceFields), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostLtcfgInstanceFields")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLtcfgInstanceFields), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostLtcfgInstanceFields")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLtcfgInstanceFields)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostManagementIp
//
//
// Management port address configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostManagementIp(id string, object SysManagementIp) (*SysManagementIp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementIp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysManagementIp), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostManagementIp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysManagementIp), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostManagementIp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysManagementIp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostManagementRoute
//
//
// Route configuration for the management interface.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostManagementRoute(id string, object SysManagementRoute) (*SysManagementRoute, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementRoute/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysManagementRoute), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostManagementRoute")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysManagementRoute), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostManagementRoute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysManagementRoute)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostNtpRestrict
//
//
// A restrict line in the NTP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostNtpRestrict(id string, object SysNtpRestrict) (*SysNtpRestrict, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ntp/restrict/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysNtpRestrict), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostNtpRestrict")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysNtpRestrict), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostNtpRestrict")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysNtpRestrict)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostPerformanceAllStats
//
//
// View or reset all available performance statistics.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostPerformanceAllStats(id string, object SysPerformanceAllStats) (*SysPerformanceAllStats, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/allStats/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysPerformanceAllStats), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostPerformanceAllStats")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysPerformanceAllStats), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostPerformanceAllStats")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysPerformanceAllStats)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostPvaTraffic
//
//
// Packet Velocity Acceleration Engine&#39;s (PVA) traffic statistics..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostPvaTraffic(id string, object SysPvaTraffic) (*SysPvaTraffic, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/pvaTraffic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysPvaTraffic), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostPvaTraffic")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysPvaTraffic), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostPvaTraffic")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysPvaTraffic)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostRestrictedModule
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostRestrictedModule(id string, object SysRestrictedModule) (*SysRestrictedModule, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/restrictedModule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysRestrictedModule), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostRestrictedModule")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysRestrictedModule), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostRestrictedModule")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysRestrictedModule)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostService
//
//
// Controls the BIG-IP system services..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostService(id string, object SysService) (*SysService, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/service/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysService), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostService")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysService), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostService")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysService)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostSflowReceiver
//
//
// sFlow receiver configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostSflowReceiver(id string, object SysSflowReceiver) (*SysSflowReceiver, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/receiver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowReceiver), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostSflowReceiver")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSflowReceiver), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostSflowReceiver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSflowReceiver)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostSmtpServer
//
//
// SMTP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostSmtpServer(id string, object SysSmtpServer) (*SysSmtpServer, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/smtpServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSmtpServer), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostSmtpServer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSmtpServer), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostSmtpServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSmtpServer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostSnmpCommunities
//
//
// Specifies SNMP community strings and limits them to specific oid subsets..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostSnmpCommunities(id string, object SysSnmpCommunities) (*SysSnmpCommunities, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/communities/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSnmpCommunities), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostSnmpCommunities")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSnmpCommunities), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostSnmpCommunities")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSnmpCommunities)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostSnmpTraps
//
//
// Generic interface for configuring SNMP traps..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostSnmpTraps(id string, object SysSnmpTraps) (*SysSnmpTraps, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/traps/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSnmpTraps), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostSnmpTraps")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSnmpTraps), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostSnmpTraps")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSnmpTraps)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostSnmpUsers
//
//
// Specifies user account information for use with SNMPv3..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostSnmpUsers(id string, object SysSnmpUsers) (*SysSnmpUsers, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/users/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSnmpUsers), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostSnmpUsers")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSnmpUsers), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostSnmpUsers")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSnmpUsers)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostSoftwareBlockDeviceHotfix
//
//
// Manage block device hotfix images.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostSoftwareBlockDeviceHotfix(id string, object SysSoftwareBlockDeviceHotfix) (*SysSoftwareBlockDeviceHotfix, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/blockDeviceHotfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSoftwareBlockDeviceHotfix), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostSoftwareBlockDeviceHotfix")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSoftwareBlockDeviceHotfix), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostSoftwareBlockDeviceHotfix")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSoftwareBlockDeviceHotfix)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostSoftwareBlockDeviceImage
//
//
// Manage block device software images.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostSoftwareBlockDeviceImage(id string, object SysSoftwareBlockDeviceImage) (*SysSoftwareBlockDeviceImage, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/blockDeviceImage/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSoftwareBlockDeviceImage), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostSoftwareBlockDeviceImage")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSoftwareBlockDeviceImage), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostSoftwareBlockDeviceImage")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSoftwareBlockDeviceImage)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostSoftwareHotfix
//
//
// Manage hotfix images.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostSoftwareHotfix(id string, object SysSoftwareHotfix) (*SysSoftwareHotfix, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/hotfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSoftwareHotfix), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostSoftwareHotfix")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSoftwareHotfix), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostSoftwareHotfix")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSoftwareHotfix)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostSoftwareImage
//
//
// Manage software images.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostSoftwareImage(id string, object SysSoftwareImage) (*SysSoftwareImage, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/image/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSoftwareImage), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostSoftwareImage")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSoftwareImage), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostSoftwareImage")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSoftwareImage)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostSyncSysFiles
//
//
// Sync System Files.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostSyncSysFiles(id string, object SysSyncSysFiles) (*SysSyncSysFiles, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/syncSysFiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSyncSysFiles), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostSyncSysFiles")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSyncSysFiles), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostSyncSysFiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSyncSysFiles)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostTmmTraffic
//
//
// Traffic management statistics, including traffic information, error, and connections redirected..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostTmmTraffic(id string, object SysTmmTraffic) (*SysTmmTraffic, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/tmmTraffic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysTmmTraffic), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostTmmTraffic")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysTmmTraffic), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostTmmTraffic")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysTmmTraffic)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostTraffic
//
//
// Global traffic statistics.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostTraffic(id string, object SysTraffic) (*SysTraffic, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/traffic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysTraffic), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostTraffic")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysTraffic), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostTraffic")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysTraffic)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostUcs
//
//
// Save and restore configuration from UCS files.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostUcs(id string, object SysUcs) (*SysUcs, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ucs/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysUcs), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostUcs")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysUcs), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostUcs")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysUcs)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostUrlDbUrlCategory
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostUrlDbUrlCategory(id string, object SysUrlDbUrlCategory) (*SysUrlDbUrlCategory, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/urlCategory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysUrlDbUrlCategory), nil, errors.New("Missing required parameter 'id' when calling SysApi->PostUrlDbUrlCategory")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysUrlDbUrlCategory), nil, errors.New("Missing required parameter 'object' when calling SysApi->PostUrlDbUrlCategory")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysUrlDbUrlCategory)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutApplicationAplScript
//
//
// Scripts included by an application template.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutApplicationAplScript(id string, object SysApplicationAplScript) (*SysApplicationAplScript, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/aplScript/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysApplicationAplScript), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutApplicationAplScript")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysApplicationAplScript), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutApplicationAplScript")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysApplicationAplScript)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutApplicationCustomStat
//
//
// Derived iStats.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutApplicationCustomStat(id string, object SysApplicationCustomStat) (*SysApplicationCustomStat, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/customStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysApplicationCustomStat), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutApplicationCustomStat")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysApplicationCustomStat), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutApplicationCustomStat")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysApplicationCustomStat)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutApplicationService
//
//
// Application configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutApplicationService(id string, object SysApplicationService) (*SysApplicationService, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/service/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysApplicationService), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutApplicationService")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysApplicationService), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutApplicationService")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysApplicationService)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutApplicationTemplate
//
//
// Application templates.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutApplicationTemplate(id string, object SysApplicationTemplate) (*SysApplicationTemplate, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/template/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysApplicationTemplate), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutApplicationTemplate")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysApplicationTemplate), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutApplicationTemplate")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysApplicationTemplate)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutApplicationTemplateActions
//
//
// Manage the set of actions associated with an application template..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutApplicationTemplateActions(id string, object SysApplicationTemplateActions) (*SysApplicationTemplateActions, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/template/actions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysApplicationTemplateActions), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutApplicationTemplateActions")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysApplicationTemplateActions), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutApplicationTemplateActions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysApplicationTemplateActions)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutAutoscaleGroup
//
//
// Autoscale group information for Amazon Web Services(AWS)..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutAutoscaleGroup(id string, object SysAutoscaleGroup) (*SysAutoscaleGroup, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/autoscaleGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysAutoscaleGroup), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutAutoscaleGroup")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysAutoscaleGroup), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutAutoscaleGroup")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysAutoscaleGroup)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutClock
//
//
// Display the current date and time.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutClock(id string, object SysClock) (*SysClock, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/clock/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysClock), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutClock")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysClock), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutClock")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysClock)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutCluster
//
//
// Cluster configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutCluster(id string, object SysCluster) (*SysCluster, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/cluster/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCluster), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutCluster")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysCluster), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutCluster")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysCluster)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutConnection
//
//
// Displays or deletes active connections on the BIG-IP system.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutConnection(id string, object SysConnection) (*SysConnection, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/connection/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysConnection), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutConnection")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysConnection), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutConnection")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysConnection)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutConsole
//
//
// Configure the serial console.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutConsole(id string, object SysConsole) (*SysConsole, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/console/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysConsole), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutConsole")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysConsole), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutConsole")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysConsole)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutCryptoClient
//
//
// Crypto client configuration..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutCryptoClient(id string, object SysCryptoClient) (*SysCryptoClient, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/client/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoClient), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutCryptoClient")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysCryptoClient), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutCryptoClient")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysCryptoClient)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutCryptoFipsExternalHsm
//
//
// FIPS external hsm specific configuration..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutCryptoFipsExternalHsm(id string, object SysCryptoFipsExternalHsm) (*SysCryptoFipsExternalHsm, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/externalHsm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoFipsExternalHsm), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutCryptoFipsExternalHsm")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysCryptoFipsExternalHsm), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutCryptoFipsExternalHsm")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysCryptoFipsExternalHsm)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutCryptoMasterKey
//
//
// Displays internal encryption key information on a system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutCryptoMasterKey(id string, object SysCryptoMasterKey) (*SysCryptoMasterKey, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/masterKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoMasterKey), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutCryptoMasterKey")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysCryptoMasterKey), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutCryptoMasterKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysCryptoMasterKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutCryptoServer
//
//
// Crypto server configuration..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutCryptoServer(id string, object SysCryptoServer) (*SysCryptoServer, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/server/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysCryptoServer), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutCryptoServer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysCryptoServer), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutCryptoServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysCryptoServer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDaemonHa
//
//
// System daemon HA configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDaemonHa(id string, object SysDaemonHa) (*SysDaemonHa, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonHa/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonHa), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutDaemonHa")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDaemonHa), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutDaemonHa")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDaemonHa)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDaemonLogSettingsClusterd
//
//
// The clusterd daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDaemonLogSettingsClusterd(id string, object SysDaemonLogSettingsClusterd) (*SysDaemonLogSettingsClusterd, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/clusterd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonLogSettingsClusterd), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutDaemonLogSettingsClusterd")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDaemonLogSettingsClusterd), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutDaemonLogSettingsClusterd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDaemonLogSettingsClusterd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDaemonLogSettingsCsyncd
//
//
// The csyncd daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDaemonLogSettingsCsyncd(id string, object SysDaemonLogSettingsCsyncd) (*SysDaemonLogSettingsCsyncd, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/csyncd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonLogSettingsCsyncd), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutDaemonLogSettingsCsyncd")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDaemonLogSettingsCsyncd), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutDaemonLogSettingsCsyncd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDaemonLogSettingsCsyncd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDaemonLogSettingsIcrd
//
//
// The icrd daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDaemonLogSettingsIcrd(id string, object SysDaemonLogSettingsIcrd) (*SysDaemonLogSettingsIcrd, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/icrd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonLogSettingsIcrd), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutDaemonLogSettingsIcrd")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDaemonLogSettingsIcrd), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutDaemonLogSettingsIcrd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDaemonLogSettingsIcrd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDaemonLogSettingsLind
//
//
// The lind daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDaemonLogSettingsLind(id string, object SysDaemonLogSettingsLind) (*SysDaemonLogSettingsLind, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/lind/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonLogSettingsLind), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutDaemonLogSettingsLind")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDaemonLogSettingsLind), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutDaemonLogSettingsLind")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDaemonLogSettingsLind)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDaemonLogSettingsMcpd
//
//
// The mcpd daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDaemonLogSettingsMcpd(id string, object SysDaemonLogSettingsMcpd) (*SysDaemonLogSettingsMcpd, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/mcpd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonLogSettingsMcpd), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutDaemonLogSettingsMcpd")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDaemonLogSettingsMcpd), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutDaemonLogSettingsMcpd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDaemonLogSettingsMcpd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDaemonLogSettingsTmm
//
//
// The tmm daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDaemonLogSettingsTmm(id string, object SysDaemonLogSettingsTmm) (*SysDaemonLogSettingsTmm, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/tmm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDaemonLogSettingsTmm), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutDaemonLogSettingsTmm")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDaemonLogSettingsTmm), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutDaemonLogSettingsTmm")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDaemonLogSettingsTmm)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDatastor
//
//
// Optimization data storage configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDatastor(id string, object SysDatastor) (*SysDatastor, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/datastor/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDatastor), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutDatastor")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDatastor), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutDatastor")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDatastor)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDb
//
//
// General system properties.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDb(id string, object SysDb) (*SysDb, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/db/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDb), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutDb")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDb), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutDb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDiskDirectory
//
//
// System directory resize operations..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDiskDirectory(id string, object SysDiskDirectory) (*SysDiskDirectory, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/directory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDiskDirectory), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutDiskDirectory")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDiskDirectory), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutDiskDirectory")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDiskDirectory)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDiskLogicalDisk
//
//
// Logical Disk Configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDiskLogicalDisk(id string, object SysDiskLogicalDisk) (*SysDiskLogicalDisk, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/logicalDisk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDiskLogicalDisk), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutDiskLogicalDisk")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDiskLogicalDisk), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutDiskLogicalDisk")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDiskLogicalDisk)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDns
//
//
// DNS configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDns(id string, object SysDns) (*SysDns, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/dns/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysDns), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutDns")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysDns), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutDns")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysDns)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutEcmCloudProvider
//
//
// Describes the properties of all the cloud-providers.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutEcmCloudProvider(id string, object SysEcmCloudProvider) (*SysEcmCloudProvider, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/cloudProvider/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysEcmCloudProvider), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutEcmCloudProvider")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysEcmCloudProvider), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutEcmCloudProvider")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysEcmCloudProvider)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutEcmConfig
//
//
// Specifies the ecm configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutEcmConfig(id string, object SysEcmConfig) (*SysEcmConfig, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/config/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysEcmConfig), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutEcmConfig")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysEcmConfig), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutEcmConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysEcmConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutFeatureModule
//
//
// Feature module configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFeatureModule(id string, object SysFeatureModule) (*SysFeatureModule, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/featureModule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFeatureModule), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutFeatureModule")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFeatureModule), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutFeatureModule")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFeatureModule)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutFileApacheSslCert
//
//
// SSL certificates management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFileApacheSslCert(id string, object SysFileApacheSslCert) (*SysFileApacheSslCert, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/apacheSslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileApacheSslCert), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutFileApacheSslCert")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileApacheSslCert), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutFileApacheSslCert")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileApacheSslCert)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutFileDashboardViewset
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFileDashboardViewset(id string, object SysFileDashboardViewset) (*SysFileDashboardViewset, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dashboardViewset/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileDashboardViewset), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutFileDashboardViewset")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileDashboardViewset), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutFileDashboardViewset")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileDashboardViewset)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutFileDataGroup
//
//
// External Data Group files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFileDataGroup(id string, object SysFileDataGroup) (*SysFileDataGroup, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dataGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileDataGroup), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutFileDataGroup")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileDataGroup), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutFileDataGroup")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileDataGroup)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutFileDeviceCapabilitiesDb
//
//
// Device capabilities DB file management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFileDeviceCapabilitiesDb(id string, object SysFileDeviceCapabilitiesDb) (*SysFileDeviceCapabilitiesDb, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/deviceCapabilitiesDb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileDeviceCapabilitiesDb), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutFileDeviceCapabilitiesDb")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileDeviceCapabilitiesDb), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutFileDeviceCapabilitiesDb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileDeviceCapabilitiesDb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutFileExternalMonitor
//
//
// External Monitor files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFileExternalMonitor(id string, object SysFileExternalMonitor) (*SysFileExternalMonitor, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/externalMonitor/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileExternalMonitor), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutFileExternalMonitor")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileExternalMonitor), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutFileExternalMonitor")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileExternalMonitor)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutFileIfile
//
//
// iFile files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFileIfile(id string, object SysFileIfile) (*SysFileIfile, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/ifile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileIfile), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutFileIfile")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileIfile), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutFileIfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileIfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutFileSslCert
//
//
// SSL certificates management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFileSslCert(id string, object SysFileSslCert) (*SysFileSslCert, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSslCert), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutFileSslCert")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileSslCert), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutFileSslCert")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileSslCert)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutFileSslCrl
//
//
// SSL CRL files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFileSslCrl(id string, object SysFileSslCrl) (*SysFileSslCrl, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCrl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSslCrl), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutFileSslCrl")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileSslCrl), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutFileSslCrl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileSslCrl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutFileSslCsr
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFileSslCsr(id string, object SysFileSslCsr) (*SysFileSslCsr, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCsr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSslCsr), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutFileSslCsr")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileSslCsr), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutFileSslCsr")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileSslCsr)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutFileSslKey
//
//
// SSL certificate keys management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFileSslKey(id string, object SysFileSslKey) (*SysFileSslKey, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFileSslKey), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutFileSslKey")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFileSslKey), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutFileSslKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFileSslKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutFixConnection
//
//
// FIX connection level stats.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFixConnection(id string, object SysFixConnection) (*SysFixConnection, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fixConnection/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFixConnection), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutFixConnection")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFixConnection), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutFixConnection")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFixConnection)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutFolder
//
//
// Folder configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFolder(id string, object SysFolder) (*SysFolder, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/folder/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFolder), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutFolder")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFolder), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutFolder")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFolder)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutFpgaFirmwareConfig
//
//
// The current FPGA firmware configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFpgaFirmwareConfig(id string, object SysFpgaFirmwareConfig) (*SysFpgaFirmwareConfig, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fpga/firmwareConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysFpgaFirmwareConfig), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutFpgaFirmwareConfig")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysFpgaFirmwareConfig), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutFpgaFirmwareConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysFpgaFirmwareConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutGlobalSettings
//
//
// General system settings.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutGlobalSettings(id string, object SysGlobalSettings) (*SysGlobalSettings, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/globalSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysGlobalSettings), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutGlobalSettings")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysGlobalSettings), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutGlobalSettings")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysGlobalSettings)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutHaGroup
//
//
// Specifies the ha group used to calculate the failover score..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutHaGroup(id string, object SysHaGroup) (*SysHaGroup, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysHaGroup), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutHaGroup")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysHaGroup), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutHaGroup")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysHaGroup)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutHttpd
//
//
// HTTPD configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutHttpd(id string, object SysHttpd) (*SysHttpd, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/httpd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysHttpd), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutHttpd")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysHttpd), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutHttpd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysHttpd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutIcallHandlerPeriodic
//
//
// iCall periodic handler.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutIcallHandlerPeriodic(id string, object SysIcallHandlerPeriodic) (*SysIcallHandlerPeriodic, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/periodic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallHandlerPeriodic), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutIcallHandlerPeriodic")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallHandlerPeriodic), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutIcallHandlerPeriodic")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallHandlerPeriodic)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutIcallHandlerPerpetual
//
//
// iCall perpetual handler.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutIcallHandlerPerpetual(id string, object SysIcallHandlerPerpetual) (*SysIcallHandlerPerpetual, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallHandlerPerpetual), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutIcallHandlerPerpetual")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallHandlerPerpetual), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutIcallHandlerPerpetual")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallHandlerPerpetual)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutIcallHandlerPerpetualSubscriptions
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutIcallHandlerPerpetualSubscriptions(id string, object SysIcallHandlerPerpetualSubscriptions) (*SysIcallHandlerPerpetualSubscriptions, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/subscriptions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallHandlerPerpetualSubscriptions), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutIcallHandlerPerpetualSubscriptions")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallHandlerPerpetualSubscriptions), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutIcallHandlerPerpetualSubscriptions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallHandlerPerpetualSubscriptions)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutIcallHandlerTriggered
//
//
// iCall event-triggered event handler.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutIcallHandlerTriggered(id string, object SysIcallHandlerTriggered) (*SysIcallHandlerTriggered, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallHandlerTriggered), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutIcallHandlerTriggered")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallHandlerTriggered), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutIcallHandlerTriggered")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallHandlerTriggered)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutIcallHandlerTriggeredSubscriptions
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutIcallHandlerTriggeredSubscriptions(id string, object SysIcallHandlerTriggeredSubscriptions) (*SysIcallHandlerTriggeredSubscriptions, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/subscriptions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallHandlerTriggeredSubscriptions), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutIcallHandlerTriggeredSubscriptions")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallHandlerTriggeredSubscriptions), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutIcallHandlerTriggeredSubscriptions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallHandlerTriggeredSubscriptions)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutIcallIstatsTrigger
//
//
// Event trigger for iStats.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutIcallIstatsTrigger(id string, object SysIcallIstatsTrigger) (*SysIcallIstatsTrigger, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/istatsTrigger/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallIstatsTrigger), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutIcallIstatsTrigger")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallIstatsTrigger), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutIcallIstatsTrigger")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallIstatsTrigger)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutIcallScript
//
//
// iCall script.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutIcallScript(id string, object SysIcallScript) (*SysIcallScript, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/script/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcallScript), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutIcallScript")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcallScript), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutIcallScript")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcallScript)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutIcontrolSoap
//
//
// iControl SOAP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutIcontrolSoap(id string, object SysIcontrolSoap) (*SysIcontrolSoap, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icontrolSoap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIcontrolSoap), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutIcontrolSoap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIcontrolSoap), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutIcontrolSoap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIcontrolSoap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutIpfixElement
//
//
// IPFIX element configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutIpfixElement(id string, object SysIpfixElement) (*SysIpfixElement, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/element/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysIpfixElement), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutIpfixElement")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysIpfixElement), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutIpfixElement")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysIpfixElement)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutLogConfigDestinationAlertd
//
//
// Forwards messages to the AlertD daemon.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigDestinationAlertd(id string, object SysLogConfigDestinationAlertd) (*SysLogConfigDestinationAlertd, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/alertd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationAlertd), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutLogConfigDestinationAlertd")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationAlertd), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutLogConfigDestinationAlertd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationAlertd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutLogConfigDestinationArcsight
//
//
// Format messages to the ArcSight specification.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigDestinationArcsight(id string, object SysLogConfigDestinationArcsight) (*SysLogConfigDestinationArcsight, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/arcsight/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationArcsight), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutLogConfigDestinationArcsight")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationArcsight), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutLogConfigDestinationArcsight")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationArcsight)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutLogConfigDestinationIpfix
//
//
// Formats logs into IPFIX messages and transmits them to a pool of IPFIX Collectors.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigDestinationIpfix(id string, object SysLogConfigDestinationIpfix) (*SysLogConfigDestinationIpfix, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/ipfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationIpfix), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutLogConfigDestinationIpfix")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationIpfix), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutLogConfigDestinationIpfix")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationIpfix)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutLogConfigDestinationLocalDatabase
//
//
// Forwards messages to the local database.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigDestinationLocalDatabase(id string, object SysLogConfigDestinationLocalDatabase) (*SysLogConfigDestinationLocalDatabase, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/localDatabase/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationLocalDatabase), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutLogConfigDestinationLocalDatabase")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationLocalDatabase), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutLogConfigDestinationLocalDatabase")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationLocalDatabase)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutLogConfigDestinationLocalSyslog
//
//
// Forwards messages to the local Syslog-ng process.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigDestinationLocalSyslog(id string, object SysLogConfigDestinationLocalSyslog) (*SysLogConfigDestinationLocalSyslog, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/localSyslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationLocalSyslog), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutLogConfigDestinationLocalSyslog")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationLocalSyslog), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutLogConfigDestinationLocalSyslog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationLocalSyslog)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutLogConfigDestinationManagementPort
//
//
// Forwards messages to a destination through the management port.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigDestinationManagementPort(id string, object SysLogConfigDestinationManagementPort) (*SysLogConfigDestinationManagementPort, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/managementPort/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationManagementPort), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutLogConfigDestinationManagementPort")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationManagementPort), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutLogConfigDestinationManagementPort")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationManagementPort)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutLogConfigDestinationRemoteHighSpeedLog
//
//
// Forwards messages to a pool.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigDestinationRemoteHighSpeedLog(id string, object SysLogConfigDestinationRemoteHighSpeedLog) (*SysLogConfigDestinationRemoteHighSpeedLog, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteHighSpeedLog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationRemoteHighSpeedLog), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutLogConfigDestinationRemoteHighSpeedLog")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationRemoteHighSpeedLog), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutLogConfigDestinationRemoteHighSpeedLog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationRemoteHighSpeedLog)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutLogConfigDestinationRemoteSyslog
//
//
// Format messages to the Syslog format for remote logging.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigDestinationRemoteSyslog(id string, object SysLogConfigDestinationRemoteSyslog) (*SysLogConfigDestinationRemoteSyslog, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteSyslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationRemoteSyslog), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutLogConfigDestinationRemoteSyslog")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationRemoteSyslog), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutLogConfigDestinationRemoteSyslog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationRemoteSyslog)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutLogConfigDestinationSplunk
//
//
// Format messages to the Splunk specification.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigDestinationSplunk(id string, object SysLogConfigDestinationSplunk) (*SysLogConfigDestinationSplunk, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/splunk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigDestinationSplunk), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutLogConfigDestinationSplunk")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigDestinationSplunk), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutLogConfigDestinationSplunk")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigDestinationSplunk)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutLogConfigFilter
//
//
// Selectively route logs to log publishers.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigFilter(id string, object SysLogConfigFilter) (*SysLogConfigFilter, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/filter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigFilter), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutLogConfigFilter")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigFilter), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutLogConfigFilter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigFilter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutLogConfigPublisher
//
//
// List of log destinations.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigPublisher(id string, object SysLogConfigPublisher) (*SysLogConfigPublisher, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/publisher/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogConfigPublisher), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutLogConfigPublisher")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogConfigPublisher), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutLogConfigPublisher")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogConfigPublisher)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutLogRotate
//
//
// Log rotation configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogRotate(id string, object SysLogRotate) (*SysLogRotate, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logRotate/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLogRotate), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutLogRotate")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLogRotate), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutLogRotate")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLogRotate)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutLtcfgClassFields
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLtcfgClassFields(id string, object SysLtcfgClassFields) (*SysLtcfgClassFields, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgClass/fields/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLtcfgClassFields), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutLtcfgClassFields")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLtcfgClassFields), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutLtcfgClassFields")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLtcfgClassFields)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutLtcfgInstanceFields
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLtcfgInstanceFields(id string, object SysLtcfgInstanceFields) (*SysLtcfgInstanceFields, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgInstance/fields/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysLtcfgInstanceFields), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutLtcfgInstanceFields")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysLtcfgInstanceFields), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutLtcfgInstanceFields")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysLtcfgInstanceFields)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutManagementDhcp
//
//
// DHCP configuration for the management interface.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutManagementDhcp(id string, object SysManagementDhcp) (*SysManagementDhcp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementDhcp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysManagementDhcp), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutManagementDhcp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysManagementDhcp), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutManagementDhcp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysManagementDhcp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutManagementIp
//
//
// Management port address configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutManagementIp(id string, object SysManagementIp) (*SysManagementIp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementIp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysManagementIp), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutManagementIp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysManagementIp), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutManagementIp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysManagementIp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutManagementOvsdb
//
//
// OVSDB configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutManagementOvsdb(id string, object SysManagementOvsdb) (*SysManagementOvsdb, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementOvsdb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysManagementOvsdb), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutManagementOvsdb")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysManagementOvsdb), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutManagementOvsdb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysManagementOvsdb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutManagementRoute
//
//
// Route configuration for the management interface.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutManagementRoute(id string, object SysManagementRoute) (*SysManagementRoute, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementRoute/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysManagementRoute), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutManagementRoute")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysManagementRoute), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutManagementRoute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysManagementRoute)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutNtp
//
//
// NTP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutNtp(id string, object SysNtp) (*SysNtp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ntp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysNtp), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutNtp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysNtp), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutNtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysNtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutNtpRestrict
//
//
// A restrict line in the NTP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutNtpRestrict(id string, object SysNtpRestrict) (*SysNtpRestrict, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ntp/restrict/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysNtpRestrict), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutNtpRestrict")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysNtpRestrict), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutNtpRestrict")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysNtpRestrict)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutOutboundSmtp
//
//
// Configuration for outbound email sent by the TMOS system.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutOutboundSmtp(id string, object SysOutboundSmtp) (*SysOutboundSmtp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/outboundSmtp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysOutboundSmtp), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutOutboundSmtp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysOutboundSmtp), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutOutboundSmtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysOutboundSmtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProvision
//
//
// Module resource configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutProvision(id string, object SysProvision) (*SysProvision, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/provision/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysProvision), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutProvision")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysProvision), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutProvision")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysProvision)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutRaidArray
//
//
// Manage the disk array.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutRaidArray(id string, object SysRaidArray) (*SysRaidArray, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/array/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysRaidArray), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutRaidArray")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysRaidArray), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutRaidArray")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysRaidArray)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutRaidBay
//
//
// Manage drive bays.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutRaidBay(id string, object SysRaidBay) (*SysRaidBay, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/bay/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysRaidBay), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutRaidBay")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysRaidBay), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutRaidBay")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysRaidBay)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutScriptd
//
//
// scriptd daemon configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutScriptd(id string, object SysScriptd) (*SysScriptd, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/scriptd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysScriptd), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutScriptd")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysScriptd), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutScriptd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysScriptd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutService
//
//
// Controls the BIG-IP system services..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutService(id string, object SysService) (*SysService, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/service/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysService), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutService")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysService), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutService")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysService)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutSflowGlobalSettingsHttp
//
//
// Global HTTP sFlow configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSflowGlobalSettingsHttp(id string, object SysSflowGlobalSettingsHttp) (*SysSflowGlobalSettingsHttp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/http/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowGlobalSettingsHttp), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutSflowGlobalSettingsHttp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSflowGlobalSettingsHttp), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutSflowGlobalSettingsHttp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSflowGlobalSettingsHttp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutSflowGlobalSettingsSystem
//
//
// Global system sFlow configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSflowGlobalSettingsSystem(id string, object SysSflowGlobalSettingsSystem) (*SysSflowGlobalSettingsSystem, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/system/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowGlobalSettingsSystem), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutSflowGlobalSettingsSystem")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSflowGlobalSettingsSystem), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutSflowGlobalSettingsSystem")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSflowGlobalSettingsSystem)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutSflowGlobalSettingsTmInterface
//
//
// Global sFlow configuration for interfaces.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSflowGlobalSettingsTmInterface(id string, object SysSflowGlobalSettingsTmInterface) (*SysSflowGlobalSettingsTmInterface, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/tmInterface/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowGlobalSettingsTmInterface), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutSflowGlobalSettingsTmInterface")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSflowGlobalSettingsTmInterface), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutSflowGlobalSettingsTmInterface")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSflowGlobalSettingsTmInterface)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutSflowGlobalSettingsVlan
//
//
// Global sFlow configuration for VLANs.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSflowGlobalSettingsVlan(id string, object SysSflowGlobalSettingsVlan) (*SysSflowGlobalSettingsVlan, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/vlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowGlobalSettingsVlan), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutSflowGlobalSettingsVlan")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSflowGlobalSettingsVlan), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutSflowGlobalSettingsVlan")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSflowGlobalSettingsVlan)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutSflowReceiver
//
//
// sFlow receiver configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSflowReceiver(id string, object SysSflowReceiver) (*SysSflowReceiver, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/receiver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSflowReceiver), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutSflowReceiver")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSflowReceiver), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutSflowReceiver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSflowReceiver)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutSmtpServer
//
//
// SMTP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSmtpServer(id string, object SysSmtpServer) (*SysSmtpServer, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/smtpServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSmtpServer), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutSmtpServer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSmtpServer), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutSmtpServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSmtpServer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutSnmp
//
//
// SNMP agent config.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSnmp(id string, object SysSnmp) (*SysSnmp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSnmp), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutSnmp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSnmp), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutSnmp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSnmp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutSnmpCommunities
//
//
// Specifies SNMP community strings and limits them to specific oid subsets..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSnmpCommunities(id string, object SysSnmpCommunities) (*SysSnmpCommunities, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/communities/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSnmpCommunities), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutSnmpCommunities")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSnmpCommunities), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutSnmpCommunities")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSnmpCommunities)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutSnmpTraps
//
//
// Generic interface for configuring SNMP traps..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSnmpTraps(id string, object SysSnmpTraps) (*SysSnmpTraps, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/traps/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSnmpTraps), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutSnmpTraps")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSnmpTraps), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutSnmpTraps")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSnmpTraps)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutSnmpUsers
//
//
// Specifies user account information for use with SNMPv3..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSnmpUsers(id string, object SysSnmpUsers) (*SysSnmpUsers, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/users/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSnmpUsers), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutSnmpUsers")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSnmpUsers), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutSnmpUsers")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSnmpUsers)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutSoftwareUpdate
//
//
// Manage software update checking.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSoftwareUpdate(id string, object SysSoftwareUpdate) (*SysSoftwareUpdate, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/update/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSoftwareUpdate), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutSoftwareUpdate")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSoftwareUpdate), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutSoftwareUpdate")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSoftwareUpdate)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutSshd
//
//
// SSHD configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSshd(id string, object SysSshd) (*SysSshd, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sshd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSshd), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutSshd")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSshd), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutSshd")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSshd)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutStateMirroring
//
//
// Redundant system connection mirroring configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutStateMirroring(id string, object SysStateMirroring) (*SysStateMirroring, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/stateMirroring/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysStateMirroring), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutStateMirroring")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysStateMirroring), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutStateMirroring")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysStateMirroring)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutSyslog
//
//
// System logging configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSyslog(id string, object SysSyslog) (*SysSyslog, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/syslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysSyslog), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutSyslog")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysSyslog), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutSyslog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysSyslog)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutUrlDbDownloadSchedule
//
//
// URL Database Download Schedule.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutUrlDbDownloadSchedule(id string, object SysUrlDbDownloadSchedule) (*SysUrlDbDownloadSchedule, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/downloadSchedule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysUrlDbDownloadSchedule), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutUrlDbDownloadSchedule")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysUrlDbDownloadSchedule), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutUrlDbDownloadSchedule")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysUrlDbDownloadSchedule)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutUrlDbUrlCategory
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutUrlDbUrlCategory(id string, object SysUrlDbUrlCategory) (*SysUrlDbUrlCategory, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/urlCategory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(SysUrlDbUrlCategory), nil, errors.New("Missing required parameter 'id' when calling SysApi->PutUrlDbUrlCategory")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(SysUrlDbUrlCategory), nil, errors.New("Missing required parameter 'object' when calling SysApi->PutUrlDbUrlCategory")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(SysUrlDbUrlCategory)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}
