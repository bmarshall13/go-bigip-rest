/*
 * BigIP iControl REST
 *
 * REST API for F5 BigIP. List of operations is not complete, nor known to be accurate.
 *
 * OpenAPI spec version: 12.0
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package f5api

import (
	"fmt"
	"net/url"
	"strings"

	"encoding/json"
)

// This class holds all the API methods for the Sys API sub tree
type SysApi struct {
	configuration *configuration
}

func unused_import_hack_SysApi() {
	strings.Replace("a", "a", fmt.Sprintf("%v", nil), -1)
}

// DeleteApplicationAplScript
//
//
// Scripts included by an application template.
//
// id is for ID of the resource.
func (a SysApi) DeleteApplicationAplScript(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/aplScript/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteApplicationCustomStat
//
//
// Derived iStats.
//
// id is for ID of the resource.
func (a SysApi) DeleteApplicationCustomStat(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/customStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteApplicationService
//
//
// Application configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteApplicationService(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/service/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteApplicationTemplate
//
//
// Application templates.
//
// id is for ID of the resource.
func (a SysApi) DeleteApplicationTemplate(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/template/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteConfig
//
//
// Save and load system configuration files.
//
// id is for ID of the resource.
func (a SysApi) DeleteConfig(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/config/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteConnection
//
//
// Displays or deletes active connections on the BIG-IP system.
//
// id is for ID of the resource.
func (a SysApi) DeleteConnection(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/connection/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteCryptoCert
//
//
// Certificate configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteCryptoCert(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/cert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteCryptoClient
//
//
// Crypto client configuration..
//
// id is for ID of the resource.
func (a SysApi) DeleteCryptoClient(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/client/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteCryptoCrl
//
//
// Certificate revocation list configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteCryptoCrl(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/crl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteCryptoCsr
//
//
// Certificate Signing Request configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteCryptoCsr(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/csr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteCryptoFipsByHandle
//
//
// Manipulate FIPS key by its handle..
//
// id is for ID of the resource.
func (a SysApi) DeleteCryptoFipsByHandle(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/byHandle/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteCryptoFipsExternalHsm
//
//
// FIPS external hsm specific configuration..
//
// id is for ID of the resource.
func (a SysApi) DeleteCryptoFipsExternalHsm(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/externalHsm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteCryptoKey
//
//
// Key configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteCryptoKey(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/key/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteCryptoServer
//
//
// Crypto server configuration..
//
// id is for ID of the resource.
func (a SysApi) DeleteCryptoServer(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/server/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteDiskApplicationVolume
//
//
// Application Volume Configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteDiskApplicationVolume(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/applicationVolume/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteEcmCloudProvider
//
//
// Describes the properties of all the cloud-providers.
//
// id is for ID of the resource.
func (a SysApi) DeleteEcmCloudProvider(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/cloudProvider/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteFileApacheSslCert
//
//
// SSL certificates management.
//
// id is for ID of the resource.
func (a SysApi) DeleteFileApacheSslCert(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/apacheSslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteFileDashboardViewset
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) DeleteFileDashboardViewset(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dashboardViewset/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteFileDataGroup
//
//
// External Data Group files management.
//
// id is for ID of the resource.
func (a SysApi) DeleteFileDataGroup(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dataGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteFileDeviceCapabilitiesDb
//
//
// Device capabilities DB file management.
//
// id is for ID of the resource.
func (a SysApi) DeleteFileDeviceCapabilitiesDb(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/deviceCapabilitiesDb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteFileExternalMonitor
//
//
// External Monitor files management.
//
// id is for ID of the resource.
func (a SysApi) DeleteFileExternalMonitor(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/externalMonitor/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteFileIfile
//
//
// iFile files management.
//
// id is for ID of the resource.
func (a SysApi) DeleteFileIfile(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/ifile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteFileSslCert
//
//
// SSL certificates management.
//
// id is for ID of the resource.
func (a SysApi) DeleteFileSslCert(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteFileSslCrl
//
//
// SSL CRL files management.
//
// id is for ID of the resource.
func (a SysApi) DeleteFileSslCrl(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCrl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteFileSslCsr
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) DeleteFileSslCsr(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCsr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteFileSslKey
//
//
// SSL certificate keys management.
//
// id is for ID of the resource.
func (a SysApi) DeleteFileSslKey(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteFixConnection
//
//
// FIX connection level stats.
//
// id is for ID of the resource.
func (a SysApi) DeleteFixConnection(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fixConnection/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteFolder
//
//
// Folder configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteFolder(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/folder/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteHaGroup
//
//
// Specifies the ha group used to calculate the failover score..
//
// id is for ID of the resource.
func (a SysApi) DeleteHaGroup(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteIcallHandlerPeriodic
//
//
// iCall periodic handler.
//
// id is for ID of the resource.
func (a SysApi) DeleteIcallHandlerPeriodic(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/periodic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteIcallHandlerPerpetual
//
//
// iCall perpetual handler.
//
// id is for ID of the resource.
func (a SysApi) DeleteIcallHandlerPerpetual(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteIcallHandlerPerpetualSubscriptions
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) DeleteIcallHandlerPerpetualSubscriptions(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/subscriptions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteIcallHandlerTriggered
//
//
// iCall event-triggered event handler.
//
// id is for ID of the resource.
func (a SysApi) DeleteIcallHandlerTriggered(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteIcallHandlerTriggeredSubscriptions
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) DeleteIcallHandlerTriggeredSubscriptions(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/subscriptions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteIcallIstatsTrigger
//
//
// Event trigger for iStats.
//
// id is for ID of the resource.
func (a SysApi) DeleteIcallIstatsTrigger(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/istatsTrigger/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteIcallScript
//
//
// iCall script.
//
// id is for ID of the resource.
func (a SysApi) DeleteIcallScript(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/script/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteIpfixElement
//
//
// IPFIX element configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteIpfixElement(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/element/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteLogConfigDestinationArcsight
//
//
// Format messages to the ArcSight specification.
//
// id is for ID of the resource.
func (a SysApi) DeleteLogConfigDestinationArcsight(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/arcsight/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteLogConfigDestinationIpfix
//
//
// Formats logs into IPFIX messages and transmits them to a pool of IPFIX Collectors.
//
// id is for ID of the resource.
func (a SysApi) DeleteLogConfigDestinationIpfix(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/ipfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteLogConfigDestinationManagementPort
//
//
// Forwards messages to a destination through the management port.
//
// id is for ID of the resource.
func (a SysApi) DeleteLogConfigDestinationManagementPort(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/managementPort/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteLogConfigDestinationRemoteHighSpeedLog
//
//
// Forwards messages to a pool.
//
// id is for ID of the resource.
func (a SysApi) DeleteLogConfigDestinationRemoteHighSpeedLog(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteHighSpeedLog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteLogConfigDestinationRemoteSyslog
//
//
// Format messages to the Syslog format for remote logging.
//
// id is for ID of the resource.
func (a SysApi) DeleteLogConfigDestinationRemoteSyslog(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteSyslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteLogConfigDestinationSplunk
//
//
// Format messages to the Splunk specification.
//
// id is for ID of the resource.
func (a SysApi) DeleteLogConfigDestinationSplunk(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/splunk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteLogConfigFilter
//
//
// Selectively route logs to log publishers.
//
// id is for ID of the resource.
func (a SysApi) DeleteLogConfigFilter(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/filter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteLogConfigPublisher
//
//
// List of log destinations.
//
// id is for ID of the resource.
func (a SysApi) DeleteLogConfigPublisher(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/publisher/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteLtcfgClassFields
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) DeleteLtcfgClassFields(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgClass/fields/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteLtcfgInstanceFields
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) DeleteLtcfgInstanceFields(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgInstance/fields/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteManagementIp
//
//
// Management port address configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteManagementIp(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementIp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteManagementRoute
//
//
// Route configuration for the management interface.
//
// id is for ID of the resource.
func (a SysApi) DeleteManagementRoute(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementRoute/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteNtpRestrict
//
//
// A restrict line in the NTP configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteNtpRestrict(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ntp/restrict/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeletePptpCallInfo
//
//
// Displays or deletes active pptp-calls on the BIG-IP system.
//
// id is for ID of the resource.
func (a SysApi) DeletePptpCallInfo(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/pptpCallInfo/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteSflowReceiver
//
//
// sFlow receiver configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteSflowReceiver(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/receiver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteSmtpServer
//
//
// SMTP configuration.
//
// id is for ID of the resource.
func (a SysApi) DeleteSmtpServer(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/smtpServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteSnmpCommunities
//
//
// Specifies SNMP community strings and limits them to specific oid subsets..
//
// id is for ID of the resource.
func (a SysApi) DeleteSnmpCommunities(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/communities/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteSnmpTraps
//
//
// Generic interface for configuring SNMP traps..
//
// id is for ID of the resource.
func (a SysApi) DeleteSnmpTraps(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/traps/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteSnmpUsers
//
//
// Specifies user account information for use with SNMPv3..
//
// id is for ID of the resource.
func (a SysApi) DeleteSnmpUsers(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/users/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteSoftwareHotfix
//
//
// Manage hotfix images.
//
// id is for ID of the resource.
func (a SysApi) DeleteSoftwareHotfix(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/hotfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteSoftwareImage
//
//
// Manage software images.
//
// id is for ID of the resource.
func (a SysApi) DeleteSoftwareImage(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/image/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteSoftwareSignature
//
//
// Manage software signatures.
//
// id is for ID of the resource.
func (a SysApi) DeleteSoftwareSignature(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/signature/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteSoftwareVolume
//
//
// Manage software volumes, or reboot to a specific volume.
//
// id is for ID of the resource.
func (a SysApi) DeleteSoftwareVolume(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/volume/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteUcs
//
//
// Save and restore configuration from UCS files.
//
// id is for ID of the resource.
func (a SysApi) DeleteUcs(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ucs/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// DeleteUrlDbUrlCategory
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) DeleteUrlDbUrlCategory(id string) error {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/urlCategory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)

	return NewAPIResponse(httpResponse, err)

}

// GetApplication
//
//
// Configure an application.
//
// id is for ID of the resource.
func (a SysApi) GetApplication(id string) (*SysApplication, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplication)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetApplicationAplScript
//
//
// Scripts included by an application template.
//
// id is for ID of the resource.
func (a SysApi) GetApplicationAplScript(id string) (*SysApplicationAplScript, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/aplScript/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationAplScript)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetApplicationAplScriptList
//
//
// Scripts included by an application template..
func (a SysApi) GetApplicationAplScriptList() (*SysApplicationAplScriptList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/aplScript"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationAplScriptList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetApplicationCustomStat
//
//
// Derived iStats.
//
// id is for ID of the resource.
func (a SysApi) GetApplicationCustomStat(id string) (*SysApplicationCustomStat, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/customStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationCustomStat)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetApplicationCustomStatList
//
//
// Derived iStats..
func (a SysApi) GetApplicationCustomStatList() (*SysApplicationCustomStatList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/customStat"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationCustomStatList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetApplicationList
//
//
// Configure an application..
func (a SysApi) GetApplicationList() (*SysApplicationList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetApplicationService
//
//
// Application configuration.
//
// id is for ID of the resource.
func (a SysApi) GetApplicationService(id string) (*SysApplicationService, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/service/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationService)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetApplicationServiceList
//
//
// Application configuration..
func (a SysApi) GetApplicationServiceList() (*SysApplicationServiceList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/service"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationServiceList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetApplicationTemplate
//
//
// Application templates.
//
// id is for ID of the resource.
func (a SysApi) GetApplicationTemplate(id string) (*SysApplicationTemplate, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/template/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationTemplate)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetApplicationTemplateActions
//
//
// Manage the set of actions associated with an application template..
//
// id is for ID of the resource.
func (a SysApi) GetApplicationTemplateActions(id string) (*SysApplicationTemplateActions, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/template/actions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationTemplateActions)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetApplicationTemplateActionsList
//
//
// Manage the set of actions associated with an application template...
func (a SysApi) GetApplicationTemplateActionsList() (*SysApplicationTemplateActionsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/template/actions"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationTemplateActionsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetApplicationTemplateList
//
//
// Application templates..
func (a SysApi) GetApplicationTemplateList() (*SysApplicationTemplateList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/template"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationTemplateList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetAutoscaleGroup
//
//
// Autoscale group information for Amazon Web Services(AWS)..
//
// id is for ID of the resource.
func (a SysApi) GetAutoscaleGroup(id string) (*SysAutoscaleGroup, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/autoscaleGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysAutoscaleGroup)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetAutoscaleGroupList
//
//
// Autoscale group information for Amazon Web Services(AWS)...
func (a SysApi) GetAutoscaleGroupList() (*SysAutoscaleGroupList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/autoscaleGroup"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysAutoscaleGroupList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetClassificationSignatureList
//
//
// ..
func (a SysApi) GetClassificationSignatureList() (*SysClassificationSignatureList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/classificationSignature"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysClassificationSignatureList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetClock
//
//
// Display the current date and time.
//
// id is for ID of the resource.
func (a SysApi) GetClock(id string) (*SysClock, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/clock/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysClock)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetClockList
//
//
// Display the current date and time..
func (a SysApi) GetClockList() (*SysClockList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/clock"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysClockList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCluster
//
//
// Cluster configuration.
//
// id is for ID of the resource.
func (a SysApi) GetCluster(id string) (*SysCluster, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/cluster/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCluster)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetClusterList
//
//
// Cluster configuration..
func (a SysApi) GetClusterList() (*SysClusterList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/cluster"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysClusterList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetConfig
//
//
// Save and load system configuration files.
//
// id is for ID of the resource.
func (a SysApi) GetConfig(id string) (*SysConfig, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/config/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysConfig)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetConfigDiff
//
//
// View the difference between two SCF files, or a file to running configuration.
//
// id is for ID of the resource.
func (a SysApi) GetConfigDiff(id string) (*SysConfigDiff, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/configDiff/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysConfigDiff)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetConfigDiffList
//
//
// View the difference between two SCF files, or a file to running configuration..
func (a SysApi) GetConfigDiffList() (*SysConfigDiffList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/configDiff"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysConfigDiffList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetConfigList
//
//
// Save and load system configuration files..
func (a SysApi) GetConfigList() (*SysConfigList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/config"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysConfigList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetConnection
//
//
// Displays or deletes active connections on the BIG-IP system.
//
// id is for ID of the resource.
func (a SysApi) GetConnection(id string) (*SysConnection, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/connection/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysConnection)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetConnectionList
//
//
// Displays or deletes active connections on the BIG-IP system..
func (a SysApi) GetConnectionList() (*SysConnectionList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/connection"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysConnectionList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetConsole
//
//
// Configure the serial console.
//
// id is for ID of the resource.
func (a SysApi) GetConsole(id string) (*SysConsole, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/console/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysConsole)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetConsoleList
//
//
// Configure the serial console..
func (a SysApi) GetConsoleList() (*SysConsoleList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/console"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysConsoleList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCpu
//
//
// CPU statistics of system overall performance and on management hosts..
//
// id is for ID of the resource.
func (a SysApi) GetCpu(id string) (*SysCpu, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/cpu/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCpu)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCpuList
//
//
// CPU statistics of system overall performance and on management hosts...
func (a SysApi) GetCpuList() (*SysCpuList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/cpu"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCpuList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCrypto
//
//
// Manage cryptographic objects such as keys and certificates..
//
// id is for ID of the resource.
func (a SysApi) GetCrypto(id string) (*SysCrypto, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCrypto)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoCert
//
//
// Certificate configuration.
//
// id is for ID of the resource.
func (a SysApi) GetCryptoCert(id string) (*SysCryptoCert, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/cert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoCert)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoCertList
//
//
// Certificate configuration..
func (a SysApi) GetCryptoCertList() (*SysCryptoCertList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/cert"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoCertList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoCheckCertList
//
//
// Certificate expiration check utility..
func (a SysApi) GetCryptoCheckCertList() (*SysCryptoCheckCertList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/checkCert"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoCheckCertList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoClient
//
//
// Crypto client configuration..
//
// id is for ID of the resource.
func (a SysApi) GetCryptoClient(id string) (*SysCryptoClient, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/client/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoClient)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoClientList
//
//
// Crypto client configuration...
func (a SysApi) GetCryptoClientList() (*SysCryptoClientList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/client"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoClientList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoCrl
//
//
// Certificate revocation list configuration.
//
// id is for ID of the resource.
func (a SysApi) GetCryptoCrl(id string) (*SysCryptoCrl, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/crl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoCrl)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoCrlList
//
//
// Certificate revocation list configuration..
func (a SysApi) GetCryptoCrlList() (*SysCryptoCrlList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/crl"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoCrlList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoCsr
//
//
// Certificate Signing Request configuration.
//
// id is for ID of the resource.
func (a SysApi) GetCryptoCsr(id string) (*SysCryptoCsr, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/csr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoCsr)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoCsrList
//
//
// Certificate Signing Request configuration..
func (a SysApi) GetCryptoCsrList() (*SysCryptoCsrList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/csr"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoCsrList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoFips
//
//
// FIPS specific configuration..
//
// id is for ID of the resource.
func (a SysApi) GetCryptoFips(id string) (*SysCryptoFips, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoFips)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoFipsByHandleList
//
//
// Manipulate FIPS key by its handle...
func (a SysApi) GetCryptoFipsByHandleList() (*SysCryptoFipsByHandleList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/byHandle"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoFipsByHandleList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoFipsExternalHsm
//
//
// FIPS external hsm specific configuration..
//
// id is for ID of the resource.
func (a SysApi) GetCryptoFipsExternalHsm(id string) (*SysCryptoFipsExternalHsm, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/externalHsm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoFipsExternalHsm)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoFipsExternalHsmList
//
//
// FIPS external hsm specific configuration...
func (a SysApi) GetCryptoFipsExternalHsmList() (*SysCryptoFipsExternalHsmList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/externalHsm"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoFipsExternalHsmList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoFipsKey
//
//
// FIPS key specific configuration..
//
// id is for ID of the resource.
func (a SysApi) GetCryptoFipsKey(id string) (*SysCryptoFipsKey, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/key/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoFipsKey)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoFipsKeyList
//
//
// FIPS key specific configuration...
func (a SysApi) GetCryptoFipsKeyList() (*SysCryptoFipsKeyList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/key"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoFipsKeyList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoFipsList
//
//
// FIPS specific configuration...
func (a SysApi) GetCryptoFipsList() (*SysCryptoFipsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoFipsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoKey
//
//
// Key configuration.
//
// id is for ID of the resource.
func (a SysApi) GetCryptoKey(id string) (*SysCryptoKey, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/key/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoKey)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoKeyList
//
//
// Key configuration..
func (a SysApi) GetCryptoKeyList() (*SysCryptoKeyList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/key"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoKeyList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoList
//
//
// Manage cryptographic objects such as keys and certificates...
func (a SysApi) GetCryptoList() (*SysCryptoList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoMasterKey
//
//
// Displays internal encryption key information on a system..
//
// id is for ID of the resource.
func (a SysApi) GetCryptoMasterKey(id string) (*SysCryptoMasterKey, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/masterKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoMasterKey)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoMasterKeyList
//
//
// Displays internal encryption key information on a system...
func (a SysApi) GetCryptoMasterKeyList() (*SysCryptoMasterKeyList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/masterKey"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoMasterKeyList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoPkcs12List
//
//
// PKCS12 configuration..
func (a SysApi) GetCryptoPkcs12List() (*SysCryptoPkcs12List, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/pkcs12"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoPkcs12List)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoServer
//
//
// Crypto server configuration..
//
// id is for ID of the resource.
func (a SysApi) GetCryptoServer(id string) (*SysCryptoServer, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/server/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoServer)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetCryptoServerList
//
//
// Crypto server configuration...
func (a SysApi) GetCryptoServerList() (*SysCryptoServerList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/server"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoServerList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDaemonHa
//
//
// System daemon HA configuration.
//
// id is for ID of the resource.
func (a SysApi) GetDaemonHa(id string) (*SysDaemonHa, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonHa/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonHa)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDaemonHaList
//
//
// System daemon HA configuration..
func (a SysApi) GetDaemonHaList() (*SysDaemonHaList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonHa"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonHaList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDaemonLogSettings
//
//
// Daemon log configuration.
//
// id is for ID of the resource.
func (a SysApi) GetDaemonLogSettings(id string) (*SysDaemonLogSettings, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettings)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDaemonLogSettingsClusterd
//
//
// The clusterd daemon configuration on the system..
//
// id is for ID of the resource.
func (a SysApi) GetDaemonLogSettingsClusterd(id string) (*SysDaemonLogSettingsClusterd, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/clusterd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsClusterd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDaemonLogSettingsClusterdList
//
//
// The clusterd daemon configuration on the system...
func (a SysApi) GetDaemonLogSettingsClusterdList() (*SysDaemonLogSettingsClusterdList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/clusterd"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsClusterdList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDaemonLogSettingsCsyncd
//
//
// The csyncd daemon configuration on the system..
//
// id is for ID of the resource.
func (a SysApi) GetDaemonLogSettingsCsyncd(id string) (*SysDaemonLogSettingsCsyncd, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/csyncd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsCsyncd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDaemonLogSettingsCsyncdList
//
//
// The csyncd daemon configuration on the system...
func (a SysApi) GetDaemonLogSettingsCsyncdList() (*SysDaemonLogSettingsCsyncdList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/csyncd"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsCsyncdList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDaemonLogSettingsIcrd
//
//
// The icrd daemon configuration on the system..
//
// id is for ID of the resource.
func (a SysApi) GetDaemonLogSettingsIcrd(id string) (*SysDaemonLogSettingsIcrd, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/icrd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsIcrd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDaemonLogSettingsIcrdList
//
//
// The icrd daemon configuration on the system...
func (a SysApi) GetDaemonLogSettingsIcrdList() (*SysDaemonLogSettingsIcrdList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/icrd"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsIcrdList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDaemonLogSettingsLind
//
//
// The lind daemon configuration on the system..
//
// id is for ID of the resource.
func (a SysApi) GetDaemonLogSettingsLind(id string) (*SysDaemonLogSettingsLind, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/lind/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsLind)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDaemonLogSettingsLindList
//
//
// The lind daemon configuration on the system...
func (a SysApi) GetDaemonLogSettingsLindList() (*SysDaemonLogSettingsLindList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/lind"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsLindList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDaemonLogSettingsList
//
//
// Daemon log configuration..
func (a SysApi) GetDaemonLogSettingsList() (*SysDaemonLogSettingsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDaemonLogSettingsMcpd
//
//
// The mcpd daemon configuration on the system..
//
// id is for ID of the resource.
func (a SysApi) GetDaemonLogSettingsMcpd(id string) (*SysDaemonLogSettingsMcpd, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/mcpd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsMcpd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDaemonLogSettingsMcpdList
//
//
// The mcpd daemon configuration on the system...
func (a SysApi) GetDaemonLogSettingsMcpdList() (*SysDaemonLogSettingsMcpdList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/mcpd"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsMcpdList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDaemonLogSettingsTmm
//
//
// The tmm daemon configuration on the system..
//
// id is for ID of the resource.
func (a SysApi) GetDaemonLogSettingsTmm(id string) (*SysDaemonLogSettingsTmm, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/tmm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsTmm)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDaemonLogSettingsTmmList
//
//
// The tmm daemon configuration on the system...
func (a SysApi) GetDaemonLogSettingsTmmList() (*SysDaemonLogSettingsTmmList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/tmm"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsTmmList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDatastor
//
//
// Optimization data storage configuration.
//
// id is for ID of the resource.
func (a SysApi) GetDatastor(id string) (*SysDatastor, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/datastor/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDatastor)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDatastorList
//
//
// Optimization data storage configuration..
func (a SysApi) GetDatastorList() (*SysDatastorList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/datastor"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDatastorList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDb
//
//
// General system properties.
//
// id is for ID of the resource.
func (a SysApi) GetDb(id string) (*SysDb, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/db/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDb)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDbList
//
//
// General system properties..
func (a SysApi) GetDbList() (*SysDbList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/db"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDbList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDisk
//
//
// Manage disk configuration and utilization.
//
// id is for ID of the resource.
func (a SysApi) GetDisk(id string) (*SysDisk, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDisk)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDiskApplicationVolume
//
//
// Application Volume Configuration.
//
// id is for ID of the resource.
func (a SysApi) GetDiskApplicationVolume(id string) (*SysDiskApplicationVolume, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/applicationVolume/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDiskApplicationVolume)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDiskApplicationVolumeList
//
//
// Application Volume Configuration..
func (a SysApi) GetDiskApplicationVolumeList() (*SysDiskApplicationVolumeList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/applicationVolume"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDiskApplicationVolumeList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDiskDirectory
//
//
// System directory resize operations..
//
// id is for ID of the resource.
func (a SysApi) GetDiskDirectory(id string) (*SysDiskDirectory, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/directory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDiskDirectory)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDiskDirectoryList
//
//
// System directory resize operations...
func (a SysApi) GetDiskDirectoryList() (*SysDiskDirectoryList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/directory"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDiskDirectoryList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDiskList
//
//
// Manage disk configuration and utilization..
func (a SysApi) GetDiskList() (*SysDiskList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDiskList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDiskLogicalDisk
//
//
// Logical Disk Configuration.
//
// id is for ID of the resource.
func (a SysApi) GetDiskLogicalDisk(id string) (*SysDiskLogicalDisk, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/logicalDisk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDiskLogicalDisk)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDiskLogicalDiskList
//
//
// Logical Disk Configuration..
func (a SysApi) GetDiskLogicalDiskList() (*SysDiskLogicalDiskList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/logicalDisk"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDiskLogicalDiskList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDns
//
//
// DNS configuration.
//
// id is for ID of the resource.
func (a SysApi) GetDns(id string) (*SysDns, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/dns/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDns)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetDnsList
//
//
// DNS configuration..
func (a SysApi) GetDnsList() (*SysDnsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/dns"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDnsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetEcm
//
//
// Configures the Elastic Compute Manager(ECM).
//
// id is for ID of the resource.
func (a SysApi) GetEcm(id string) (*SysEcm, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysEcm)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetEcmCloudProvider
//
//
// Describes the properties of all the cloud-providers.
//
// id is for ID of the resource.
func (a SysApi) GetEcmCloudProvider(id string) (*SysEcmCloudProvider, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/cloudProvider/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysEcmCloudProvider)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetEcmCloudProviderList
//
//
// Describes the properties of all the cloud-providers..
func (a SysApi) GetEcmCloudProviderList() (*SysEcmCloudProviderList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/cloudProvider"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysEcmCloudProviderList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetEcmConfig
//
//
// Specifies the ecm configuration.
//
// id is for ID of the resource.
func (a SysApi) GetEcmConfig(id string) (*SysEcmConfig, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/config/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysEcmConfig)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetEcmConfigList
//
//
// Specifies the ecm configuration..
func (a SysApi) GetEcmConfigList() (*SysEcmConfigList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/config"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysEcmConfigList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetEcmList
//
//
// Configures the Elastic Compute Manager(ECM)..
func (a SysApi) GetEcmList() (*SysEcmList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysEcmList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFailover
//
//
// Redundant system failover state.
//
// id is for ID of the resource.
func (a SysApi) GetFailover(id string) (*SysFailover, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/failover/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFailover)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFailoverList
//
//
// Redundant system failover state..
func (a SysApi) GetFailoverList() (*SysFailoverList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/failover"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFailoverList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFeatureModule
//
//
// Feature module configuration.
//
// id is for ID of the resource.
func (a SysApi) GetFeatureModule(id string) (*SysFeatureModule, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/featureModule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFeatureModule)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFeatureModuleList
//
//
// Feature module configuration..
func (a SysApi) GetFeatureModuleList() (*SysFeatureModuleList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/featureModule"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFeatureModuleList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFile
//
//
// System files management.
//
// id is for ID of the resource.
func (a SysApi) GetFile(id string) (*SysFile, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFile)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileApacheSslCert
//
//
// SSL certificates management.
//
// id is for ID of the resource.
func (a SysApi) GetFileApacheSslCert(id string) (*SysFileApacheSslCert, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/apacheSslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileApacheSslCert)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileApacheSslCertBundleCertificates
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetFileApacheSslCertBundleCertificates(id string) (*SysFileApacheSslCertBundleCertificates, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/apacheSslCert/bundleCertificates/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileApacheSslCertBundleCertificates)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileApacheSslCertBundleCertificatesList
//
//
// ..
func (a SysApi) GetFileApacheSslCertBundleCertificatesList() (*SysFileApacheSslCertBundleCertificatesList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/apacheSslCert/bundleCertificates"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileApacheSslCertBundleCertificatesList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileApacheSslCertList
//
//
// SSL certificates management..
func (a SysApi) GetFileApacheSslCertList() (*SysFileApacheSslCertList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/apacheSslCert"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileApacheSslCertList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileDashboardViewset
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetFileDashboardViewset(id string) (*SysFileDashboardViewset, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dashboardViewset/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileDashboardViewset)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileDashboardViewsetList
//
//
// ..
func (a SysApi) GetFileDashboardViewsetList() (*SysFileDashboardViewsetList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dashboardViewset"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileDashboardViewsetList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileDataGroup
//
//
// External Data Group files management.
//
// id is for ID of the resource.
func (a SysApi) GetFileDataGroup(id string) (*SysFileDataGroup, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dataGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileDataGroup)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileDataGroupList
//
//
// External Data Group files management..
func (a SysApi) GetFileDataGroupList() (*SysFileDataGroupList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dataGroup"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileDataGroupList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileDeviceCapabilitiesDb
//
//
// Device capabilities DB file management.
//
// id is for ID of the resource.
func (a SysApi) GetFileDeviceCapabilitiesDb(id string) (*SysFileDeviceCapabilitiesDb, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/deviceCapabilitiesDb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileDeviceCapabilitiesDb)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileDeviceCapabilitiesDbList
//
//
// Device capabilities DB file management..
func (a SysApi) GetFileDeviceCapabilitiesDbList() (*SysFileDeviceCapabilitiesDbList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/deviceCapabilitiesDb"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileDeviceCapabilitiesDbList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileExternalMonitor
//
//
// External Monitor files management.
//
// id is for ID of the resource.
func (a SysApi) GetFileExternalMonitor(id string) (*SysFileExternalMonitor, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/externalMonitor/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileExternalMonitor)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileExternalMonitorList
//
//
// External Monitor files management..
func (a SysApi) GetFileExternalMonitorList() (*SysFileExternalMonitorList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/externalMonitor"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileExternalMonitorList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileIfile
//
//
// iFile files management.
//
// id is for ID of the resource.
func (a SysApi) GetFileIfile(id string) (*SysFileIfile, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/ifile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileIfile)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileIfileList
//
//
// iFile files management..
func (a SysApi) GetFileIfileList() (*SysFileIfileList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/ifile"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileIfileList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileList
//
//
// System files management..
func (a SysApi) GetFileList() (*SysFileList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileSslCert
//
//
// SSL certificates management.
//
// id is for ID of the resource.
func (a SysApi) GetFileSslCert(id string) (*SysFileSslCert, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslCert)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileSslCertBundleCertificates
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetFileSslCertBundleCertificates(id string) (*SysFileSslCertBundleCertificates, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCert/bundleCertificates/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslCertBundleCertificates)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileSslCertBundleCertificatesList
//
//
// ..
func (a SysApi) GetFileSslCertBundleCertificatesList() (*SysFileSslCertBundleCertificatesList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCert/bundleCertificates"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslCertBundleCertificatesList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileSslCertList
//
//
// SSL certificates management..
func (a SysApi) GetFileSslCertList() (*SysFileSslCertList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCert"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslCertList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileSslCrl
//
//
// SSL CRL files management.
//
// id is for ID of the resource.
func (a SysApi) GetFileSslCrl(id string) (*SysFileSslCrl, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCrl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslCrl)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileSslCrlList
//
//
// SSL CRL files management..
func (a SysApi) GetFileSslCrlList() (*SysFileSslCrlList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCrl"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslCrlList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileSslCsr
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetFileSslCsr(id string) (*SysFileSslCsr, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCsr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslCsr)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileSslCsrList
//
//
// ..
func (a SysApi) GetFileSslCsrList() (*SysFileSslCsrList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCsr"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslCsrList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileSslKey
//
//
// SSL certificate keys management.
//
// id is for ID of the resource.
func (a SysApi) GetFileSslKey(id string) (*SysFileSslKey, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslKey)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileSslKeyList
//
//
// SSL certificate keys management..
func (a SysApi) GetFileSslKeyList() (*SysFileSslKeyList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslKey"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslKeyList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileSystemSslCert
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetFileSystemSslCert(id string) (*SysFileSystemSslCert, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/systemSslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSystemSslCert)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileSystemSslCertBundleCertificates
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetFileSystemSslCertBundleCertificates(id string) (*SysFileSystemSslCertBundleCertificates, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/systemSslCert/bundleCertificates/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSystemSslCertBundleCertificates)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileSystemSslCertBundleCertificatesList
//
//
// ..
func (a SysApi) GetFileSystemSslCertBundleCertificatesList() (*SysFileSystemSslCertBundleCertificatesList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/systemSslCert/bundleCertificates"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSystemSslCertBundleCertificatesList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileSystemSslCertList
//
//
// ..
func (a SysApi) GetFileSystemSslCertList() (*SysFileSystemSslCertList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/systemSslCert"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSystemSslCertList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileSystemSslKey
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetFileSystemSslKey(id string) (*SysFileSystemSslKey, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/systemSslKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSystemSslKey)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFileSystemSslKeyList
//
//
// ..
func (a SysApi) GetFileSystemSslKeyList() (*SysFileSystemSslKeyList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/systemSslKey"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSystemSslKeyList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFixConnection
//
//
// FIX connection level stats.
//
// id is for ID of the resource.
func (a SysApi) GetFixConnection(id string) (*SysFixConnection, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fixConnection/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFixConnection)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFixConnectionList
//
//
// FIX connection level stats..
func (a SysApi) GetFixConnectionList() (*SysFixConnectionList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fixConnection"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFixConnectionList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFolder
//
//
// Folder configuration.
//
// id is for ID of the resource.
func (a SysApi) GetFolder(id string) (*SysFolder, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/folder/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFolder)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFolderList
//
//
// Folder configuration..
func (a SysApi) GetFolderList() (*SysFolderList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/folder"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFolderList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFpga
//
//
// FPGA(Field-Programmable Gate Array) firmware configuration.
//
// id is for ID of the resource.
func (a SysApi) GetFpga(id string) (*SysFpga, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fpga/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFpga)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFpgaFirmwareConfig
//
//
// The current FPGA firmware configuration.
//
// id is for ID of the resource.
func (a SysApi) GetFpgaFirmwareConfig(id string) (*SysFpgaFirmwareConfig, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fpga/firmwareConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFpgaFirmwareConfig)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFpgaFirmwareConfigList
//
//
// The current FPGA firmware configuration..
func (a SysApi) GetFpgaFirmwareConfigList() (*SysFpgaFirmwareConfigList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fpga/firmwareConfig"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFpgaFirmwareConfigList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFpgaInfo
//
//
// FPGA firmware information on the system.
//
// id is for ID of the resource.
func (a SysApi) GetFpgaInfo(id string) (*SysFpgaInfo, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fpga/info/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFpgaInfo)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFpgaInfoList
//
//
// FPGA firmware information on the system..
func (a SysApi) GetFpgaInfoList() (*SysFpgaInfoList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fpga/info"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFpgaInfoList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetFpgaList
//
//
// FPGA(Field-Programmable Gate Array) firmware configuration..
func (a SysApi) GetFpgaList() (*SysFpgaList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fpga"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFpgaList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetGeoipList
//
//
// Load GeoIP data files..
func (a SysApi) GetGeoipList() (*SysGeoipList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/geoip"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysGeoipList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetGlobalSettings
//
//
// General system settings.
//
// id is for ID of the resource.
func (a SysApi) GetGlobalSettings(id string) (*SysGlobalSettings, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/globalSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysGlobalSettings)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetGlobalSettingsList
//
//
// General system settings..
func (a SysApi) GetGlobalSettingsList() (*SysGlobalSettingsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/globalSettings"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysGlobalSettingsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetHaGroup
//
//
// Specifies the ha group used to calculate the failover score..
//
// id is for ID of the resource.
func (a SysApi) GetHaGroup(id string) (*SysHaGroup, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysHaGroup)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetHaGroupList
//
//
// Specifies the ha group used to calculate the failover score...
func (a SysApi) GetHaGroupList() (*SysHaGroupList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haGroup"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysHaGroupList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetHaMirror
//
//
// Statistics for connection mirroring..
//
// id is for ID of the resource.
func (a SysApi) GetHaMirror(id string) (*SysHaMirror, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haMirror/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysHaMirror)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetHaMirrorList
//
//
// Statistics for connection mirroring...
func (a SysApi) GetHaMirrorList() (*SysHaMirrorList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haMirror"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysHaMirrorList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetHaStatus
//
//
// Displays the settings and status for high availability on a system..
//
// id is for ID of the resource.
func (a SysApi) GetHaStatus(id string) (*SysHaStatus, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haStatus/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysHaStatus)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetHaStatusList
//
//
// Displays the settings and status for high availability on a system...
func (a SysApi) GetHaStatusList() (*SysHaStatusList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haStatus"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysHaStatusList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetHardware
//
//
// View hardware information.
//
// id is for ID of the resource.
func (a SysApi) GetHardware(id string) (*SysHardware, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/hardware/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysHardware)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetHardwareList
//
//
// View hardware information..
func (a SysApi) GetHardwareList() (*SysHardwareList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/hardware"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysHardwareList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetHostInfo
//
//
// Host statistics, including system memory, CPU, and processor.
//
// id is for ID of the resource.
func (a SysApi) GetHostInfo(id string) (*SysHostInfo, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/hostInfo/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysHostInfo)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetHostInfoList
//
//
// Host statistics, including system memory, CPU, and processor..
func (a SysApi) GetHostInfoList() (*SysHostInfoList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/hostInfo"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysHostInfoList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetHttpd
//
//
// HTTPD configuration.
//
// id is for ID of the resource.
func (a SysApi) GetHttpd(id string) (*SysHttpd, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/httpd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysHttpd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetHttpdList
//
//
// HTTPD configuration..
func (a SysApi) GetHttpdList() (*SysHttpdList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/httpd"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysHttpdList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetHypervisorInfo
//
//
// Configuration settings proposed by the vCMP hypervisor. (vCMP guest only).
//
// id is for ID of the resource.
func (a SysApi) GetHypervisorInfo(id string) (*SysHypervisorInfo, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/hypervisorInfo/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysHypervisorInfo)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetHypervisorInfoList
//
//
// Configuration settings proposed by the vCMP hypervisor. (vCMP guest only)..
func (a SysApi) GetHypervisorInfoList() (*SysHypervisorInfoList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/hypervisorInfo"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysHypervisorInfoList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcall
//
//
// Manage iCall configuration items.
//
// id is for ID of the resource.
func (a SysApi) GetIcall(id string) (*SysIcall, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcall)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcallEventList
//
//
// iCall event..
func (a SysApi) GetIcallEventList() (*SysIcallEventList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/event"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallEventList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcallHandler
//
//
// Manage the iCall event handler configuration items.
//
// id is for ID of the resource.
func (a SysApi) GetIcallHandler(id string) (*SysIcallHandler, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandler)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcallHandlerList
//
//
// Manage the iCall event handler configuration items..
func (a SysApi) GetIcallHandlerList() (*SysIcallHandlerList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcallHandlerPeriodic
//
//
// iCall periodic handler.
//
// id is for ID of the resource.
func (a SysApi) GetIcallHandlerPeriodic(id string) (*SysIcallHandlerPeriodic, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/periodic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerPeriodic)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcallHandlerPeriodicList
//
//
// iCall periodic handler..
func (a SysApi) GetIcallHandlerPeriodicList() (*SysIcallHandlerPeriodicList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/periodic"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerPeriodicList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcallHandlerPerpetual
//
//
// iCall perpetual handler.
//
// id is for ID of the resource.
func (a SysApi) GetIcallHandlerPerpetual(id string) (*SysIcallHandlerPerpetual, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerPerpetual)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcallHandlerPerpetualList
//
//
// iCall perpetual handler..
func (a SysApi) GetIcallHandlerPerpetualList() (*SysIcallHandlerPerpetualList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerPerpetualList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcallHandlerPerpetualSubscriptions
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetIcallHandlerPerpetualSubscriptions(id string) (*SysIcallHandlerPerpetualSubscriptions, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/subscriptions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerPerpetualSubscriptions)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcallHandlerPerpetualSubscriptionsList
//
//
// ..
func (a SysApi) GetIcallHandlerPerpetualSubscriptionsList() (*SysIcallHandlerPerpetualSubscriptionsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/subscriptions"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerPerpetualSubscriptionsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcallHandlerTriggered
//
//
// iCall event-triggered event handler.
//
// id is for ID of the resource.
func (a SysApi) GetIcallHandlerTriggered(id string) (*SysIcallHandlerTriggered, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerTriggered)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcallHandlerTriggeredList
//
//
// iCall event-triggered event handler..
func (a SysApi) GetIcallHandlerTriggeredList() (*SysIcallHandlerTriggeredList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerTriggeredList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcallHandlerTriggeredSubscriptions
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetIcallHandlerTriggeredSubscriptions(id string) (*SysIcallHandlerTriggeredSubscriptions, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/subscriptions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerTriggeredSubscriptions)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcallHandlerTriggeredSubscriptionsList
//
//
// ..
func (a SysApi) GetIcallHandlerTriggeredSubscriptionsList() (*SysIcallHandlerTriggeredSubscriptionsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/subscriptions"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerTriggeredSubscriptionsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcallIstatsTrigger
//
//
// Event trigger for iStats.
//
// id is for ID of the resource.
func (a SysApi) GetIcallIstatsTrigger(id string) (*SysIcallIstatsTrigger, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/istatsTrigger/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallIstatsTrigger)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcallIstatsTriggerList
//
//
// Event trigger for iStats..
func (a SysApi) GetIcallIstatsTriggerList() (*SysIcallIstatsTriggerList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/istatsTrigger"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallIstatsTriggerList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcallList
//
//
// Manage iCall configuration items..
func (a SysApi) GetIcallList() (*SysIcallList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcallPublisher
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetIcallPublisher(id string) (*SysIcallPublisher, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/publisher/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallPublisher)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcallPublisherList
//
//
// ..
func (a SysApi) GetIcallPublisherList() (*SysIcallPublisherList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/publisher"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallPublisherList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcallScript
//
//
// iCall script.
//
// id is for ID of the resource.
func (a SysApi) GetIcallScript(id string) (*SysIcallScript, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/script/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallScript)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcallScriptList
//
//
// iCall script..
func (a SysApi) GetIcallScriptList() (*SysIcallScriptList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/script"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallScriptList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcmpStat
//
//
// Standard ICMP statistics, including ICMPv4 packets and errors, and ICMPv6 packets and errors..
//
// id is for ID of the resource.
func (a SysApi) GetIcmpStat(id string) (*SysIcmpStat, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icmpStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcmpStat)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcmpStatList
//
//
// Standard ICMP statistics, including ICMPv4 packets and errors, and ICMPv6 packets and errors...
func (a SysApi) GetIcmpStatList() (*SysIcmpStatList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icmpStat"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcmpStatList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcontrolSoap
//
//
// iControl SOAP configuration.
//
// id is for ID of the resource.
func (a SysApi) GetIcontrolSoap(id string) (*SysIcontrolSoap, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icontrolSoap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcontrolSoap)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIcontrolSoapList
//
//
// iControl SOAP configuration..
func (a SysApi) GetIcontrolSoapList() (*SysIcontrolSoapList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icontrolSoap"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcontrolSoapList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpAddress
//
//
// View configured IP addresses.
//
// id is for ID of the resource.
func (a SysApi) GetIpAddress(id string) (*SysIpAddress, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipAddress/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIpAddress)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpAddressList
//
//
// View configured IP addresses..
func (a SysApi) GetIpAddressList() (*SysIpAddressList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipAddress"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIpAddressList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpStat
//
//
// Standard IP statistics, including IPv4 and IPv6 packets, fragments, fragments reassembled, and errors..
//
// id is for ID of the resource.
func (a SysApi) GetIpStat(id string) (*SysIpStat, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIpStat)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpStatList
//
//
// Standard IP statistics, including IPv4 and IPv6 packets, fragments, fragments reassembled, and errors...
func (a SysApi) GetIpStatList() (*SysIpStatList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipStat"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIpStatList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpfix
//
//
// Manages the common ipfix interface.
//
// id is for ID of the resource.
func (a SysApi) GetIpfix(id string) (*SysIpfix, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIpfix)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpfixDestination
//
//
// IPFIX destination statistics, including Template and Data Record counts.
//
// id is for ID of the resource.
func (a SysApi) GetIpfixDestination(id string) (*SysIpfixDestination, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/destination/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIpfixDestination)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpfixDestinationList
//
//
// IPFIX destination statistics, including Template and Data Record counts..
func (a SysApi) GetIpfixDestinationList() (*SysIpfixDestinationList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/destination"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIpfixDestinationList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpfixElement
//
//
// IPFIX element configuration.
//
// id is for ID of the resource.
func (a SysApi) GetIpfixElement(id string) (*SysIpfixElement, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/element/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIpfixElement)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpfixElementList
//
//
// IPFIX element configuration..
func (a SysApi) GetIpfixElementList() (*SysIpfixElementList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/element"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIpfixElementList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpfixIrules
//
//
// IPFIX iRules statistics, including allocated and outstanding memory.
//
// id is for ID of the resource.
func (a SysApi) GetIpfixIrules(id string) (*SysIpfixIrules, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/irules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIpfixIrules)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpfixIrulesList
//
//
// IPFIX iRules statistics, including allocated and outstanding memory..
func (a SysApi) GetIpfixIrulesList() (*SysIpfixIrulesList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/irules"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIpfixIrulesList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIpfixList
//
//
// Manages the common ipfix interface..
func (a SysApi) GetIpfixList() (*SysIpfixList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIpfixList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIprepList
//
//
// ..
func (a SysApi) GetIprepList() (*SysIprepList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/iprep"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIprepList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIprepStatus
//
//
// Display the IP reputation database update status.
//
// id is for ID of the resource.
func (a SysApi) GetIprepStatus(id string) (*SysIprepStatus, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/iprepStatus/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIprepStatus)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetIprepStatusList
//
//
// Display the IP reputation database update status..
func (a SysApi) GetIprepStatusList() (*SysIprepStatusList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/iprepStatus"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIprepStatusList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLicense
//
//
// Manage the system license.
//
// id is for ID of the resource.
func (a SysApi) GetLicense(id string) (*SysLicense, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/license/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLicense)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLicenseList
//
//
// Manage the system license..
func (a SysApi) GetLicenseList() (*SysLicenseList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/license"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLicenseList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLog
//
//
// View system log files.
//
// id is for ID of the resource.
func (a SysApi) GetLog(id string) (*SysLog, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/log/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLog)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfig
//
//
// Manages the common logging interface.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfig(id string) (*SysLogConfig, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfig)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigDestination
//
//
// Log Destination configuration.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigDestination(id string) (*SysLogConfigDestination, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestination)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigDestinationAlertd
//
//
// Forwards messages to the AlertD daemon.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigDestinationAlertd(id string) (*SysLogConfigDestinationAlertd, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/alertd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationAlertd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigDestinationAlertdList
//
//
// Forwards messages to the AlertD daemon..
func (a SysApi) GetLogConfigDestinationAlertdList() (*SysLogConfigDestinationAlertdList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/alertd"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationAlertdList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigDestinationArcsight
//
//
// Format messages to the ArcSight specification.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigDestinationArcsight(id string) (*SysLogConfigDestinationArcsight, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/arcsight/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationArcsight)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigDestinationArcsightList
//
//
// Format messages to the ArcSight specification..
func (a SysApi) GetLogConfigDestinationArcsightList() (*SysLogConfigDestinationArcsightList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/arcsight"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationArcsightList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigDestinationIpfix
//
//
// Formats logs into IPFIX messages and transmits them to a pool of IPFIX Collectors.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigDestinationIpfix(id string) (*SysLogConfigDestinationIpfix, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/ipfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationIpfix)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigDestinationIpfixList
//
//
// Formats logs into IPFIX messages and transmits them to a pool of IPFIX Collectors..
func (a SysApi) GetLogConfigDestinationIpfixList() (*SysLogConfigDestinationIpfixList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/ipfix"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationIpfixList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigDestinationList
//
//
// Log Destination configuration..
func (a SysApi) GetLogConfigDestinationList() (*SysLogConfigDestinationList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigDestinationLocalDatabase
//
//
// Forwards messages to the local database.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigDestinationLocalDatabase(id string) (*SysLogConfigDestinationLocalDatabase, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/localDatabase/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationLocalDatabase)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigDestinationLocalDatabaseList
//
//
// Forwards messages to the local database..
func (a SysApi) GetLogConfigDestinationLocalDatabaseList() (*SysLogConfigDestinationLocalDatabaseList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/localDatabase"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationLocalDatabaseList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigDestinationLocalSyslog
//
//
// Forwards messages to the local Syslog-ng process.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigDestinationLocalSyslog(id string) (*SysLogConfigDestinationLocalSyslog, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/localSyslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationLocalSyslog)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigDestinationLocalSyslogList
//
//
// Forwards messages to the local Syslog-ng process..
func (a SysApi) GetLogConfigDestinationLocalSyslogList() (*SysLogConfigDestinationLocalSyslogList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/localSyslog"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationLocalSyslogList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigDestinationManagementPort
//
//
// Forwards messages to a destination through the management port.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigDestinationManagementPort(id string) (*SysLogConfigDestinationManagementPort, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/managementPort/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationManagementPort)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigDestinationManagementPortList
//
//
// Forwards messages to a destination through the management port..
func (a SysApi) GetLogConfigDestinationManagementPortList() (*SysLogConfigDestinationManagementPortList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/managementPort"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationManagementPortList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigDestinationRemoteHighSpeedLog
//
//
// Forwards messages to a pool.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigDestinationRemoteHighSpeedLog(id string) (*SysLogConfigDestinationRemoteHighSpeedLog, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteHighSpeedLog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationRemoteHighSpeedLog)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigDestinationRemoteHighSpeedLogList
//
//
// Forwards messages to a pool..
func (a SysApi) GetLogConfigDestinationRemoteHighSpeedLogList() (*SysLogConfigDestinationRemoteHighSpeedLogList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteHighSpeedLog"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationRemoteHighSpeedLogList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigDestinationRemoteSyslog
//
//
// Format messages to the Syslog format for remote logging.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigDestinationRemoteSyslog(id string) (*SysLogConfigDestinationRemoteSyslog, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteSyslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationRemoteSyslog)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigDestinationRemoteSyslogList
//
//
// Format messages to the Syslog format for remote logging..
func (a SysApi) GetLogConfigDestinationRemoteSyslogList() (*SysLogConfigDestinationRemoteSyslogList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteSyslog"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationRemoteSyslogList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigDestinationSplunk
//
//
// Format messages to the Splunk specification.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigDestinationSplunk(id string) (*SysLogConfigDestinationSplunk, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/splunk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationSplunk)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigDestinationSplunkList
//
//
// Format messages to the Splunk specification..
func (a SysApi) GetLogConfigDestinationSplunkList() (*SysLogConfigDestinationSplunkList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/splunk"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationSplunkList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigFilter
//
//
// Selectively route logs to log publishers.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigFilter(id string) (*SysLogConfigFilter, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/filter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigFilter)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigFilterList
//
//
// Selectively route logs to log publishers..
func (a SysApi) GetLogConfigFilterList() (*SysLogConfigFilterList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/filter"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigFilterList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigList
//
//
// Manages the common logging interface..
func (a SysApi) GetLogConfigList() (*SysLogConfigList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigPublisher
//
//
// List of log destinations.
//
// id is for ID of the resource.
func (a SysApi) GetLogConfigPublisher(id string) (*SysLogConfigPublisher, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/publisher/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigPublisher)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogConfigPublisherList
//
//
// List of log destinations..
func (a SysApi) GetLogConfigPublisherList() (*SysLogConfigPublisherList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/publisher"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigPublisherList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogList
//
//
// View system log files..
func (a SysApi) GetLogList() (*SysLogList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/log"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogRotate
//
//
// Log rotation configuration.
//
// id is for ID of the resource.
func (a SysApi) GetLogRotate(id string) (*SysLogRotate, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logRotate/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogRotate)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLogRotateList
//
//
// Log rotation configuration..
func (a SysApi) GetLogRotateList() (*SysLogRotateList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logRotate"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogRotateList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLtcfgClassFields
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetLtcfgClassFields(id string) (*SysLtcfgClassFields, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgClass/fields/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLtcfgClassFields)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLtcfgClassFieldsList
//
//
// ..
func (a SysApi) GetLtcfgClassFieldsList() (*SysLtcfgClassFieldsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgClass/fields"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLtcfgClassFieldsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLtcfgClassList
//
//
// ..
func (a SysApi) GetLtcfgClassList() (*SysLtcfgClassList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgClass"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLtcfgClassList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLtcfgInstanceFields
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetLtcfgInstanceFields(id string) (*SysLtcfgInstanceFields, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgInstance/fields/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLtcfgInstanceFields)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLtcfgInstanceFieldsList
//
//
// ..
func (a SysApi) GetLtcfgInstanceFieldsList() (*SysLtcfgInstanceFieldsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgInstance/fields"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLtcfgInstanceFieldsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetLtcfgInstanceList
//
//
// ..
func (a SysApi) GetLtcfgInstanceList() (*SysLtcfgInstanceList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgInstance"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLtcfgInstanceList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetMacAddress
//
//
// View MAC addresses attached to the system.
//
// id is for ID of the resource.
func (a SysApi) GetMacAddress(id string) (*SysMacAddress, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/macAddress/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysMacAddress)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetMacAddressList
//
//
// View MAC addresses attached to the system..
func (a SysApi) GetMacAddressList() (*SysMacAddressList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/macAddress"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysMacAddressList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetManagementDhcp
//
//
// DHCP configuration for the management interface.
//
// id is for ID of the resource.
func (a SysApi) GetManagementDhcp(id string) (*SysManagementDhcp, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementDhcp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysManagementDhcp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetManagementDhcpList
//
//
// DHCP configuration for the management interface..
func (a SysApi) GetManagementDhcpList() (*SysManagementDhcpList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementDhcp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysManagementDhcpList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetManagementIp
//
//
// Management port address configuration.
//
// id is for ID of the resource.
func (a SysApi) GetManagementIp(id string) (*SysManagementIp, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementIp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysManagementIp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetManagementIpList
//
//
// Management port address configuration..
func (a SysApi) GetManagementIpList() (*SysManagementIpList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementIp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysManagementIpList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetManagementOvsdb
//
//
// OVSDB configuration.
//
// id is for ID of the resource.
func (a SysApi) GetManagementOvsdb(id string) (*SysManagementOvsdb, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementOvsdb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysManagementOvsdb)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetManagementOvsdbList
//
//
// OVSDB configuration..
func (a SysApi) GetManagementOvsdbList() (*SysManagementOvsdbList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementOvsdb"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysManagementOvsdbList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetManagementRoute
//
//
// Route configuration for the management interface.
//
// id is for ID of the resource.
func (a SysApi) GetManagementRoute(id string) (*SysManagementRoute, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementRoute/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysManagementRoute)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetManagementRouteList
//
//
// Route configuration for the management interface..
func (a SysApi) GetManagementRouteList() (*SysManagementRouteList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementRoute"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysManagementRouteList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetMcpState
//
//
// Displays Master Control Program (mcp) state..
//
// id is for ID of the resource.
func (a SysApi) GetMcpState(id string) (*SysMcpState, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/mcpState/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysMcpState)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetMcpStateList
//
//
// Displays Master Control Program (mcp) state...
func (a SysApi) GetMcpStateList() (*SysMcpStateList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/mcpState"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysMcpStateList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetMemory
//
//
// Memory statistics of system overall performance, on management hosts and traffic management modules, and on individual subsystem.
//
// id is for ID of the resource.
func (a SysApi) GetMemory(id string) (*SysMemory, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/memory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysMemory)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetMemoryList
//
//
// Memory statistics of system overall performance, on management hosts and traffic management modules, and on individual subsystem..
func (a SysApi) GetMemoryList() (*SysMemoryList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/memory"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysMemoryList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetNtp
//
//
// NTP configuration.
//
// id is for ID of the resource.
func (a SysApi) GetNtp(id string) (*SysNtp, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ntp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysNtp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetNtpList
//
//
// NTP configuration..
func (a SysApi) GetNtpList() (*SysNtpList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ntp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysNtpList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetNtpRestrict
//
//
// A restrict line in the NTP configuration.
//
// id is for ID of the resource.
func (a SysApi) GetNtpRestrict(id string) (*SysNtpRestrict, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ntp/restrict/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysNtpRestrict)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetNtpRestrictList
//
//
// A restrict line in the NTP configuration..
func (a SysApi) GetNtpRestrictList() (*SysNtpRestrictList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ntp/restrict"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysNtpRestrictList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetOutboundSmtp
//
//
// Configuration for outbound email sent by the TMOS system.
//
// id is for ID of the resource.
func (a SysApi) GetOutboundSmtp(id string) (*SysOutboundSmtp, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/outboundSmtp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysOutboundSmtp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetOutboundSmtpList
//
//
// Configuration for outbound email sent by the TMOS system..
func (a SysApi) GetOutboundSmtpList() (*SysOutboundSmtpList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/outboundSmtp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysOutboundSmtpList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPerformance
//
//
// System performance statistics.
//
// id is for ID of the resource.
func (a SysApi) GetPerformance(id string) (*SysPerformance, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPerformance)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPerformanceAllStats
//
//
// View or reset all available performance statistics.
//
// id is for ID of the resource.
func (a SysApi) GetPerformanceAllStats(id string) (*SysPerformanceAllStats, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/allStats/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPerformanceAllStats)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPerformanceAllStatsList
//
//
// View or reset all available performance statistics..
func (a SysApi) GetPerformanceAllStatsList() (*SysPerformanceAllStatsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/allStats"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPerformanceAllStatsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPerformanceConnections
//
//
// View active connection statistics.
//
// id is for ID of the resource.
func (a SysApi) GetPerformanceConnections(id string) (*SysPerformanceConnections, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/connections/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPerformanceConnections)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPerformanceConnectionsList
//
//
// View active connection statistics..
func (a SysApi) GetPerformanceConnectionsList() (*SysPerformanceConnectionsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/connections"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPerformanceConnectionsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPerformanceDnsexpress
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetPerformanceDnsexpress(id string) (*SysPerformanceDnsexpress, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/dnsexpress/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPerformanceDnsexpress)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPerformanceDnsexpressList
//
//
// ..
func (a SysApi) GetPerformanceDnsexpressList() (*SysPerformanceDnsexpressList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/dnsexpress"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPerformanceDnsexpressList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPerformanceDnssec
//
//
// View DNSSEC signing request/response rate statistics.
//
// id is for ID of the resource.
func (a SysApi) GetPerformanceDnssec(id string) (*SysPerformanceDnssec, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/dnssec/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPerformanceDnssec)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPerformanceDnssecList
//
//
// View DNSSEC signing request/response rate statistics..
func (a SysApi) GetPerformanceDnssecList() (*SysPerformanceDnssecList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/dnssec"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPerformanceDnssecList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPerformanceGtm
//
//
// View GTM request/response rate statistics.
//
// id is for ID of the resource.
func (a SysApi) GetPerformanceGtm(id string) (*SysPerformanceGtm, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/gtm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPerformanceGtm)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPerformanceGtmList
//
//
// View GTM request/response rate statistics..
func (a SysApi) GetPerformanceGtmList() (*SysPerformanceGtmList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/gtm"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPerformanceGtmList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPerformanceList
//
//
// System performance statistics..
func (a SysApi) GetPerformanceList() (*SysPerformanceList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPerformanceList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPerformanceRamcache
//
//
// View RAM Cache utilization.
//
// id is for ID of the resource.
func (a SysApi) GetPerformanceRamcache(id string) (*SysPerformanceRamcache, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/ramcache/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPerformanceRamcache)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPerformanceRamcacheList
//
//
// View RAM Cache utilization..
func (a SysApi) GetPerformanceRamcacheList() (*SysPerformanceRamcacheList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/ramcache"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPerformanceRamcacheList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPerformanceSystem
//
//
// View system CPU and memory usage.
//
// id is for ID of the resource.
func (a SysApi) GetPerformanceSystem(id string) (*SysPerformanceSystem, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/system/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPerformanceSystem)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPerformanceSystemList
//
//
// View system CPU and memory usage..
func (a SysApi) GetPerformanceSystemList() (*SysPerformanceSystemList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/system"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPerformanceSystemList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPerformanceThroughput
//
//
// View throughput statistics and SSL transactions/sec.
//
// id is for ID of the resource.
func (a SysApi) GetPerformanceThroughput(id string) (*SysPerformanceThroughput, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/throughput/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPerformanceThroughput)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPerformanceThroughputList
//
//
// View throughput statistics and SSL transactions/sec..
func (a SysApi) GetPerformanceThroughputList() (*SysPerformanceThroughputList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/throughput"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPerformanceThroughputList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPptpCallInfo
//
//
// Displays or deletes active pptp-calls on the BIG-IP system.
//
// id is for ID of the resource.
func (a SysApi) GetPptpCallInfo(id string) (*SysPptpCallInfo, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/pptpCallInfo/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPptpCallInfo)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPptpCallInfoList
//
//
// Displays or deletes active pptp-calls on the BIG-IP system..
func (a SysApi) GetPptpCallInfoList() (*SysPptpCallInfoList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/pptpCallInfo"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPptpCallInfoList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetProcInfo
//
//
// Display process status.
//
// id is for ID of the resource.
func (a SysApi) GetProcInfo(id string) (*SysProcInfo, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/procInfo/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysProcInfo)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetProcInfoList
//
//
// Display process status..
func (a SysApi) GetProcInfoList() (*SysProcInfoList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/procInfo"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysProcInfoList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetProvision
//
//
// Module resource configuration.
//
// id is for ID of the resource.
func (a SysApi) GetProvision(id string) (*SysProvision, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/provision/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysProvision)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetProvisionList
//
//
// Module resource configuration..
func (a SysApi) GetProvisionList() (*SysProvisionList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/provision"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysProvisionList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPvaTraffic
//
//
// Packet Velocity Acceleration Engine&#39;s (PVA) traffic statistics..
//
// id is for ID of the resource.
func (a SysApi) GetPvaTraffic(id string) (*SysPvaTraffic, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/pvaTraffic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPvaTraffic)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetPvaTrafficList
//
//
// Packet Velocity Acceleration Engine&#39;s (PVA) traffic statistics...
func (a SysApi) GetPvaTrafficList() (*SysPvaTrafficList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/pvaTraffic"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPvaTrafficList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRaid
//
//
// Manage disk arrays.
//
// id is for ID of the resource.
func (a SysApi) GetRaid(id string) (*SysRaid, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysRaid)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRaidArray
//
//
// Manage the disk array.
//
// id is for ID of the resource.
func (a SysApi) GetRaidArray(id string) (*SysRaidArray, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/array/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysRaidArray)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRaidArrayList
//
//
// Manage the disk array..
func (a SysApi) GetRaidArrayList() (*SysRaidArrayList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/array"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysRaidArrayList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRaidBay
//
//
// Manage drive bays.
//
// id is for ID of the resource.
func (a SysApi) GetRaidBay(id string) (*SysRaidBay, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/bay/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysRaidBay)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRaidBayList
//
//
// Manage drive bays..
func (a SysApi) GetRaidBayList() (*SysRaidBayList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/bay"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysRaidBayList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRaidDisk
//
//
// View disk drive status.
//
// id is for ID of the resource.
func (a SysApi) GetRaidDisk(id string) (*SysRaidDisk, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/disk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysRaidDisk)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRaidDiskList
//
//
// View disk drive status..
func (a SysApi) GetRaidDiskList() (*SysRaidDiskList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/disk"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysRaidDiskList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRaidList
//
//
// Manage disk arrays..
func (a SysApi) GetRaidList() (*SysRaidList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysRaidList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetRestrictedModuleList
//
//
// ..
func (a SysApi) GetRestrictedModuleList() (*SysRestrictedModuleList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/restrictedModule"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysRestrictedModuleList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetScriptd
//
//
// scriptd daemon configuration.
//
// id is for ID of the resource.
func (a SysApi) GetScriptd(id string) (*SysScriptd, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/scriptd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysScriptd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetScriptdList
//
//
// scriptd daemon configuration..
func (a SysApi) GetScriptdList() (*SysScriptdList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/scriptd"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysScriptdList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetService
//
//
// Controls the BIG-IP system services..
//
// id is for ID of the resource.
func (a SysApi) GetService(id string) (*SysService, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/service/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysService)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetServiceList
//
//
// Controls the BIG-IP system services...
func (a SysApi) GetServiceList() (*SysServiceList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/service"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysServiceList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflow
//
//
// sFlow configuration.
//
// id is for ID of the resource.
func (a SysApi) GetSflow(id string) (*SysSflow, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflow)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowDataSource
//
//
// The status of sFlow data sources.
//
// id is for ID of the resource.
func (a SysApi) GetSflowDataSource(id string) (*SysSflowDataSource, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/dataSource/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowDataSource)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowDataSourceHttp
//
//
// The status of HTTP sFlow data sources.
//
// id is for ID of the resource.
func (a SysApi) GetSflowDataSourceHttp(id string) (*SysSflowDataSourceHttp, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/dataSource/http/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowDataSourceHttp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowDataSourceHttpList
//
//
// The status of HTTP sFlow data sources..
func (a SysApi) GetSflowDataSourceHttpList() (*SysSflowDataSourceHttpList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/dataSource/http"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowDataSourceHttpList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowDataSourceList
//
//
// The status of sFlow data sources..
func (a SysApi) GetSflowDataSourceList() (*SysSflowDataSourceList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/dataSource"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowDataSourceList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowDataSourceSystem
//
//
// The status of system sFlow data sources.
//
// id is for ID of the resource.
func (a SysApi) GetSflowDataSourceSystem(id string) (*SysSflowDataSourceSystem, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/dataSource/system/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowDataSourceSystem)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowDataSourceSystemList
//
//
// The status of system sFlow data sources..
func (a SysApi) GetSflowDataSourceSystemList() (*SysSflowDataSourceSystemList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/dataSource/system"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowDataSourceSystemList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowDataSourceTmInterface
//
//
// The status of sFlow data sources (interfaces).
//
// id is for ID of the resource.
func (a SysApi) GetSflowDataSourceTmInterface(id string) (*SysSflowDataSourceTmInterface, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/dataSource/tmInterface/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowDataSourceTmInterface)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowDataSourceTmInterfaceList
//
//
// The status of sFlow data sources (interfaces)..
func (a SysApi) GetSflowDataSourceTmInterfaceList() (*SysSflowDataSourceTmInterfaceList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/dataSource/tmInterface"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowDataSourceTmInterfaceList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowDataSourceVlan
//
//
// The status of sFlow data sources (VLANs).
//
// id is for ID of the resource.
func (a SysApi) GetSflowDataSourceVlan(id string) (*SysSflowDataSourceVlan, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/dataSource/vlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowDataSourceVlan)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowDataSourceVlanList
//
//
// The status of sFlow data sources (VLANs)..
func (a SysApi) GetSflowDataSourceVlanList() (*SysSflowDataSourceVlanList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/dataSource/vlan"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowDataSourceVlanList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowGlobalSettings
//
//
// Global sFlow configuration.
//
// id is for ID of the resource.
func (a SysApi) GetSflowGlobalSettings(id string) (*SysSflowGlobalSettings, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowGlobalSettings)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowGlobalSettingsHttp
//
//
// Global HTTP sFlow configuration.
//
// id is for ID of the resource.
func (a SysApi) GetSflowGlobalSettingsHttp(id string) (*SysSflowGlobalSettingsHttp, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/http/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowGlobalSettingsHttp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowGlobalSettingsHttpList
//
//
// Global HTTP sFlow configuration..
func (a SysApi) GetSflowGlobalSettingsHttpList() (*SysSflowGlobalSettingsHttpList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/http"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowGlobalSettingsHttpList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowGlobalSettingsList
//
//
// Global sFlow configuration..
func (a SysApi) GetSflowGlobalSettingsList() (*SysSflowGlobalSettingsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowGlobalSettingsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowGlobalSettingsSystem
//
//
// Global system sFlow configuration.
//
// id is for ID of the resource.
func (a SysApi) GetSflowGlobalSettingsSystem(id string) (*SysSflowGlobalSettingsSystem, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/system/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowGlobalSettingsSystem)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowGlobalSettingsSystemList
//
//
// Global system sFlow configuration..
func (a SysApi) GetSflowGlobalSettingsSystemList() (*SysSflowGlobalSettingsSystemList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/system"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowGlobalSettingsSystemList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowGlobalSettingsTmInterface
//
//
// Global sFlow configuration for interfaces.
//
// id is for ID of the resource.
func (a SysApi) GetSflowGlobalSettingsTmInterface(id string) (*SysSflowGlobalSettingsTmInterface, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/tmInterface/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowGlobalSettingsTmInterface)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowGlobalSettingsTmInterfaceList
//
//
// Global sFlow configuration for interfaces..
func (a SysApi) GetSflowGlobalSettingsTmInterfaceList() (*SysSflowGlobalSettingsTmInterfaceList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/tmInterface"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowGlobalSettingsTmInterfaceList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowGlobalSettingsVlan
//
//
// Global sFlow configuration for VLANs.
//
// id is for ID of the resource.
func (a SysApi) GetSflowGlobalSettingsVlan(id string) (*SysSflowGlobalSettingsVlan, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/vlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowGlobalSettingsVlan)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowGlobalSettingsVlanList
//
//
// Global sFlow configuration for VLANs..
func (a SysApi) GetSflowGlobalSettingsVlanList() (*SysSflowGlobalSettingsVlanList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/vlan"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowGlobalSettingsVlanList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowList
//
//
// sFlow configuration..
func (a SysApi) GetSflowList() (*SysSflowList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowReceiver
//
//
// sFlow receiver configuration.
//
// id is for ID of the resource.
func (a SysApi) GetSflowReceiver(id string) (*SysSflowReceiver, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/receiver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowReceiver)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSflowReceiverList
//
//
// sFlow receiver configuration..
func (a SysApi) GetSflowReceiverList() (*SysSflowReceiverList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/receiver"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowReceiverList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSmtpServer
//
//
// SMTP configuration.
//
// id is for ID of the resource.
func (a SysApi) GetSmtpServer(id string) (*SysSmtpServer, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/smtpServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSmtpServer)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSmtpServerList
//
//
// SMTP configuration..
func (a SysApi) GetSmtpServerList() (*SysSmtpServerList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/smtpServer"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSmtpServerList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSnmp
//
//
// SNMP agent config.
//
// id is for ID of the resource.
func (a SysApi) GetSnmp(id string) (*SysSnmp, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSnmp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSnmpCommunities
//
//
// Specifies SNMP community strings and limits them to specific oid subsets..
//
// id is for ID of the resource.
func (a SysApi) GetSnmpCommunities(id string) (*SysSnmpCommunities, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/communities/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSnmpCommunities)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSnmpCommunitiesList
//
//
// Specifies SNMP community strings and limits them to specific oid subsets...
func (a SysApi) GetSnmpCommunitiesList() (*SysSnmpCommunitiesList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/communities"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSnmpCommunitiesList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSnmpList
//
//
// SNMP agent config..
func (a SysApi) GetSnmpList() (*SysSnmpList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSnmpList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSnmpTraps
//
//
// Generic interface for configuring SNMP traps..
//
// id is for ID of the resource.
func (a SysApi) GetSnmpTraps(id string) (*SysSnmpTraps, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/traps/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSnmpTraps)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSnmpTrapsList
//
//
// Generic interface for configuring SNMP traps...
func (a SysApi) GetSnmpTrapsList() (*SysSnmpTrapsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/traps"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSnmpTrapsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSnmpUsers
//
//
// Specifies user account information for use with SNMPv3..
//
// id is for ID of the resource.
func (a SysApi) GetSnmpUsers(id string) (*SysSnmpUsers, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/users/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSnmpUsers)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSnmpUsersList
//
//
// Specifies user account information for use with SNMPv3...
func (a SysApi) GetSnmpUsersList() (*SysSnmpUsersList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/users"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSnmpUsersList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSoftware
//
//
// Software Installation and Volume Management.
//
// id is for ID of the resource.
func (a SysApi) GetSoftware(id string) (*SysSoftware, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftware)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSoftwareBlockDeviceHotfix
//
//
// Manage block device hotfix images.
//
// id is for ID of the resource.
func (a SysApi) GetSoftwareBlockDeviceHotfix(id string) (*SysSoftwareBlockDeviceHotfix, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/blockDeviceHotfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareBlockDeviceHotfix)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSoftwareBlockDeviceHotfixList
//
//
// Manage block device hotfix images..
func (a SysApi) GetSoftwareBlockDeviceHotfixList() (*SysSoftwareBlockDeviceHotfixList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/blockDeviceHotfix"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareBlockDeviceHotfixList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSoftwareBlockDeviceImage
//
//
// Manage block device software images.
//
// id is for ID of the resource.
func (a SysApi) GetSoftwareBlockDeviceImage(id string) (*SysSoftwareBlockDeviceImage, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/blockDeviceImage/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareBlockDeviceImage)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSoftwareBlockDeviceImageList
//
//
// Manage block device software images..
func (a SysApi) GetSoftwareBlockDeviceImageList() (*SysSoftwareBlockDeviceImageList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/blockDeviceImage"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareBlockDeviceImageList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSoftwareHotfix
//
//
// Manage hotfix images.
//
// id is for ID of the resource.
func (a SysApi) GetSoftwareHotfix(id string) (*SysSoftwareHotfix, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/hotfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareHotfix)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSoftwareHotfixList
//
//
// Manage hotfix images..
func (a SysApi) GetSoftwareHotfixList() (*SysSoftwareHotfixList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/hotfix"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareHotfixList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSoftwareImage
//
//
// Manage software images.
//
// id is for ID of the resource.
func (a SysApi) GetSoftwareImage(id string) (*SysSoftwareImage, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/image/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareImage)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSoftwareImageList
//
//
// Manage software images..
func (a SysApi) GetSoftwareImageList() (*SysSoftwareImageList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/image"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareImageList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSoftwareList
//
//
// Software Installation and Volume Management..
func (a SysApi) GetSoftwareList() (*SysSoftwareList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSoftwareSignature
//
//
// Manage software signatures.
//
// id is for ID of the resource.
func (a SysApi) GetSoftwareSignature(id string) (*SysSoftwareSignature, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/signature/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareSignature)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSoftwareSignatureList
//
//
// Manage software signatures..
func (a SysApi) GetSoftwareSignatureList() (*SysSoftwareSignatureList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/signature"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareSignatureList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSoftwareStatus
//
//
// Status for software volumes.
//
// id is for ID of the resource.
func (a SysApi) GetSoftwareStatus(id string) (*SysSoftwareStatus, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/status/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareStatus)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSoftwareStatusList
//
//
// Status for software volumes..
func (a SysApi) GetSoftwareStatusList() (*SysSoftwareStatusList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/status"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareStatusList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSoftwareUpdate
//
//
// Manage software update checking.
//
// id is for ID of the resource.
func (a SysApi) GetSoftwareUpdate(id string) (*SysSoftwareUpdate, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/update/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareUpdate)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSoftwareUpdateList
//
//
// Manage software update checking..
func (a SysApi) GetSoftwareUpdateList() (*SysSoftwareUpdateList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/update"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareUpdateList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSoftwareUpdateStatus
//
//
// Display update check results.
//
// id is for ID of the resource.
func (a SysApi) GetSoftwareUpdateStatus(id string) (*SysSoftwareUpdateStatus, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/updateStatus/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareUpdateStatus)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSoftwareUpdateStatusList
//
//
// Display update check results..
func (a SysApi) GetSoftwareUpdateStatusList() (*SysSoftwareUpdateStatusList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/updateStatus"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareUpdateStatusList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSoftwareVolume
//
//
// Manage software volumes, or reboot to a specific volume.
//
// id is for ID of the resource.
func (a SysApi) GetSoftwareVolume(id string) (*SysSoftwareVolume, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/volume/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareVolume)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSoftwareVolumeList
//
//
// Manage software volumes, or reboot to a specific volume..
func (a SysApi) GetSoftwareVolumeList() (*SysSoftwareVolumeList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/volume"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareVolumeList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSshd
//
//
// SSHD configuration.
//
// id is for ID of the resource.
func (a SysApi) GetSshd(id string) (*SysSshd, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sshd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSshd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSshdList
//
//
// SSHD configuration..
func (a SysApi) GetSshdList() (*SysSshdList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sshd"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSshdList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetStateMirroring
//
//
// Redundant system connection mirroring configuration.
//
// id is for ID of the resource.
func (a SysApi) GetStateMirroring(id string) (*SysStateMirroring, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/stateMirroring/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysStateMirroring)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetStateMirroringList
//
//
// Redundant system connection mirroring configuration..
func (a SysApi) GetStateMirroringList() (*SysStateMirroringList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/stateMirroring"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysStateMirroringList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSyncSysFiles
//
//
// Sync System Files.
//
// id is for ID of the resource.
func (a SysApi) GetSyncSysFiles(id string) (*SysSyncSysFiles, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/syncSysFiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSyncSysFiles)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSyncSysFilesList
//
//
// Sync System Files..
func (a SysApi) GetSyncSysFilesList() (*SysSyncSysFilesList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/syncSysFiles"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSyncSysFilesList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSyslog
//
//
// System logging configuration.
//
// id is for ID of the resource.
func (a SysApi) GetSyslog(id string) (*SysSyslog, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/syslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSyslog)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetSyslogList
//
//
// System logging configuration..
func (a SysApi) GetSyslogList() (*SysSyslogList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/syslog"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSyslogList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTmmInfo
//
//
// Traffic management statistics, including process, memory, and CPU usage..
//
// id is for ID of the resource.
func (a SysApi) GetTmmInfo(id string) (*SysTmmInfo, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/tmmInfo/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysTmmInfo)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTmmInfoList
//
//
// Traffic management statistics, including process, memory, and CPU usage...
func (a SysApi) GetTmmInfoList() (*SysTmmInfoList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/tmmInfo"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysTmmInfoList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTmmTraffic
//
//
// Traffic management statistics, including traffic information, error, and connections redirected..
//
// id is for ID of the resource.
func (a SysApi) GetTmmTraffic(id string) (*SysTmmTraffic, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/tmmTraffic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysTmmTraffic)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTmmTrafficList
//
//
// Traffic management statistics, including traffic information, error, and connections redirected...
func (a SysApi) GetTmmTrafficList() (*SysTmmTrafficList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/tmmTraffic"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysTmmTrafficList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTraffic
//
//
// Global traffic statistics.
//
// id is for ID of the resource.
func (a SysApi) GetTraffic(id string) (*SysTraffic, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/traffic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysTraffic)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetTrafficList
//
//
// Global traffic statistics..
func (a SysApi) GetTrafficList() (*SysTrafficList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/traffic"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysTrafficList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetUcs
//
//
// Save and restore configuration from UCS files.
//
// id is for ID of the resource.
func (a SysApi) GetUcs(id string) (*SysUcs, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ucs/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysUcs)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetUcsList
//
//
// Save and restore configuration from UCS files..
func (a SysApi) GetUcsList() (*SysUcsList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ucs"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysUcsList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetUrlDb
//
//
// URL Database Configuration and Category Management.
//
// id is for ID of the resource.
func (a SysApi) GetUrlDb(id string) (*SysUrlDb, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysUrlDb)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetUrlDbDownloadResult
//
//
// URL Database Download Result.
//
// id is for ID of the resource.
func (a SysApi) GetUrlDbDownloadResult(id string) (*SysUrlDbDownloadResult, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/downloadResult/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysUrlDbDownloadResult)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetUrlDbDownloadResultList
//
//
// URL Database Download Result..
func (a SysApi) GetUrlDbDownloadResultList() (*SysUrlDbDownloadResultList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/downloadResult"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysUrlDbDownloadResultList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetUrlDbDownloadSchedule
//
//
// URL Database Download Schedule.
//
// id is for ID of the resource.
func (a SysApi) GetUrlDbDownloadSchedule(id string) (*SysUrlDbDownloadSchedule, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/downloadSchedule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysUrlDbDownloadSchedule)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetUrlDbDownloadScheduleList
//
//
// URL Database Download Schedule..
func (a SysApi) GetUrlDbDownloadScheduleList() (*SysUrlDbDownloadScheduleList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/downloadSchedule"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysUrlDbDownloadScheduleList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetUrlDbList
//
//
// URL Database Configuration and Category Management..
func (a SysApi) GetUrlDbList() (*SysUrlDbList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysUrlDbList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetUrlDbUrlCategory
//
//
// .
//
// id is for ID of the resource.
func (a SysApi) GetUrlDbUrlCategory(id string) (*SysUrlDbUrlCategory, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/urlCategory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysUrlDbUrlCategory)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetUrlDbUrlCategoryList
//
//
// ..
func (a SysApi) GetUrlDbUrlCategoryList() (*SysUrlDbUrlCategoryList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/urlCategory"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysUrlDbUrlCategoryList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetVersion
//
//
// View system version and hotfix information.
//
// id is for ID of the resource.
func (a SysApi) GetVersion(id string) (*SysVersion, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/version/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysVersion)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// GetVersionList
//
//
// View system version and hotfix information..
func (a SysApi) GetVersionList() (*SysVersionList, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/version"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysVersionList)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchApplicationAplScript
//
//
// Scripts included by an application template.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchApplicationAplScript(id string, object SysApplicationAplScript) (*SysApplicationAplScript, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/aplScript/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationAplScript)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchApplicationCustomStat
//
//
// Derived iStats.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchApplicationCustomStat(id string, object SysApplicationCustomStat) (*SysApplicationCustomStat, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/customStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationCustomStat)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchApplicationService
//
//
// Application configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchApplicationService(id string, object SysApplicationService) (*SysApplicationService, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/service/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationService)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchApplicationTemplate
//
//
// Application templates.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchApplicationTemplate(id string, object SysApplicationTemplate) (*SysApplicationTemplate, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/template/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationTemplate)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchApplicationTemplateActions
//
//
// Manage the set of actions associated with an application template..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchApplicationTemplateActions(id string, object SysApplicationTemplateActions) (*SysApplicationTemplateActions, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/template/actions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationTemplateActions)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchAutoscaleGroup
//
//
// Autoscale group information for Amazon Web Services(AWS)..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchAutoscaleGroup(id string, object SysAutoscaleGroup) (*SysAutoscaleGroup, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/autoscaleGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysAutoscaleGroup)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchClock
//
//
// Display the current date and time.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchClock(id string, object SysClock) (*SysClock, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/clock/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysClock)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchCluster
//
//
// Cluster configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchCluster(id string, object SysCluster) (*SysCluster, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/cluster/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCluster)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchConnection
//
//
// Displays or deletes active connections on the BIG-IP system.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchConnection(id string, object SysConnection) (*SysConnection, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/connection/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysConnection)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchConsole
//
//
// Configure the serial console.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchConsole(id string, object SysConsole) (*SysConsole, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/console/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysConsole)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchCryptoClient
//
//
// Crypto client configuration..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchCryptoClient(id string, object SysCryptoClient) (*SysCryptoClient, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/client/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoClient)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchCryptoFipsExternalHsm
//
//
// FIPS external hsm specific configuration..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchCryptoFipsExternalHsm(id string, object SysCryptoFipsExternalHsm) (*SysCryptoFipsExternalHsm, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/externalHsm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoFipsExternalHsm)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchCryptoMasterKey
//
//
// Displays internal encryption key information on a system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchCryptoMasterKey(id string, object SysCryptoMasterKey) (*SysCryptoMasterKey, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/masterKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoMasterKey)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchCryptoServer
//
//
// Crypto server configuration..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchCryptoServer(id string, object SysCryptoServer) (*SysCryptoServer, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/server/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoServer)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchDaemonHa
//
//
// System daemon HA configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDaemonHa(id string, object SysDaemonHa) (*SysDaemonHa, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonHa/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonHa)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchDaemonLogSettingsClusterd
//
//
// The clusterd daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDaemonLogSettingsClusterd(id string, object SysDaemonLogSettingsClusterd) (*SysDaemonLogSettingsClusterd, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/clusterd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsClusterd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchDaemonLogSettingsCsyncd
//
//
// The csyncd daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDaemonLogSettingsCsyncd(id string, object SysDaemonLogSettingsCsyncd) (*SysDaemonLogSettingsCsyncd, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/csyncd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsCsyncd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchDaemonLogSettingsIcrd
//
//
// The icrd daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDaemonLogSettingsIcrd(id string, object SysDaemonLogSettingsIcrd) (*SysDaemonLogSettingsIcrd, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/icrd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsIcrd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchDaemonLogSettingsLind
//
//
// The lind daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDaemonLogSettingsLind(id string, object SysDaemonLogSettingsLind) (*SysDaemonLogSettingsLind, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/lind/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsLind)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchDaemonLogSettingsMcpd
//
//
// The mcpd daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDaemonLogSettingsMcpd(id string, object SysDaemonLogSettingsMcpd) (*SysDaemonLogSettingsMcpd, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/mcpd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsMcpd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchDaemonLogSettingsTmm
//
//
// The tmm daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDaemonLogSettingsTmm(id string, object SysDaemonLogSettingsTmm) (*SysDaemonLogSettingsTmm, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/tmm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsTmm)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchDatastor
//
//
// Optimization data storage configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDatastor(id string, object SysDatastor) (*SysDatastor, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/datastor/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDatastor)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchDb
//
//
// General system properties.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDb(id string, object SysDb) (*SysDb, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/db/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDb)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchDiskDirectory
//
//
// System directory resize operations..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDiskDirectory(id string, object SysDiskDirectory) (*SysDiskDirectory, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/directory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDiskDirectory)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchDiskLogicalDisk
//
//
// Logical Disk Configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDiskLogicalDisk(id string, object SysDiskLogicalDisk) (*SysDiskLogicalDisk, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/logicalDisk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDiskLogicalDisk)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchDns
//
//
// DNS configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchDns(id string, object SysDns) (*SysDns, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/dns/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDns)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchEcmCloudProvider
//
//
// Describes the properties of all the cloud-providers.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchEcmCloudProvider(id string, object SysEcmCloudProvider) (*SysEcmCloudProvider, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/cloudProvider/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysEcmCloudProvider)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchEcmConfig
//
//
// Specifies the ecm configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchEcmConfig(id string, object SysEcmConfig) (*SysEcmConfig, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/config/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysEcmConfig)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchFeatureModule
//
//
// Feature module configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFeatureModule(id string, object SysFeatureModule) (*SysFeatureModule, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/featureModule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFeatureModule)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchFileApacheSslCert
//
//
// SSL certificates management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFileApacheSslCert(id string, object SysFileApacheSslCert) (*SysFileApacheSslCert, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/apacheSslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileApacheSslCert)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchFileDashboardViewset
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFileDashboardViewset(id string, object SysFileDashboardViewset) (*SysFileDashboardViewset, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dashboardViewset/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileDashboardViewset)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchFileDataGroup
//
//
// External Data Group files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFileDataGroup(id string, object SysFileDataGroup) (*SysFileDataGroup, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dataGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileDataGroup)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchFileDeviceCapabilitiesDb
//
//
// Device capabilities DB file management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFileDeviceCapabilitiesDb(id string, object SysFileDeviceCapabilitiesDb) (*SysFileDeviceCapabilitiesDb, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/deviceCapabilitiesDb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileDeviceCapabilitiesDb)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchFileExternalMonitor
//
//
// External Monitor files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFileExternalMonitor(id string, object SysFileExternalMonitor) (*SysFileExternalMonitor, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/externalMonitor/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileExternalMonitor)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchFileIfile
//
//
// iFile files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFileIfile(id string, object SysFileIfile) (*SysFileIfile, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/ifile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileIfile)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchFileSslCert
//
//
// SSL certificates management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFileSslCert(id string, object SysFileSslCert) (*SysFileSslCert, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslCert)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchFileSslCrl
//
//
// SSL CRL files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFileSslCrl(id string, object SysFileSslCrl) (*SysFileSslCrl, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCrl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslCrl)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchFileSslCsr
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFileSslCsr(id string, object SysFileSslCsr) (*SysFileSslCsr, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCsr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslCsr)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchFileSslKey
//
//
// SSL certificate keys management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFileSslKey(id string, object SysFileSslKey) (*SysFileSslKey, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslKey)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchFixConnection
//
//
// FIX connection level stats.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFixConnection(id string, object SysFixConnection) (*SysFixConnection, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fixConnection/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFixConnection)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchFolder
//
//
// Folder configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFolder(id string, object SysFolder) (*SysFolder, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/folder/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFolder)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchFpgaFirmwareConfig
//
//
// The current FPGA firmware configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchFpgaFirmwareConfig(id string, object SysFpgaFirmwareConfig) (*SysFpgaFirmwareConfig, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fpga/firmwareConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFpgaFirmwareConfig)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchGlobalSettings
//
//
// General system settings.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchGlobalSettings(id string, object SysGlobalSettings) (*SysGlobalSettings, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/globalSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysGlobalSettings)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchHaGroup
//
//
// Specifies the ha group used to calculate the failover score..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchHaGroup(id string, object SysHaGroup) (*SysHaGroup, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysHaGroup)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchHttpd
//
//
// HTTPD configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchHttpd(id string, object SysHttpd) (*SysHttpd, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/httpd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysHttpd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchIcallHandlerPeriodic
//
//
// iCall periodic handler.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchIcallHandlerPeriodic(id string, object SysIcallHandlerPeriodic) (*SysIcallHandlerPeriodic, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/periodic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerPeriodic)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchIcallHandlerPerpetual
//
//
// iCall perpetual handler.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchIcallHandlerPerpetual(id string, object SysIcallHandlerPerpetual) (*SysIcallHandlerPerpetual, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerPerpetual)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchIcallHandlerPerpetualSubscriptions
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchIcallHandlerPerpetualSubscriptions(id string, object SysIcallHandlerPerpetualSubscriptions) (*SysIcallHandlerPerpetualSubscriptions, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/subscriptions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerPerpetualSubscriptions)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchIcallHandlerTriggered
//
//
// iCall event-triggered event handler.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchIcallHandlerTriggered(id string, object SysIcallHandlerTriggered) (*SysIcallHandlerTriggered, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerTriggered)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchIcallHandlerTriggeredSubscriptions
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchIcallHandlerTriggeredSubscriptions(id string, object SysIcallHandlerTriggeredSubscriptions) (*SysIcallHandlerTriggeredSubscriptions, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/subscriptions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerTriggeredSubscriptions)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchIcallIstatsTrigger
//
//
// Event trigger for iStats.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchIcallIstatsTrigger(id string, object SysIcallIstatsTrigger) (*SysIcallIstatsTrigger, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/istatsTrigger/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallIstatsTrigger)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchIcallScript
//
//
// iCall script.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchIcallScript(id string, object SysIcallScript) (*SysIcallScript, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/script/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallScript)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchIcontrolSoap
//
//
// iControl SOAP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchIcontrolSoap(id string, object SysIcontrolSoap) (*SysIcontrolSoap, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icontrolSoap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcontrolSoap)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchIpfixElement
//
//
// IPFIX element configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchIpfixElement(id string, object SysIpfixElement) (*SysIpfixElement, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/element/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIpfixElement)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchLogConfigDestinationAlertd
//
//
// Forwards messages to the AlertD daemon.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigDestinationAlertd(id string, object SysLogConfigDestinationAlertd) (*SysLogConfigDestinationAlertd, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/alertd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationAlertd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchLogConfigDestinationArcsight
//
//
// Format messages to the ArcSight specification.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigDestinationArcsight(id string, object SysLogConfigDestinationArcsight) (*SysLogConfigDestinationArcsight, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/arcsight/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationArcsight)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchLogConfigDestinationIpfix
//
//
// Formats logs into IPFIX messages and transmits them to a pool of IPFIX Collectors.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigDestinationIpfix(id string, object SysLogConfigDestinationIpfix) (*SysLogConfigDestinationIpfix, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/ipfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationIpfix)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchLogConfigDestinationLocalDatabase
//
//
// Forwards messages to the local database.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigDestinationLocalDatabase(id string, object SysLogConfigDestinationLocalDatabase) (*SysLogConfigDestinationLocalDatabase, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/localDatabase/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationLocalDatabase)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchLogConfigDestinationLocalSyslog
//
//
// Forwards messages to the local Syslog-ng process.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigDestinationLocalSyslog(id string, object SysLogConfigDestinationLocalSyslog) (*SysLogConfigDestinationLocalSyslog, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/localSyslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationLocalSyslog)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchLogConfigDestinationManagementPort
//
//
// Forwards messages to a destination through the management port.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigDestinationManagementPort(id string, object SysLogConfigDestinationManagementPort) (*SysLogConfigDestinationManagementPort, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/managementPort/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationManagementPort)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchLogConfigDestinationRemoteHighSpeedLog
//
//
// Forwards messages to a pool.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigDestinationRemoteHighSpeedLog(id string, object SysLogConfigDestinationRemoteHighSpeedLog) (*SysLogConfigDestinationRemoteHighSpeedLog, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteHighSpeedLog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationRemoteHighSpeedLog)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchLogConfigDestinationRemoteSyslog
//
//
// Format messages to the Syslog format for remote logging.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigDestinationRemoteSyslog(id string, object SysLogConfigDestinationRemoteSyslog) (*SysLogConfigDestinationRemoteSyslog, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteSyslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationRemoteSyslog)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchLogConfigDestinationSplunk
//
//
// Format messages to the Splunk specification.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigDestinationSplunk(id string, object SysLogConfigDestinationSplunk) (*SysLogConfigDestinationSplunk, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/splunk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationSplunk)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchLogConfigFilter
//
//
// Selectively route logs to log publishers.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigFilter(id string, object SysLogConfigFilter) (*SysLogConfigFilter, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/filter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigFilter)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchLogConfigPublisher
//
//
// List of log destinations.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogConfigPublisher(id string, object SysLogConfigPublisher) (*SysLogConfigPublisher, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/publisher/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigPublisher)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchLogRotate
//
//
// Log rotation configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLogRotate(id string, object SysLogRotate) (*SysLogRotate, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logRotate/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogRotate)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchLtcfgClassFields
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLtcfgClassFields(id string, object SysLtcfgClassFields) (*SysLtcfgClassFields, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgClass/fields/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLtcfgClassFields)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchLtcfgInstanceFields
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchLtcfgInstanceFields(id string, object SysLtcfgInstanceFields) (*SysLtcfgInstanceFields, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgInstance/fields/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLtcfgInstanceFields)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchManagementDhcp
//
//
// DHCP configuration for the management interface.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchManagementDhcp(id string, object SysManagementDhcp) (*SysManagementDhcp, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementDhcp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysManagementDhcp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchManagementIp
//
//
// Management port address configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchManagementIp(id string, object SysManagementIp) (*SysManagementIp, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementIp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysManagementIp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchManagementOvsdb
//
//
// OVSDB configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchManagementOvsdb(id string, object SysManagementOvsdb) (*SysManagementOvsdb, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementOvsdb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysManagementOvsdb)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchManagementRoute
//
//
// Route configuration for the management interface.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchManagementRoute(id string, object SysManagementRoute) (*SysManagementRoute, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementRoute/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysManagementRoute)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchNtp
//
//
// NTP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchNtp(id string, object SysNtp) (*SysNtp, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ntp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysNtp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchNtpRestrict
//
//
// A restrict line in the NTP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchNtpRestrict(id string, object SysNtpRestrict) (*SysNtpRestrict, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ntp/restrict/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysNtpRestrict)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchOutboundSmtp
//
//
// Configuration for outbound email sent by the TMOS system.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchOutboundSmtp(id string, object SysOutboundSmtp) (*SysOutboundSmtp, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/outboundSmtp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysOutboundSmtp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchProvision
//
//
// Module resource configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchProvision(id string, object SysProvision) (*SysProvision, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/provision/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysProvision)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchRaidArray
//
//
// Manage the disk array.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchRaidArray(id string, object SysRaidArray) (*SysRaidArray, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/array/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysRaidArray)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchRaidBay
//
//
// Manage drive bays.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchRaidBay(id string, object SysRaidBay) (*SysRaidBay, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/bay/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysRaidBay)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchScriptd
//
//
// scriptd daemon configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchScriptd(id string, object SysScriptd) (*SysScriptd, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/scriptd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysScriptd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchService
//
//
// Controls the BIG-IP system services..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchService(id string, object SysService) (*SysService, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/service/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysService)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchSflowGlobalSettingsHttp
//
//
// Global HTTP sFlow configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSflowGlobalSettingsHttp(id string, object SysSflowGlobalSettingsHttp) (*SysSflowGlobalSettingsHttp, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/http/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowGlobalSettingsHttp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchSflowGlobalSettingsSystem
//
//
// Global system sFlow configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSflowGlobalSettingsSystem(id string, object SysSflowGlobalSettingsSystem) (*SysSflowGlobalSettingsSystem, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/system/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowGlobalSettingsSystem)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchSflowGlobalSettingsTmInterface
//
//
// Global sFlow configuration for interfaces.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSflowGlobalSettingsTmInterface(id string, object SysSflowGlobalSettingsTmInterface) (*SysSflowGlobalSettingsTmInterface, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/tmInterface/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowGlobalSettingsTmInterface)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchSflowGlobalSettingsVlan
//
//
// Global sFlow configuration for VLANs.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSflowGlobalSettingsVlan(id string, object SysSflowGlobalSettingsVlan) (*SysSflowGlobalSettingsVlan, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/vlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowGlobalSettingsVlan)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchSflowReceiver
//
//
// sFlow receiver configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSflowReceiver(id string, object SysSflowReceiver) (*SysSflowReceiver, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/receiver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowReceiver)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchSmtpServer
//
//
// SMTP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSmtpServer(id string, object SysSmtpServer) (*SysSmtpServer, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/smtpServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSmtpServer)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchSnmp
//
//
// SNMP agent config.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSnmp(id string, object SysSnmp) (*SysSnmp, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSnmp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchSnmpCommunities
//
//
// Specifies SNMP community strings and limits them to specific oid subsets..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSnmpCommunities(id string, object SysSnmpCommunities) (*SysSnmpCommunities, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/communities/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSnmpCommunities)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchSnmpTraps
//
//
// Generic interface for configuring SNMP traps..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSnmpTraps(id string, object SysSnmpTraps) (*SysSnmpTraps, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/traps/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSnmpTraps)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchSnmpUsers
//
//
// Specifies user account information for use with SNMPv3..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSnmpUsers(id string, object SysSnmpUsers) (*SysSnmpUsers, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/users/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSnmpUsers)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchSoftwareUpdate
//
//
// Manage software update checking.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSoftwareUpdate(id string, object SysSoftwareUpdate) (*SysSoftwareUpdate, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/update/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareUpdate)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchSshd
//
//
// SSHD configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSshd(id string, object SysSshd) (*SysSshd, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sshd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSshd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchStateMirroring
//
//
// Redundant system connection mirroring configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchStateMirroring(id string, object SysStateMirroring) (*SysStateMirroring, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/stateMirroring/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysStateMirroring)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchSyslog
//
//
// System logging configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchSyslog(id string, object SysSyslog) (*SysSyslog, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/syslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSyslog)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchUrlDbDownloadSchedule
//
//
// URL Database Download Schedule.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchUrlDbDownloadSchedule(id string, object SysUrlDbDownloadSchedule) (*SysUrlDbDownloadSchedule, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/downloadSchedule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysUrlDbDownloadSchedule)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PatchUrlDbUrlCategory
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PatchUrlDbUrlCategory(id string, object SysUrlDbUrlCategory) (*SysUrlDbUrlCategory, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/urlCategory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysUrlDbUrlCategory)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostApplicationAplScript
//
//
// Scripts included by an application template.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostApplicationAplScript(id string, object SysApplicationAplScript) (*SysApplicationAplScript, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/aplScript/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationAplScript)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostApplicationCustomStat
//
//
// Derived iStats.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostApplicationCustomStat(id string, object SysApplicationCustomStat) (*SysApplicationCustomStat, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/customStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationCustomStat)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostApplicationService
//
//
// Application configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostApplicationService(id string, object SysApplicationService) (*SysApplicationService, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/service/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationService)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostApplicationTemplate
//
//
// Application templates.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostApplicationTemplate(id string, object SysApplicationTemplate) (*SysApplicationTemplate, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/template/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationTemplate)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostClassificationSignature
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostClassificationSignature(id string, object SysClassificationSignature) (*SysClassificationSignature, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/classificationSignature/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysClassificationSignature)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostConfig
//
//
// Save and load system configuration files.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostConfig(id string, object SysConfig) (*SysConfig, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/config/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysConfig)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostCryptoCert
//
//
// Certificate configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostCryptoCert(id string, object SysCryptoCert) (*SysCryptoCert, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/cert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoCert)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostCryptoCheckCert
//
//
// Certificate expiration check utility.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostCryptoCheckCert(id string, object SysCryptoCheckCert) (*SysCryptoCheckCert, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/checkCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoCheckCert)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostCryptoClient
//
//
// Crypto client configuration..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostCryptoClient(id string, object SysCryptoClient) (*SysCryptoClient, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/client/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoClient)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostCryptoCrl
//
//
// Certificate revocation list configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostCryptoCrl(id string, object SysCryptoCrl) (*SysCryptoCrl, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/crl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoCrl)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostCryptoCsr
//
//
// Certificate Signing Request configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostCryptoCsr(id string, object SysCryptoCsr) (*SysCryptoCsr, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/csr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoCsr)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostCryptoFipsExternalHsm
//
//
// FIPS external hsm specific configuration..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostCryptoFipsExternalHsm(id string, object SysCryptoFipsExternalHsm) (*SysCryptoFipsExternalHsm, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/externalHsm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoFipsExternalHsm)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostCryptoKey
//
//
// Key configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostCryptoKey(id string, object SysCryptoKey) (*SysCryptoKey, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/key/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoKey)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostCryptoMasterKey
//
//
// Displays internal encryption key information on a system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostCryptoMasterKey(id string, object SysCryptoMasterKey) (*SysCryptoMasterKey, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/masterKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoMasterKey)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostCryptoPkcs12
//
//
// PKCS12 configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostCryptoPkcs12(id string, object SysCryptoPkcs12) (*SysCryptoPkcs12, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/pkcs12/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoPkcs12)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostCryptoServer
//
//
// Crypto server configuration..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostCryptoServer(id string, object SysCryptoServer) (*SysCryptoServer, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/server/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoServer)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostEcmCloudProvider
//
//
// Describes the properties of all the cloud-providers.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostEcmCloudProvider(id string, object SysEcmCloudProvider) (*SysEcmCloudProvider, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/cloudProvider/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysEcmCloudProvider)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostFailover
//
//
// Redundant system failover state.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFailover(id string, object SysFailover) (*SysFailover, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/failover/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFailover)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostFileApacheSslCert
//
//
// SSL certificates management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileApacheSslCert(id string, object SysFileApacheSslCert) (*SysFileApacheSslCert, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/apacheSslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileApacheSslCert)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostFileDashboardViewset
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileDashboardViewset(id string, object SysFileDashboardViewset) (*SysFileDashboardViewset, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dashboardViewset/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileDashboardViewset)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostFileDataGroup
//
//
// External Data Group files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileDataGroup(id string, object SysFileDataGroup) (*SysFileDataGroup, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dataGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileDataGroup)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostFileDeviceCapabilitiesDb
//
//
// Device capabilities DB file management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileDeviceCapabilitiesDb(id string, object SysFileDeviceCapabilitiesDb) (*SysFileDeviceCapabilitiesDb, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/deviceCapabilitiesDb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileDeviceCapabilitiesDb)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostFileExternalMonitor
//
//
// External Monitor files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileExternalMonitor(id string, object SysFileExternalMonitor) (*SysFileExternalMonitor, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/externalMonitor/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileExternalMonitor)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostFileIfile
//
//
// iFile files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileIfile(id string, object SysFileIfile) (*SysFileIfile, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/ifile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileIfile)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostFileSslCert
//
//
// SSL certificates management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileSslCert(id string, object SysFileSslCert) (*SysFileSslCert, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslCert)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostFileSslCrl
//
//
// SSL CRL files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileSslCrl(id string, object SysFileSslCrl) (*SysFileSslCrl, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCrl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslCrl)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostFileSslCsr
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileSslCsr(id string, object SysFileSslCsr) (*SysFileSslCsr, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCsr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslCsr)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostFileSslKey
//
//
// SSL certificate keys management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileSslKey(id string, object SysFileSslKey) (*SysFileSslKey, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslKey)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostFileSystemSslCert
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileSystemSslCert(id string, object SysFileSystemSslCert) (*SysFileSystemSslCert, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/systemSslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSystemSslCert)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostFileSystemSslKey
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFileSystemSslKey(id string, object SysFileSystemSslKey) (*SysFileSystemSslKey, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/systemSslKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSystemSslKey)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostFolder
//
//
// Folder configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFolder(id string, object SysFolder) (*SysFolder, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/folder/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFolder)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostFpgaFirmwareConfig
//
//
// The current FPGA firmware configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostFpgaFirmwareConfig(id string, object SysFpgaFirmwareConfig) (*SysFpgaFirmwareConfig, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fpga/firmwareConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFpgaFirmwareConfig)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostGeoip
//
//
// Load GeoIP data files.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostGeoip(id string, object SysGeoip) (*SysGeoip, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/geoip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysGeoip)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostHaGroup
//
//
// Specifies the ha group used to calculate the failover score..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostHaGroup(id string, object SysHaGroup) (*SysHaGroup, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysHaGroup)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostHaMirror
//
//
// Statistics for connection mirroring..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostHaMirror(id string, object SysHaMirror) (*SysHaMirror, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haMirror/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysHaMirror)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostIcallEvent
//
//
// iCall event.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIcallEvent(id string, object SysIcallEvent) (*SysIcallEvent, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/event/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallEvent)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostIcallHandlerPeriodic
//
//
// iCall periodic handler.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIcallHandlerPeriodic(id string, object SysIcallHandlerPeriodic) (*SysIcallHandlerPeriodic, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/periodic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerPeriodic)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostIcallHandlerPerpetual
//
//
// iCall perpetual handler.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIcallHandlerPerpetual(id string, object SysIcallHandlerPerpetual) (*SysIcallHandlerPerpetual, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerPerpetual)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostIcallHandlerPerpetualSubscriptions
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIcallHandlerPerpetualSubscriptions(id string, object SysIcallHandlerPerpetualSubscriptions) (*SysIcallHandlerPerpetualSubscriptions, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/subscriptions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerPerpetualSubscriptions)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostIcallHandlerTriggered
//
//
// iCall event-triggered event handler.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIcallHandlerTriggered(id string, object SysIcallHandlerTriggered) (*SysIcallHandlerTriggered, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerTriggered)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostIcallHandlerTriggeredSubscriptions
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIcallHandlerTriggeredSubscriptions(id string, object SysIcallHandlerTriggeredSubscriptions) (*SysIcallHandlerTriggeredSubscriptions, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/subscriptions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerTriggeredSubscriptions)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostIcallIstatsTrigger
//
//
// Event trigger for iStats.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIcallIstatsTrigger(id string, object SysIcallIstatsTrigger) (*SysIcallIstatsTrigger, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/istatsTrigger/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallIstatsTrigger)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostIcallScript
//
//
// iCall script.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIcallScript(id string, object SysIcallScript) (*SysIcallScript, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/script/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallScript)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostIcmpStat
//
//
// Standard ICMP statistics, including ICMPv4 packets and errors, and ICMPv6 packets and errors..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIcmpStat(id string, object SysIcmpStat) (*SysIcmpStat, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icmpStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcmpStat)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostIpStat
//
//
// Standard IP statistics, including IPv4 and IPv6 packets, fragments, fragments reassembled, and errors..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIpStat(id string, object SysIpStat) (*SysIpStat, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIpStat)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostIpfixDestination
//
//
// IPFIX destination statistics, including Template and Data Record counts.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIpfixDestination(id string, object SysIpfixDestination) (*SysIpfixDestination, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/destination/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIpfixDestination)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostIpfixElement
//
//
// IPFIX element configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIpfixElement(id string, object SysIpfixElement) (*SysIpfixElement, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/element/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIpfixElement)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostIpfixIrules
//
//
// IPFIX iRules statistics, including allocated and outstanding memory.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIpfixIrules(id string, object SysIpfixIrules) (*SysIpfixIrules, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/irules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIpfixIrules)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostIprep
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostIprep(id string, object SysIprep) (*SysIprep, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/iprep/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIprep)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostLicense
//
//
// Manage the system license.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLicense(id string, object SysLicense) (*SysLicense, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/license/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLicense)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostLogConfigDestinationAlertd
//
//
// Forwards messages to the AlertD daemon.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigDestinationAlertd(id string, object SysLogConfigDestinationAlertd) (*SysLogConfigDestinationAlertd, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/alertd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationAlertd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostLogConfigDestinationArcsight
//
//
// Format messages to the ArcSight specification.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigDestinationArcsight(id string, object SysLogConfigDestinationArcsight) (*SysLogConfigDestinationArcsight, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/arcsight/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationArcsight)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostLogConfigDestinationIpfix
//
//
// Formats logs into IPFIX messages and transmits them to a pool of IPFIX Collectors.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigDestinationIpfix(id string, object SysLogConfigDestinationIpfix) (*SysLogConfigDestinationIpfix, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/ipfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationIpfix)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostLogConfigDestinationLocalDatabase
//
//
// Forwards messages to the local database.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigDestinationLocalDatabase(id string, object SysLogConfigDestinationLocalDatabase) (*SysLogConfigDestinationLocalDatabase, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/localDatabase/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationLocalDatabase)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostLogConfigDestinationLocalSyslog
//
//
// Forwards messages to the local Syslog-ng process.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigDestinationLocalSyslog(id string, object SysLogConfigDestinationLocalSyslog) (*SysLogConfigDestinationLocalSyslog, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/localSyslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationLocalSyslog)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostLogConfigDestinationManagementPort
//
//
// Forwards messages to a destination through the management port.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigDestinationManagementPort(id string, object SysLogConfigDestinationManagementPort) (*SysLogConfigDestinationManagementPort, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/managementPort/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationManagementPort)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostLogConfigDestinationRemoteHighSpeedLog
//
//
// Forwards messages to a pool.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigDestinationRemoteHighSpeedLog(id string, object SysLogConfigDestinationRemoteHighSpeedLog) (*SysLogConfigDestinationRemoteHighSpeedLog, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteHighSpeedLog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationRemoteHighSpeedLog)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostLogConfigDestinationRemoteSyslog
//
//
// Format messages to the Syslog format for remote logging.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigDestinationRemoteSyslog(id string, object SysLogConfigDestinationRemoteSyslog) (*SysLogConfigDestinationRemoteSyslog, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteSyslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationRemoteSyslog)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostLogConfigDestinationSplunk
//
//
// Format messages to the Splunk specification.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigDestinationSplunk(id string, object SysLogConfigDestinationSplunk) (*SysLogConfigDestinationSplunk, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/splunk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationSplunk)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostLogConfigFilter
//
//
// Selectively route logs to log publishers.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigFilter(id string, object SysLogConfigFilter) (*SysLogConfigFilter, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/filter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigFilter)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostLogConfigPublisher
//
//
// List of log destinations.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLogConfigPublisher(id string, object SysLogConfigPublisher) (*SysLogConfigPublisher, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/publisher/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigPublisher)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostLtcfgClass
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLtcfgClass(id string, object SysLtcfgClass) (*SysLtcfgClass, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgClass/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLtcfgClass)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostLtcfgClassFields
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLtcfgClassFields(id string, object SysLtcfgClassFields) (*SysLtcfgClassFields, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgClass/fields/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLtcfgClassFields)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostLtcfgInstance
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLtcfgInstance(id string, object SysLtcfgInstance) (*SysLtcfgInstance, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgInstance/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLtcfgInstance)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostLtcfgInstanceFields
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostLtcfgInstanceFields(id string, object SysLtcfgInstanceFields) (*SysLtcfgInstanceFields, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgInstance/fields/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLtcfgInstanceFields)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostManagementIp
//
//
// Management port address configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostManagementIp(id string, object SysManagementIp) (*SysManagementIp, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementIp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysManagementIp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostManagementRoute
//
//
// Route configuration for the management interface.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostManagementRoute(id string, object SysManagementRoute) (*SysManagementRoute, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementRoute/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysManagementRoute)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostNtpRestrict
//
//
// A restrict line in the NTP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostNtpRestrict(id string, object SysNtpRestrict) (*SysNtpRestrict, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ntp/restrict/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysNtpRestrict)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostPerformanceAllStats
//
//
// View or reset all available performance statistics.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostPerformanceAllStats(id string, object SysPerformanceAllStats) (*SysPerformanceAllStats, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/performance/allStats/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPerformanceAllStats)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostPvaTraffic
//
//
// Packet Velocity Acceleration Engine&#39;s (PVA) traffic statistics..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostPvaTraffic(id string, object SysPvaTraffic) (*SysPvaTraffic, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/pvaTraffic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysPvaTraffic)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostRestrictedModule
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostRestrictedModule(id string, object SysRestrictedModule) (*SysRestrictedModule, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/restrictedModule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysRestrictedModule)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostService
//
//
// Controls the BIG-IP system services..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostService(id string, object SysService) (*SysService, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/service/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysService)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostSflowReceiver
//
//
// sFlow receiver configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostSflowReceiver(id string, object SysSflowReceiver) (*SysSflowReceiver, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/receiver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowReceiver)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostSmtpServer
//
//
// SMTP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostSmtpServer(id string, object SysSmtpServer) (*SysSmtpServer, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/smtpServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSmtpServer)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostSnmpCommunities
//
//
// Specifies SNMP community strings and limits them to specific oid subsets..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostSnmpCommunities(id string, object SysSnmpCommunities) (*SysSnmpCommunities, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/communities/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSnmpCommunities)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostSnmpTraps
//
//
// Generic interface for configuring SNMP traps..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostSnmpTraps(id string, object SysSnmpTraps) (*SysSnmpTraps, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/traps/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSnmpTraps)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostSnmpUsers
//
//
// Specifies user account information for use with SNMPv3..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostSnmpUsers(id string, object SysSnmpUsers) (*SysSnmpUsers, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/users/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSnmpUsers)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostSoftwareBlockDeviceHotfix
//
//
// Manage block device hotfix images.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostSoftwareBlockDeviceHotfix(id string, object SysSoftwareBlockDeviceHotfix) (*SysSoftwareBlockDeviceHotfix, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/blockDeviceHotfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareBlockDeviceHotfix)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostSoftwareBlockDeviceImage
//
//
// Manage block device software images.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostSoftwareBlockDeviceImage(id string, object SysSoftwareBlockDeviceImage) (*SysSoftwareBlockDeviceImage, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/blockDeviceImage/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareBlockDeviceImage)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostSoftwareHotfix
//
//
// Manage hotfix images.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostSoftwareHotfix(id string, object SysSoftwareHotfix) (*SysSoftwareHotfix, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/hotfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareHotfix)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostSoftwareImage
//
//
// Manage software images.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostSoftwareImage(id string, object SysSoftwareImage) (*SysSoftwareImage, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/image/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareImage)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostSyncSysFiles
//
//
// Sync System Files.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostSyncSysFiles(id string, object SysSyncSysFiles) (*SysSyncSysFiles, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/syncSysFiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSyncSysFiles)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostTmmTraffic
//
//
// Traffic management statistics, including traffic information, error, and connections redirected..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostTmmTraffic(id string, object SysTmmTraffic) (*SysTmmTraffic, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/tmmTraffic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysTmmTraffic)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostTraffic
//
//
// Global traffic statistics.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostTraffic(id string, object SysTraffic) (*SysTraffic, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/traffic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysTraffic)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostUcs
//
//
// Save and restore configuration from UCS files.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostUcs(id string, object SysUcs) (*SysUcs, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ucs/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysUcs)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PostUrlDbUrlCategory
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PostUrlDbUrlCategory(id string, object SysUrlDbUrlCategory) (*SysUrlDbUrlCategory, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/urlCategory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysUrlDbUrlCategory)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutApplicationAplScript
//
//
// Scripts included by an application template.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutApplicationAplScript(id string, object SysApplicationAplScript) (*SysApplicationAplScript, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/aplScript/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationAplScript)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutApplicationCustomStat
//
//
// Derived iStats.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutApplicationCustomStat(id string, object SysApplicationCustomStat) (*SysApplicationCustomStat, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/customStat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationCustomStat)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutApplicationService
//
//
// Application configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutApplicationService(id string, object SysApplicationService) (*SysApplicationService, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/service/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationService)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutApplicationTemplate
//
//
// Application templates.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutApplicationTemplate(id string, object SysApplicationTemplate) (*SysApplicationTemplate, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/template/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationTemplate)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutApplicationTemplateActions
//
//
// Manage the set of actions associated with an application template..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutApplicationTemplateActions(id string, object SysApplicationTemplateActions) (*SysApplicationTemplateActions, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/application/template/actions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysApplicationTemplateActions)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutAutoscaleGroup
//
//
// Autoscale group information for Amazon Web Services(AWS)..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutAutoscaleGroup(id string, object SysAutoscaleGroup) (*SysAutoscaleGroup, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/autoscaleGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysAutoscaleGroup)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutClock
//
//
// Display the current date and time.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutClock(id string, object SysClock) (*SysClock, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/clock/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysClock)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutCluster
//
//
// Cluster configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutCluster(id string, object SysCluster) (*SysCluster, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/cluster/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCluster)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutConnection
//
//
// Displays or deletes active connections on the BIG-IP system.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutConnection(id string, object SysConnection) (*SysConnection, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/connection/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysConnection)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutConsole
//
//
// Configure the serial console.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutConsole(id string, object SysConsole) (*SysConsole, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/console/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysConsole)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutCryptoClient
//
//
// Crypto client configuration..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutCryptoClient(id string, object SysCryptoClient) (*SysCryptoClient, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/client/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoClient)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutCryptoFipsExternalHsm
//
//
// FIPS external hsm specific configuration..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutCryptoFipsExternalHsm(id string, object SysCryptoFipsExternalHsm) (*SysCryptoFipsExternalHsm, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/fips/externalHsm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoFipsExternalHsm)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutCryptoMasterKey
//
//
// Displays internal encryption key information on a system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutCryptoMasterKey(id string, object SysCryptoMasterKey) (*SysCryptoMasterKey, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/masterKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoMasterKey)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutCryptoServer
//
//
// Crypto server configuration..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutCryptoServer(id string, object SysCryptoServer) (*SysCryptoServer, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/crypto/server/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysCryptoServer)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutDaemonHa
//
//
// System daemon HA configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDaemonHa(id string, object SysDaemonHa) (*SysDaemonHa, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonHa/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonHa)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutDaemonLogSettingsClusterd
//
//
// The clusterd daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDaemonLogSettingsClusterd(id string, object SysDaemonLogSettingsClusterd) (*SysDaemonLogSettingsClusterd, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/clusterd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsClusterd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutDaemonLogSettingsCsyncd
//
//
// The csyncd daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDaemonLogSettingsCsyncd(id string, object SysDaemonLogSettingsCsyncd) (*SysDaemonLogSettingsCsyncd, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/csyncd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsCsyncd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutDaemonLogSettingsIcrd
//
//
// The icrd daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDaemonLogSettingsIcrd(id string, object SysDaemonLogSettingsIcrd) (*SysDaemonLogSettingsIcrd, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/icrd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsIcrd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutDaemonLogSettingsLind
//
//
// The lind daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDaemonLogSettingsLind(id string, object SysDaemonLogSettingsLind) (*SysDaemonLogSettingsLind, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/lind/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsLind)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutDaemonLogSettingsMcpd
//
//
// The mcpd daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDaemonLogSettingsMcpd(id string, object SysDaemonLogSettingsMcpd) (*SysDaemonLogSettingsMcpd, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/mcpd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsMcpd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutDaemonLogSettingsTmm
//
//
// The tmm daemon configuration on the system..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDaemonLogSettingsTmm(id string, object SysDaemonLogSettingsTmm) (*SysDaemonLogSettingsTmm, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/daemonLogSettings/tmm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDaemonLogSettingsTmm)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutDatastor
//
//
// Optimization data storage configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDatastor(id string, object SysDatastor) (*SysDatastor, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/datastor/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDatastor)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutDb
//
//
// General system properties.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDb(id string, object SysDb) (*SysDb, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/db/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDb)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutDiskDirectory
//
//
// System directory resize operations..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDiskDirectory(id string, object SysDiskDirectory) (*SysDiskDirectory, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/directory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDiskDirectory)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutDiskLogicalDisk
//
//
// Logical Disk Configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDiskLogicalDisk(id string, object SysDiskLogicalDisk) (*SysDiskLogicalDisk, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/disk/logicalDisk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDiskLogicalDisk)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutDns
//
//
// DNS configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutDns(id string, object SysDns) (*SysDns, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/dns/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysDns)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutEcmCloudProvider
//
//
// Describes the properties of all the cloud-providers.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutEcmCloudProvider(id string, object SysEcmCloudProvider) (*SysEcmCloudProvider, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/cloudProvider/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysEcmCloudProvider)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutEcmConfig
//
//
// Specifies the ecm configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutEcmConfig(id string, object SysEcmConfig) (*SysEcmConfig, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ecm/config/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysEcmConfig)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutFeatureModule
//
//
// Feature module configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFeatureModule(id string, object SysFeatureModule) (*SysFeatureModule, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/featureModule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFeatureModule)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutFileApacheSslCert
//
//
// SSL certificates management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFileApacheSslCert(id string, object SysFileApacheSslCert) (*SysFileApacheSslCert, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/apacheSslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileApacheSslCert)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutFileDashboardViewset
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFileDashboardViewset(id string, object SysFileDashboardViewset) (*SysFileDashboardViewset, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dashboardViewset/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileDashboardViewset)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutFileDataGroup
//
//
// External Data Group files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFileDataGroup(id string, object SysFileDataGroup) (*SysFileDataGroup, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/dataGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileDataGroup)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutFileDeviceCapabilitiesDb
//
//
// Device capabilities DB file management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFileDeviceCapabilitiesDb(id string, object SysFileDeviceCapabilitiesDb) (*SysFileDeviceCapabilitiesDb, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/deviceCapabilitiesDb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileDeviceCapabilitiesDb)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutFileExternalMonitor
//
//
// External Monitor files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFileExternalMonitor(id string, object SysFileExternalMonitor) (*SysFileExternalMonitor, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/externalMonitor/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileExternalMonitor)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutFileIfile
//
//
// iFile files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFileIfile(id string, object SysFileIfile) (*SysFileIfile, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/ifile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileIfile)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutFileSslCert
//
//
// SSL certificates management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFileSslCert(id string, object SysFileSslCert) (*SysFileSslCert, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCert/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslCert)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutFileSslCrl
//
//
// SSL CRL files management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFileSslCrl(id string, object SysFileSslCrl) (*SysFileSslCrl, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCrl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslCrl)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutFileSslCsr
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFileSslCsr(id string, object SysFileSslCsr) (*SysFileSslCsr, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslCsr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslCsr)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutFileSslKey
//
//
// SSL certificate keys management.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFileSslKey(id string, object SysFileSslKey) (*SysFileSslKey, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/file/sslKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFileSslKey)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutFixConnection
//
//
// FIX connection level stats.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFixConnection(id string, object SysFixConnection) (*SysFixConnection, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fixConnection/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFixConnection)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutFolder
//
//
// Folder configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFolder(id string, object SysFolder) (*SysFolder, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/folder/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFolder)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutFpgaFirmwareConfig
//
//
// The current FPGA firmware configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutFpgaFirmwareConfig(id string, object SysFpgaFirmwareConfig) (*SysFpgaFirmwareConfig, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/fpga/firmwareConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysFpgaFirmwareConfig)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutGlobalSettings
//
//
// General system settings.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutGlobalSettings(id string, object SysGlobalSettings) (*SysGlobalSettings, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/globalSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysGlobalSettings)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutHaGroup
//
//
// Specifies the ha group used to calculate the failover score..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutHaGroup(id string, object SysHaGroup) (*SysHaGroup, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/haGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysHaGroup)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutHttpd
//
//
// HTTPD configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutHttpd(id string, object SysHttpd) (*SysHttpd, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/httpd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysHttpd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutIcallHandlerPeriodic
//
//
// iCall periodic handler.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutIcallHandlerPeriodic(id string, object SysIcallHandlerPeriodic) (*SysIcallHandlerPeriodic, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/periodic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerPeriodic)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutIcallHandlerPerpetual
//
//
// iCall perpetual handler.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutIcallHandlerPerpetual(id string, object SysIcallHandlerPerpetual) (*SysIcallHandlerPerpetual, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerPerpetual)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutIcallHandlerPerpetualSubscriptions
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutIcallHandlerPerpetualSubscriptions(id string, object SysIcallHandlerPerpetualSubscriptions) (*SysIcallHandlerPerpetualSubscriptions, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/perpetual/subscriptions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerPerpetualSubscriptions)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutIcallHandlerTriggered
//
//
// iCall event-triggered event handler.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutIcallHandlerTriggered(id string, object SysIcallHandlerTriggered) (*SysIcallHandlerTriggered, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerTriggered)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutIcallHandlerTriggeredSubscriptions
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutIcallHandlerTriggeredSubscriptions(id string, object SysIcallHandlerTriggeredSubscriptions) (*SysIcallHandlerTriggeredSubscriptions, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/handler/triggered/subscriptions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallHandlerTriggeredSubscriptions)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutIcallIstatsTrigger
//
//
// Event trigger for iStats.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutIcallIstatsTrigger(id string, object SysIcallIstatsTrigger) (*SysIcallIstatsTrigger, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/istatsTrigger/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallIstatsTrigger)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutIcallScript
//
//
// iCall script.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutIcallScript(id string, object SysIcallScript) (*SysIcallScript, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icall/script/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcallScript)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutIcontrolSoap
//
//
// iControl SOAP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutIcontrolSoap(id string, object SysIcontrolSoap) (*SysIcontrolSoap, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/icontrolSoap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIcontrolSoap)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutIpfixElement
//
//
// IPFIX element configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutIpfixElement(id string, object SysIpfixElement) (*SysIpfixElement, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ipfix/element/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysIpfixElement)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutLogConfigDestinationAlertd
//
//
// Forwards messages to the AlertD daemon.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigDestinationAlertd(id string, object SysLogConfigDestinationAlertd) (*SysLogConfigDestinationAlertd, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/alertd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationAlertd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutLogConfigDestinationArcsight
//
//
// Format messages to the ArcSight specification.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigDestinationArcsight(id string, object SysLogConfigDestinationArcsight) (*SysLogConfigDestinationArcsight, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/arcsight/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationArcsight)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutLogConfigDestinationIpfix
//
//
// Formats logs into IPFIX messages and transmits them to a pool of IPFIX Collectors.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigDestinationIpfix(id string, object SysLogConfigDestinationIpfix) (*SysLogConfigDestinationIpfix, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/ipfix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationIpfix)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutLogConfigDestinationLocalDatabase
//
//
// Forwards messages to the local database.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigDestinationLocalDatabase(id string, object SysLogConfigDestinationLocalDatabase) (*SysLogConfigDestinationLocalDatabase, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/localDatabase/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationLocalDatabase)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutLogConfigDestinationLocalSyslog
//
//
// Forwards messages to the local Syslog-ng process.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigDestinationLocalSyslog(id string, object SysLogConfigDestinationLocalSyslog) (*SysLogConfigDestinationLocalSyslog, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/localSyslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationLocalSyslog)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutLogConfigDestinationManagementPort
//
//
// Forwards messages to a destination through the management port.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigDestinationManagementPort(id string, object SysLogConfigDestinationManagementPort) (*SysLogConfigDestinationManagementPort, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/managementPort/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationManagementPort)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutLogConfigDestinationRemoteHighSpeedLog
//
//
// Forwards messages to a pool.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigDestinationRemoteHighSpeedLog(id string, object SysLogConfigDestinationRemoteHighSpeedLog) (*SysLogConfigDestinationRemoteHighSpeedLog, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteHighSpeedLog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationRemoteHighSpeedLog)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutLogConfigDestinationRemoteSyslog
//
//
// Format messages to the Syslog format for remote logging.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigDestinationRemoteSyslog(id string, object SysLogConfigDestinationRemoteSyslog) (*SysLogConfigDestinationRemoteSyslog, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/remoteSyslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationRemoteSyslog)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutLogConfigDestinationSplunk
//
//
// Format messages to the Splunk specification.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigDestinationSplunk(id string, object SysLogConfigDestinationSplunk) (*SysLogConfigDestinationSplunk, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/destination/splunk/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigDestinationSplunk)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutLogConfigFilter
//
//
// Selectively route logs to log publishers.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigFilter(id string, object SysLogConfigFilter) (*SysLogConfigFilter, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/filter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigFilter)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutLogConfigPublisher
//
//
// List of log destinations.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogConfigPublisher(id string, object SysLogConfigPublisher) (*SysLogConfigPublisher, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logConfig/publisher/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogConfigPublisher)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutLogRotate
//
//
// Log rotation configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLogRotate(id string, object SysLogRotate) (*SysLogRotate, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/logRotate/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLogRotate)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutLtcfgClassFields
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLtcfgClassFields(id string, object SysLtcfgClassFields) (*SysLtcfgClassFields, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgClass/fields/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLtcfgClassFields)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutLtcfgInstanceFields
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutLtcfgInstanceFields(id string, object SysLtcfgInstanceFields) (*SysLtcfgInstanceFields, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ltcfgInstance/fields/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysLtcfgInstanceFields)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutManagementDhcp
//
//
// DHCP configuration for the management interface.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutManagementDhcp(id string, object SysManagementDhcp) (*SysManagementDhcp, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementDhcp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysManagementDhcp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutManagementIp
//
//
// Management port address configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutManagementIp(id string, object SysManagementIp) (*SysManagementIp, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementIp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysManagementIp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutManagementOvsdb
//
//
// OVSDB configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutManagementOvsdb(id string, object SysManagementOvsdb) (*SysManagementOvsdb, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementOvsdb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysManagementOvsdb)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutManagementRoute
//
//
// Route configuration for the management interface.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutManagementRoute(id string, object SysManagementRoute) (*SysManagementRoute, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/managementRoute/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysManagementRoute)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutNtp
//
//
// NTP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutNtp(id string, object SysNtp) (*SysNtp, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ntp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysNtp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutNtpRestrict
//
//
// A restrict line in the NTP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutNtpRestrict(id string, object SysNtpRestrict) (*SysNtpRestrict, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/ntp/restrict/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysNtpRestrict)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutOutboundSmtp
//
//
// Configuration for outbound email sent by the TMOS system.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutOutboundSmtp(id string, object SysOutboundSmtp) (*SysOutboundSmtp, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/outboundSmtp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysOutboundSmtp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutProvision
//
//
// Module resource configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutProvision(id string, object SysProvision) (*SysProvision, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/provision/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysProvision)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutRaidArray
//
//
// Manage the disk array.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutRaidArray(id string, object SysRaidArray) (*SysRaidArray, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/array/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysRaidArray)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutRaidBay
//
//
// Manage drive bays.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutRaidBay(id string, object SysRaidBay) (*SysRaidBay, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/raid/bay/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysRaidBay)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutScriptd
//
//
// scriptd daemon configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutScriptd(id string, object SysScriptd) (*SysScriptd, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/scriptd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysScriptd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutService
//
//
// Controls the BIG-IP system services..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutService(id string, object SysService) (*SysService, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/service/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysService)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutSflowGlobalSettingsHttp
//
//
// Global HTTP sFlow configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSflowGlobalSettingsHttp(id string, object SysSflowGlobalSettingsHttp) (*SysSflowGlobalSettingsHttp, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/http/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowGlobalSettingsHttp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutSflowGlobalSettingsSystem
//
//
// Global system sFlow configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSflowGlobalSettingsSystem(id string, object SysSflowGlobalSettingsSystem) (*SysSflowGlobalSettingsSystem, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/system/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowGlobalSettingsSystem)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutSflowGlobalSettingsTmInterface
//
//
// Global sFlow configuration for interfaces.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSflowGlobalSettingsTmInterface(id string, object SysSflowGlobalSettingsTmInterface) (*SysSflowGlobalSettingsTmInterface, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/tmInterface/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowGlobalSettingsTmInterface)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutSflowGlobalSettingsVlan
//
//
// Global sFlow configuration for VLANs.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSflowGlobalSettingsVlan(id string, object SysSflowGlobalSettingsVlan) (*SysSflowGlobalSettingsVlan, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/globalSettings/vlan/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowGlobalSettingsVlan)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutSflowReceiver
//
//
// sFlow receiver configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSflowReceiver(id string, object SysSflowReceiver) (*SysSflowReceiver, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sflow/receiver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSflowReceiver)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutSmtpServer
//
//
// SMTP configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSmtpServer(id string, object SysSmtpServer) (*SysSmtpServer, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/smtpServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSmtpServer)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutSnmp
//
//
// SNMP agent config.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSnmp(id string, object SysSnmp) (*SysSnmp, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSnmp)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutSnmpCommunities
//
//
// Specifies SNMP community strings and limits them to specific oid subsets..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSnmpCommunities(id string, object SysSnmpCommunities) (*SysSnmpCommunities, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/communities/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSnmpCommunities)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutSnmpTraps
//
//
// Generic interface for configuring SNMP traps..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSnmpTraps(id string, object SysSnmpTraps) (*SysSnmpTraps, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/traps/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSnmpTraps)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutSnmpUsers
//
//
// Specifies user account information for use with SNMPv3..
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSnmpUsers(id string, object SysSnmpUsers) (*SysSnmpUsers, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/snmp/users/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSnmpUsers)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutSoftwareUpdate
//
//
// Manage software update checking.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSoftwareUpdate(id string, object SysSoftwareUpdate) (*SysSoftwareUpdate, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/software/update/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSoftwareUpdate)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutSshd
//
//
// SSHD configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSshd(id string, object SysSshd) (*SysSshd, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/sshd/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSshd)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutStateMirroring
//
//
// Redundant system connection mirroring configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutStateMirroring(id string, object SysStateMirroring) (*SysStateMirroring, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/stateMirroring/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysStateMirroring)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutSyslog
//
//
// System logging configuration.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutSyslog(id string, object SysSyslog) (*SysSyslog, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/syslog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysSyslog)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutUrlDbDownloadSchedule
//
//
// URL Database Download Schedule.
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutUrlDbDownloadSchedule(id string, object SysUrlDbDownloadSchedule) (*SysUrlDbDownloadSchedule, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/downloadSchedule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysUrlDbDownloadSchedule)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}

// PutUrlDbUrlCategory
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a SysApi) PutUrlDbUrlCategory(id string, object SysUrlDbUrlCategory) (*SysUrlDbUrlCategory, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/sys/urlDb/urlCategory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication '(token)' required
	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")
	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	var successPayload = new(SysUrlDbUrlCategory)
	if err == nil && httpResponse.StatusCode() == 200 {
		err = json.Unmarshal(httpResponse.Body(), &successPayload)
	}
	err = NewAPIResponse(httpResponse, err)
	if err != nil {
		return nil, err
	} else {
		return successPayload, err
	}

}
