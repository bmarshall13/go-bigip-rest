/*
 * BigIP iControl REST
 *
 * REST API for F5 BigIP. List of operations is not complete, nor known to be accurate.
 *
 * OpenAPI spec version: 12.0
 *
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package f5api

import (
	"errors"
	"fmt"
	"net/url"
	"strings"

	"encoding/json"
)

// This class holds all the API methods for the Ltm API sub tree
type LtmApi struct {
	configuration *configuration
}

func unused_import_hack_LtmApi() {
	strings.Replace("a", "a", fmt.Sprintf("%v", nil), -1)
}

// DeleteAlgLogProfile
//
//
// Defines the configuration for logging of ALG flows..
//
// id is for ID of the resource.
func (a LtmApi) DeleteAlgLogProfile(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/algLogProfile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteAlgLogProfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteAuthCrldpServer
//
//
// Certificate Revocation List Distribution Point (CRDLP) server configuration, for use with a CRLDP authentication profile.
//
// id is for ID of the resource.
func (a LtmApi) DeleteAuthCrldpServer(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/crldpServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteAuthCrldpServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteAuthKerberosDelegation
//
//
// Kerberos configuration for remote client authentication.
//
// id is for ID of the resource.
func (a LtmApi) DeleteAuthKerberosDelegation(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/kerberosDelegation/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteAuthKerberosDelegation")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteAuthLdap
//
//
// LDAP configuration for remote LDAP client authentication.
//
// id is for ID of the resource.
func (a LtmApi) DeleteAuthLdap(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/ldap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteAuthLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteAuthOcspResponder
//
//
// Online Certificate System Protocol (OCSP) responder configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteAuthOcspResponder(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/ocspResponder/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteAuthOcspResponder")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteAuthProfile
//
//
// Virtual server traffic Authentication profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteAuthProfile(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/profile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteAuthProfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteAuthRadius
//
//
// RADIUS configuration for remote RADIUS client authentication.
//
// id is for ID of the resource.
func (a LtmApi) DeleteAuthRadius(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/radius/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteAuthRadius")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteAuthRadiusServer
//
//
// RADIUS server configuration for use with RADIUS authentication profiles.
//
// id is for ID of the resource.
func (a LtmApi) DeleteAuthRadiusServer(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/radiusServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteAuthRadiusServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteAuthSslCcLdap
//
//
// SSL client certificate configuration, for use with remote SSL-based LDAP authorization.
//
// id is for ID of the resource.
func (a LtmApi) DeleteAuthSslCcLdap(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/sslCcLdap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteAuthSslCcLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteAuthSslCrldp
//
//
// SSL client certificate configuration, for use with remote SSL-based CRLDP authorization.
//
// id is for ID of the resource.
func (a LtmApi) DeleteAuthSslCrldp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/sslCrldp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteAuthSslCrldp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteAuthSslOcsp
//
//
// OCSP configuration for implementing remote OCSP-based client authentication.
//
// id is for ID of the resource.
func (a LtmApi) DeleteAuthSslOcsp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/sslOcsp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteAuthSslOcsp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteAuthTacacs
//
//
// TACACS+ configuration for remote TACACS+ client authentication.
//
// id is for ID of the resource.
func (a LtmApi) DeleteAuthTacacs(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/tacacs/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteAuthTacacs")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteClassificationApplication
//
//
// Traffic Classification Application.
//
// id is for ID of the resource.
func (a LtmApi) DeleteClassificationApplication(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/application/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteClassificationApplication")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteClassificationCategory
//
//
// Traffic Classification Category.
//
// id is for ID of the resource.
func (a LtmApi) DeleteClassificationCategory(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/category/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteClassificationCategory")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteClassificationUrlCatPolicy
//
//
// URL Categorization policy.
//
// id is for ID of the resource.
func (a LtmApi) DeleteClassificationUrlCatPolicy(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urlCatPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteClassificationUrlCatPolicy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteClassificationUrlCategory
//
//
// URL Classification Category.
//
// id is for ID of the resource.
func (a LtmApi) DeleteClassificationUrlCategory(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urlCategory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteClassificationUrlCategory")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteClassificationUrldbFeedList
//
//
// Reusable URLDB feed lists for URL Categorization..
//
// id is for ID of the resource.
func (a LtmApi) DeleteClassificationUrldbFeedList(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urldbFeedList/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteClassificationUrldbFeedList")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteClassificationUrldbFile
//
//
// File object for custom url category database..
//
// id is for ID of the resource.
func (a LtmApi) DeleteClassificationUrldbFile(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urldbFile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteClassificationUrldbFile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteClientsslOcspStaplingResponses
//
//
// Deletes the cached OCSP responses..
//
// id is for ID of the resource.
func (a LtmApi) DeleteClientsslOcspStaplingResponses(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/clientssl/ocspStaplingResponses/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteClientsslOcspStaplingResponses")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteClientsslProxyCachedCerts
//
//
// Displays or deletes SSL Forward Proxy cached certificates.
//
// id is for ID of the resource.
func (a LtmApi) DeleteClientsslProxyCachedCerts(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/clientsslProxy/cachedCerts/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteClientsslProxyCachedCerts")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteDataGroupExternal
//
//
// External data group configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteDataGroupExternal(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dataGroup/external/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteDataGroupExternal")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteDataGroupInternal
//
//
// Internal data group configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteDataGroupInternal(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dataGroup/internal/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteDataGroupInternal")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteDnsCacheRecordsKey
//
//
// DNS Cache DNSKEY cache entries..
//
// id is for ID of the resource.
func (a LtmApi) DeleteDnsCacheRecordsKey(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/records/key/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteDnsCacheRecordsKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteDnsCacheRecordsMsg
//
//
// DNS Cache message cache entries (i.e. complete DNS messages)..
//
// id is for ID of the resource.
func (a LtmApi) DeleteDnsCacheRecordsMsg(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/records/msg/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteDnsCacheRecordsMsg")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteDnsCacheRecordsNameserver
//
//
// DNS Cache Nameserver entries.
//
// id is for ID of the resource.
func (a LtmApi) DeleteDnsCacheRecordsNameserver(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/records/nameserver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteDnsCacheRecordsNameserver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteDnsCacheRecordsRrset
//
//
// DNS Cache Resource Record entries.
//
// id is for ID of the resource.
func (a LtmApi) DeleteDnsCacheRecordsRrset(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/records/rrset/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteDnsCacheRecordsRrset")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteDnsCacheResolver
//
//
// DNS Cache with recursive resolver..
//
// id is for ID of the resource.
func (a LtmApi) DeleteDnsCacheResolver(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/resolver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteDnsCacheResolver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteDnsCacheTransparent
//
//
// DNS Cache without a resolver (responses from serverside cached)..
//
// id is for ID of the resource.
func (a LtmApi) DeleteDnsCacheTransparent(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/transparent/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteDnsCacheTransparent")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteDnsCacheValidatingResolver
//
//
// DNS Cache with recursive resolver and DNSSEC validation..
//
// id is for ID of the resource.
func (a LtmApi) DeleteDnsCacheValidatingResolver(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/validatingResolver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteDnsCacheValidatingResolver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteDnsDnssecKey
//
//
// DNSSEC key configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteDnsDnssecKey(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/dnssec/key/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteDnsDnssecKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteDnsDnssecZone
//
//
// DNSSEC zone configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteDnsDnssecZone(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/dnssec/zone/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteDnsDnssecZone")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteDnsNameserver
//
//
// DNS nameserver configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteDnsNameserver(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/nameserver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteDnsNameserver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteDnsTsigKey
//
//
// TSIG Key configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteDnsTsigKey(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/tsigKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteDnsTsigKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteDnsZone
//
//
// Zone configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteDnsZone(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/zone/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteDnsZone")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteEvictionPolicy
//
//
// Defines an eviction policy, used to select which flows to evict when approaching limits..
//
// id is for ID of the resource.
func (a LtmApi) DeleteEvictionPolicy(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/evictionPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteEvictionPolicy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteHtmlRuleCommentRaiseEvent
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) DeleteHtmlRuleCommentRaiseEvent(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/commentRaiseEvent/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteHtmlRuleCommentRaiseEvent")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteHtmlRuleCommentRemove
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) DeleteHtmlRuleCommentRemove(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/commentRemove/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteHtmlRuleCommentRemove")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteHtmlRuleTagAppendHtml
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) DeleteHtmlRuleTagAppendHtml(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagAppendHtml/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteHtmlRuleTagAppendHtml")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteHtmlRuleTagPrependHtml
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) DeleteHtmlRuleTagPrependHtml(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagPrependHtml/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteHtmlRuleTagPrependHtml")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteHtmlRuleTagRaiseEvent
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) DeleteHtmlRuleTagRaiseEvent(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagRaiseEvent/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteHtmlRuleTagRaiseEvent")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteHtmlRuleTagRemove
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) DeleteHtmlRuleTagRemove(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagRemove/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteHtmlRuleTagRemove")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteHtmlRuleTagRemoveAttribute
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) DeleteHtmlRuleTagRemoveAttribute(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagRemoveAttribute/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteHtmlRuleTagRemoveAttribute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteIfile
//
//
// iFile Configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteIfile(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/ifile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteIfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteLsnLogProfile
//
//
// Defines the configuration for logging of LSN flows..
//
// id is for ID of the resource.
func (a LtmApi) DeleteLsnLogProfile(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/lsnLogProfile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteLsnLogProfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteLsnPool
//
//
// LSNAT/CGNAT translation address configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteLsnPool(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/lsnPool/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteLsnPool")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMessageRoutingDiameterPeer
//
//
// Peed for routing generic message protocol messages..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMessageRoutingDiameterPeer(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/peer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMessageRoutingDiameterPeer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMessageRoutingDiameterProfileRouter
//
//
// Configures a Diameter Router profile..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMessageRoutingDiameterProfileRouter(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/profile/router/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMessageRoutingDiameterProfileRouter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMessageRoutingDiameterProfileSession
//
//
// Configures a Diameter Session profile..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMessageRoutingDiameterProfileSession(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/profile/session/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMessageRoutingDiameterProfileSession")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMessageRoutingDiameterRoute
//
//
// Configures a static route for use in Diameter message routing..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMessageRoutingDiameterRoute(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/route/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMessageRoutingDiameterRoute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMessageRoutingDiameterTransportConfig
//
//
// Defines the configuration for an outgoing connection..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMessageRoutingDiameterTransportConfig(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/transportConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMessageRoutingDiameterTransportConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMessageRoutingDiameterTransportConfigProfiles
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) DeleteMessageRoutingDiameterTransportConfigProfiles(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/transportConfig/profiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMessageRoutingDiameterTransportConfigProfiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMessageRoutingGenericPeer
//
//
// Peed for routing generic message protocol messages..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMessageRoutingGenericPeer(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/peer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMessageRoutingGenericPeer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMessageRoutingGenericProtocol
//
//
// Generic message parser for use with the message routing framework..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMessageRoutingGenericProtocol(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/protocol/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMessageRoutingGenericProtocol")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMessageRoutingGenericRoute
//
//
// Static route for routing generic message protocol messages..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMessageRoutingGenericRoute(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/route/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMessageRoutingGenericRoute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMessageRoutingGenericRouter
//
//
// Message routing instance for generic message protocol..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMessageRoutingGenericRouter(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/router/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMessageRoutingGenericRouter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMessageRoutingGenericTransportConfig
//
//
// Defines the configuration for an outgoing connection..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMessageRoutingGenericTransportConfig(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/transportConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMessageRoutingGenericTransportConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMessageRoutingGenericTransportConfigProfiles
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) DeleteMessageRoutingGenericTransportConfigProfiles(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/transportConfig/profiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMessageRoutingGenericTransportConfigProfiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMessageRoutingSipPeer
//
//
// Peed for routing generic message protocol messages..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMessageRoutingSipPeer(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/peer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMessageRoutingSipPeer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMessageRoutingSipProfileRouter
//
//
// Configures a Session Initiation Protocol (SIP) Router profile..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMessageRoutingSipProfileRouter(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/profile/router/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMessageRoutingSipProfileRouter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMessageRoutingSipProfileSession
//
//
// Configures a Session Initiation Protocol (SIP) Session profile..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMessageRoutingSipProfileSession(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/profile/session/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMessageRoutingSipProfileSession")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMessageRoutingSipRoute
//
//
// Configures a static route for use in Session Initiation Protocol (SIP) message routing..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMessageRoutingSipRoute(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/route/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMessageRoutingSipRoute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMessageRoutingSipTransportConfig
//
//
// Defines the configuration for an outgoing connection..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMessageRoutingSipTransportConfig(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/transportConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMessageRoutingSipTransportConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMessageRoutingSipTransportConfigProfiles
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) DeleteMessageRoutingSipTransportConfigProfiles(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/transportConfig/profiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMessageRoutingSipTransportConfigProfiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorDiameter
//
//
// Diameter monitor configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorDiameter(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/diameter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorDiameter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorDns
//
//
// DNS monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorDns(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/dns/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorDns")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorExternal
//
//
// External monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorExternal(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/external/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorExternal")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorFirepass
//
//
// Firepass monitor configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorFirepass(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/firepass/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorFirepass")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorFtp
//
//
// FTP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorFtp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/ftp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorFtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorGatewayIcmp
//
//
// Gateway ICMP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorGatewayIcmp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/gatewayIcmp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorGatewayIcmp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorHttp
//
//
// HTTP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorHttp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/http/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorHttp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorHttps
//
//
// HTTPS monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorHttps(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/https/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorHttps")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorIcmp
//
//
// ICMP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorIcmp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/icmp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorIcmp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorImap
//
//
// IMAP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorImap(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/imap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorImap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorInband
//
//
// Inband monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorInband(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/inband/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorInband")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorLdap
//
//
// LDAP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorLdap(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/ldap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorModuleScore
//
//
// Module score monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorModuleScore(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/moduleScore/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorModuleScore")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorMssql
//
//
// MSSQL monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorMssql(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/mssql/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorMssql")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorMysql
//
//
// MySQL monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorMysql(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/mysql/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorMysql")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorNntp
//
//
// NNTP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorNntp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/nntp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorNntp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorNone
//
//
// The NULL monitor..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorNone(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/none/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorNone")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorOracle
//
//
// Oracle monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorOracle(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/oracle/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorOracle")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorPop3
//
//
// POP3 monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorPop3(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/pop3/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorPop3")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorPostgresql
//
//
// Postgresql monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorPostgresql(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/postgresql/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorPostgresql")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorRadius
//
//
// Radius monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorRadius(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/radius/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorRadius")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorRadiusAccounting
//
//
// Radius accounting monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorRadiusAccounting(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/radiusAccounting/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorRadiusAccounting")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorRealServer
//
//
// Real Server monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorRealServer(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/realServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorRealServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorRpc
//
//
// RPC monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorRpc(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/rpc/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorRpc")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorSasp
//
//
// SASP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorSasp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/sasp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorSasp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorScripted
//
//
// Scripted monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorScripted(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/scripted/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorScripted")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorSip
//
//
// SIP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorSip(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/sip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorSip")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorSmb
//
//
// SMB monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorSmb(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/smb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorSmb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorSmtp
//
//
// SMTP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorSmtp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/smtp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorSmtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorSnmpDca
//
//
// SNMP DCA monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorSnmpDca(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/snmpDca/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorSnmpDca")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorSnmpDcaBase
//
//
// SNMP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorSnmpDcaBase(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/snmpDcaBase/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorSnmpDcaBase")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorSoap
//
//
// SOAP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorSoap(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/soap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorSoap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorTcp
//
//
// TCP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorTcp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/tcp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorTcp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorTcpEcho
//
//
// TCP Echo monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorTcpEcho(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/tcpEcho/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorTcpEcho")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorTcpHalfOpen
//
//
// TCP Half Open monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorTcpHalfOpen(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/tcpHalfOpen/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorTcpHalfOpen")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorUdp
//
//
// UDP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorUdp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/udp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorUdp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorVirtualLocation
//
//
// Virtual Location monitor configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorVirtualLocation(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/virtualLocation/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorVirtualLocation")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorWap
//
//
// WAP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorWap(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/wap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorWap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteMonitorWmi
//
//
// WMI monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteMonitorWmi(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/wmi/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteMonitorWmi")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteNat
//
//
// Network address translation configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteNat(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/nat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteNat")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteNode
//
//
// Node specific pool member configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteNode(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/node/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteNode")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeletePersistenceCookie
//
//
// Virtual server Cookie persistence profile.
//
// id is for ID of the resource.
func (a LtmApi) DeletePersistenceCookie(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/cookie/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeletePersistenceCookie")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeletePersistenceDestAddr
//
//
// Virtual server Destination Address Affinity persistence profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeletePersistenceDestAddr(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/destAddr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeletePersistenceDestAddr")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeletePersistenceHash
//
//
// Virtual server Hash persistence profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeletePersistenceHash(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/hash/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeletePersistenceHash")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeletePersistenceMsrdp
//
//
// Virtual server Microsoft Remote Desktop (MSRDP) persistence profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeletePersistenceMsrdp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/msrdp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeletePersistenceMsrdp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeletePersistencePersistRecords
//
//
// Displays or delete records in the persistence table..
//
// id is for ID of the resource.
func (a LtmApi) DeletePersistencePersistRecords(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/persistRecords/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeletePersistencePersistRecords")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeletePersistenceSip
//
//
// Virtual server SIP persistence profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeletePersistenceSip(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/sip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeletePersistenceSip")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeletePersistenceSourceAddr
//
//
// Virtual server Source Address persistence profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeletePersistenceSourceAddr(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/sourceAddr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeletePersistenceSourceAddr")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeletePersistenceSsl
//
//
// Virtual server SSL persistence profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeletePersistenceSsl(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/ssl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeletePersistenceSsl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeletePersistenceUniversal
//
//
// Virtual server Universal persistence profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeletePersistenceUniversal(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/universal/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeletePersistenceUniversal")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeletePolicy
//
//
// Centralized Policy Matching configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeletePolicy(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeletePolicy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeletePolicyRules
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) DeletePolicyRules(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/rules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeletePolicyRules")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeletePolicyRulesActions
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) DeletePolicyRulesActions(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/rules/actions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeletePolicyRulesActions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeletePolicyRulesConditions
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) DeletePolicyRulesConditions(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/rules/conditions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeletePolicyRulesConditions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeletePolicyStrategy
//
//
// Centralized Policy Matching rule selection strategy.
//
// id is for ID of the resource.
func (a LtmApi) DeletePolicyStrategy(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policyStrategy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeletePolicyStrategy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeletePolicyStrategyOperands
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) DeletePolicyStrategyOperands(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policyStrategy/operands/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeletePolicyStrategyOperands")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeletePool
//
//
// Load balancing pool configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeletePool(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/pool/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeletePool")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeletePoolMembers
//
//
// Manage the set of pool members that are associated with a load balancing pool.
//
// pid is for ID of the parent resource
//
// id is for ID of the resource.
func (a LtmApi) DeletePoolMembers(pid string, id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/pool/{pid}/members/{id}"
	path = strings.Replace(path, "{"+"pid"+"}", fmt.Sprintf("%v", pid), -1)
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'pid' is set
	if &pid == nil {
		return nil, errors.New("Missing required parameter 'pid' when calling LtmApi->DeletePoolMembers")
	}
	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeletePoolMembers")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileAnalytics
//
//
// Virtual server analytics profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileAnalytics(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/analytics/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileAnalytics")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileAnalyticsAlerts
//
//
// Manage the set of analytics alerts that are associated with an analytics profile..
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileAnalyticsAlerts(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/analytics/alerts/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileAnalyticsAlerts")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileAnalyticsTrafficCapture
//
//
// Manage the set of analytics alerts that are associated with an analytics profile..
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileAnalyticsTrafficCapture(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/analytics/trafficCapture/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileAnalyticsTrafficCapture")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileCertificateAuthority
//
//
// Virtual server Certificate Authority profile configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileCertificateAuthority(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/certificateAuthority/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileCertificateAuthority")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileClientLdap
//
//
// Virtual server Client LDAP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileClientLdap(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/clientLdap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileClientLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileClientSsl
//
//
// Virtual server client-side proxy SSL profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileClientSsl(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/clientSsl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileClientSsl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileDhcpv4
//
//
// Dynamic Host Configuration Protocol, DHCPv4, profile to manage DHCPv4 network traffic..
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileDhcpv4(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dhcpv4/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileDhcpv4")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileDhcpv6
//
//
// Dynamic Host Configuration Protocol, DHCPv6, profile to manage DHCPv6 network traffic..
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileDhcpv6(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dhcpv6/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileDhcpv6")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileDiameter
//
//
// Virtual server Diameter traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileDiameter(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/diameter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileDiameter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileDns
//
//
// Virtual server DNS traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileDns(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dns/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileDns")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileDnsLogging
//
//
// High-speed logging settings for the DNS profile..
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileDnsLogging(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dnsLogging/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileDnsLogging")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileFasthttp
//
//
// Virtual server Fast HTTP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileFasthttp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/fasthttp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileFasthttp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileFastl4
//
//
// Virtual server FastL4 traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileFastl4(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/fastl4/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileFastl4")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileFix
//
//
// Virtual server Financial Information eXchange(FIX) profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileFix(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/fix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileFix")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileFtp
//
//
// Virtual server FTP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileFtp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ftp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileFtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileGtp
//
//
// Virtual server GTP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileGtp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/gtp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileGtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileHtml
//
//
// Virtual server HTML profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileHtml(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/html/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileHtml")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileHttp
//
//
// Virtual server HTTP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileHttp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/http/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileHttp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileHttp2
//
//
// Virtual server HTTP/2 traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileHttp2(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/http2/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileHttp2")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileHttpCompression
//
//
// Virtual server HTTP compression profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileHttpCompression(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/httpCompression/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileHttpCompression")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileIcap
//
//
// Virtual server Internet Content Adaptation Protocol (ICAP) profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileIcap(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/icap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileIcap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileIiop
//
//
// Virtual server IIOP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileIiop(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/iiop/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileIiop")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileIpother
//
//
// Virtual server IPOTHER for non-TCP and non-UDP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileIpother(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ipother/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileIpother")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileMblb
//
//
// MBLB profile configuration (experimental).
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileMblb(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/mblb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileMblb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileMssql
//
//
// Virtual server MSSQL profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileMssql(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/mssql/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileMssql")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileNtlm
//
//
// Virtual server NT Lan Manager profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileNtlm(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ntlm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileNtlm")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileOcspStaplingParams
//
//
// OCSP Stapling Parameters for clientssl profiles. This object should be associated with a cert-key-chain object in a clientssl profile..
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileOcspStaplingParams(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ocspStaplingParams/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileOcspStaplingParams")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileOneConnect
//
//
// Virtual server OneConnect profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileOneConnect(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/oneConnect/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileOneConnect")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfilePcp
//
//
// LSN Pool PCP configuration profile.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfilePcp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/pcp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfilePcp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfilePptp
//
//
// Virtual server Point to Point Tunneling Protocol (PPTP) profile configuration..
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfilePptp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/pptp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfilePptp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileQoe
//
//
// Virtual server Quality of Experience profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileQoe(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/qoe/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileQoe")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileRadius
//
//
// Virtual server Radius traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileRadius(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/radius/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileRadius")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileRamcache
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileRamcache(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ramcache/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileRamcache")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileRequestAdapt
//
//
// Virtual server HTTP request adaptation profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileRequestAdapt(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/requestAdapt/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileRequestAdapt")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileRequestLog
//
//
// Virtual server request logging profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileRequestLog(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/requestLog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileRequestLog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileResponseAdapt
//
//
// Virtual server HTTP response adaptation profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileResponseAdapt(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/responseAdapt/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileResponseAdapt")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileRewrite
//
//
// Virtual server Rewrite profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileRewrite(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/rewrite/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileRewrite")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileRewriteUriRules
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileRewriteUriRules(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/rewrite/uriRules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileRewriteUriRules")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileRtsp
//
//
// Virtual server RTSP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileRtsp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/rtsp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileRtsp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileSctp
//
//
// Virtual server SCTP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileSctp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/sctp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileSctp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileServerLdap
//
//
// Virtual server Server LDAP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileServerLdap(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/serverLdap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileServerLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileServerSsl
//
//
// Virtual server server-side proxy SSL profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileServerSsl(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/serverSsl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileServerSsl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileSip
//
//
// Virtual server SIP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileSip(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/sip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileSip")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileSmtp
//
//
// Virtual server SMTP profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileSmtp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/smtp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileSmtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileSmtps
//
//
// Virtual server SMTPs traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileSmtps(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/smtps/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileSmtps")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileSocks
//
//
// Virtual server SOCKS traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileSocks(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/socks/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileSocks")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileSpdy
//
//
// Virtual server SPDY traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileSpdy(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/spdy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileSpdy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileStatistics
//
//
// Virtual server custom statistics configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileStatistics(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/statistics/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileStatistics")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileStream
//
//
// Virtual server Stream traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileStream(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/stream/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileStream")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileTcp
//
//
// Virtual server TCP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileTcp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/tcp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileTcp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileTftp
//
//
// Virtual server TFTP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileTftp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/tftp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileTftp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileUdp
//
//
// Virtual server UDP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileUdp(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/udp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileUdp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileWaCache
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileWaCache(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/waCache/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileWaCache")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileWebAcceleration
//
//
// Virtual server Web Acceleration profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileWebAcceleration(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/webAcceleration/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileWebAcceleration")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteProfileXml
//
//
// Virtual server XML configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteProfileXml(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/xml/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteProfileXml")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteRule
//
//
// iRules configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteRule(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/rule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteRule")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteSnat
//
//
// Secure network address translation (SNAT) configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteSnat(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/snat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteSnat")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteSnatTranslation
//
//
// SNAT translation address configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteSnatTranslation(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/snatTranslation/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteSnatTranslation")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteSnatpool
//
//
// Collections of SNAT translation addresses.
//
// id is for ID of the resource.
func (a LtmApi) DeleteSnatpool(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/snatpool/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteSnatpool")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteTacdbCustomdb
//
//
// Custom tacdb for detection of device type and OS..
//
// id is for ID of the resource.
func (a LtmApi) DeleteTacdbCustomdb(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/tacdb/customdb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteTacdbCustomdb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteTacdbCustomdbFile
//
//
// File object for custom tacdb. User should NOT use it. Daemon use it internally..
//
// id is for ID of the resource.
func (a LtmApi) DeleteTacdbCustomdbFile(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/tacdb/customdbFile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteTacdbCustomdbFile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteTrafficClass
//
//
// Traffic Class Configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteTrafficClass(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/trafficClass/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteTrafficClass")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteVirtual
//
//
// Virtual server configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteVirtual(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteVirtual")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteVirtualAddress
//
//
// Virtual server IP address configuration.
//
// id is for ID of the resource.
func (a LtmApi) DeleteVirtualAddress(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtualAddress/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteVirtualAddress")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteVirtualPolicies
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) DeleteVirtualPolicies(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/policies/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteVirtualPolicies")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// DeleteVirtualProfiles
//
//
// Manage the set of profiles that are associated with virtual servers.
//
// id is for ID of the resource.
func (a LtmApi) DeleteVirtualProfiles(id string) (*APIResponse, error) {

	var httpMethod = "Delete"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/profiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return nil, errors.New("Missing required parameter 'id' when calling LtmApi->DeleteVirtualProfiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}

	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return NewAPIResponse(httpResponse.RawResponse), err
	}

	return NewAPIResponse(httpResponse.RawResponse), err
}

// GetAlgLogProfile
//
//
// Defines the configuration for logging of ALG flows..
//
// id is for ID of the resource.
func (a LtmApi) GetAlgLogProfile(id string) (*LtmAlgLogProfile, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/algLogProfile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAlgLogProfile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetAlgLogProfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAlgLogProfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAlgLogProfileList
//
//
// Defines the configuration for logging of ALG flows...
func (a LtmApi) GetAlgLogProfileList() (*LtmAlgLogProfileList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/algLogProfile"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAlgLogProfileList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuth
//
//
// Virtual server authentication configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetAuth(id string) (*LtmAuth, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuth), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetAuth")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuth)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthCrldpServer
//
//
// Certificate Revocation List Distribution Point (CRDLP) server configuration, for use with a CRLDP authentication profile.
//
// id is for ID of the resource.
func (a LtmApi) GetAuthCrldpServer(id string) (*LtmAuthCrldpServer, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/crldpServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthCrldpServer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetAuthCrldpServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthCrldpServer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthCrldpServerList
//
//
// Certificate Revocation List Distribution Point (CRDLP) server configuration, for use with a CRLDP authentication profile..
func (a LtmApi) GetAuthCrldpServerList() (*LtmAuthCrldpServerList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/crldpServer"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthCrldpServerList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthKerberosDelegation
//
//
// Kerberos configuration for remote client authentication.
//
// id is for ID of the resource.
func (a LtmApi) GetAuthKerberosDelegation(id string) (*LtmAuthKerberosDelegation, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/kerberosDelegation/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthKerberosDelegation), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetAuthKerberosDelegation")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthKerberosDelegation)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthKerberosDelegationList
//
//
// Kerberos configuration for remote client authentication..
func (a LtmApi) GetAuthKerberosDelegationList() (*LtmAuthKerberosDelegationList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/kerberosDelegation"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthKerberosDelegationList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthLdap
//
//
// LDAP configuration for remote LDAP client authentication.
//
// id is for ID of the resource.
func (a LtmApi) GetAuthLdap(id string) (*LtmAuthLdap, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/ldap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthLdap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetAuthLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthLdap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthLdapList
//
//
// LDAP configuration for remote LDAP client authentication..
func (a LtmApi) GetAuthLdapList() (*LtmAuthLdapList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/ldap"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthLdapList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthList
//
//
// Virtual server authentication configuration..
func (a LtmApi) GetAuthList() (*LtmAuthList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthOcspResponder
//
//
// Online Certificate System Protocol (OCSP) responder configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetAuthOcspResponder(id string) (*LtmAuthOcspResponder, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/ocspResponder/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthOcspResponder), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetAuthOcspResponder")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthOcspResponder)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthOcspResponderList
//
//
// Online Certificate System Protocol (OCSP) responder configuration..
func (a LtmApi) GetAuthOcspResponderList() (*LtmAuthOcspResponderList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/ocspResponder"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthOcspResponderList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthProfile
//
//
// Virtual server traffic Authentication profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetAuthProfile(id string) (*LtmAuthProfile, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/profile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthProfile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetAuthProfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthProfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthProfileList
//
//
// Virtual server traffic Authentication profile configuration..
func (a LtmApi) GetAuthProfileList() (*LtmAuthProfileList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/profile"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthProfileList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthRadius
//
//
// RADIUS configuration for remote RADIUS client authentication.
//
// id is for ID of the resource.
func (a LtmApi) GetAuthRadius(id string) (*LtmAuthRadius, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/radius/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthRadius), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetAuthRadius")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthRadius)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthRadiusList
//
//
// RADIUS configuration for remote RADIUS client authentication..
func (a LtmApi) GetAuthRadiusList() (*LtmAuthRadiusList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/radius"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthRadiusList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthRadiusServer
//
//
// RADIUS server configuration for use with RADIUS authentication profiles.
//
// id is for ID of the resource.
func (a LtmApi) GetAuthRadiusServer(id string) (*LtmAuthRadiusServer, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/radiusServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthRadiusServer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetAuthRadiusServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthRadiusServer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthRadiusServerList
//
//
// RADIUS server configuration for use with RADIUS authentication profiles..
func (a LtmApi) GetAuthRadiusServerList() (*LtmAuthRadiusServerList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/radiusServer"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthRadiusServerList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthSslCcLdap
//
//
// SSL client certificate configuration, for use with remote SSL-based LDAP authorization.
//
// id is for ID of the resource.
func (a LtmApi) GetAuthSslCcLdap(id string) (*LtmAuthSslCcLdap, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/sslCcLdap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthSslCcLdap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetAuthSslCcLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthSslCcLdap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthSslCcLdapList
//
//
// SSL client certificate configuration, for use with remote SSL-based LDAP authorization..
func (a LtmApi) GetAuthSslCcLdapList() (*LtmAuthSslCcLdapList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/sslCcLdap"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthSslCcLdapList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthSslCrldp
//
//
// SSL client certificate configuration, for use with remote SSL-based CRLDP authorization.
//
// id is for ID of the resource.
func (a LtmApi) GetAuthSslCrldp(id string) (*LtmAuthSslCrldp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/sslCrldp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthSslCrldp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetAuthSslCrldp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthSslCrldp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthSslCrldpList
//
//
// SSL client certificate configuration, for use with remote SSL-based CRLDP authorization..
func (a LtmApi) GetAuthSslCrldpList() (*LtmAuthSslCrldpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/sslCrldp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthSslCrldpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthSslOcsp
//
//
// OCSP configuration for implementing remote OCSP-based client authentication.
//
// id is for ID of the resource.
func (a LtmApi) GetAuthSslOcsp(id string) (*LtmAuthSslOcsp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/sslOcsp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthSslOcsp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetAuthSslOcsp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthSslOcsp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthSslOcspList
//
//
// OCSP configuration for implementing remote OCSP-based client authentication..
func (a LtmApi) GetAuthSslOcspList() (*LtmAuthSslOcspList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/sslOcsp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthSslOcspList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthTacacs
//
//
// TACACS+ configuration for remote TACACS+ client authentication.
//
// id is for ID of the resource.
func (a LtmApi) GetAuthTacacs(id string) (*LtmAuthTacacs, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/tacacs/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthTacacs), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetAuthTacacs")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthTacacs)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetAuthTacacsList
//
//
// TACACS+ configuration for remote TACACS+ client authentication..
func (a LtmApi) GetAuthTacacsList() (*LtmAuthTacacsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/tacacs"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmAuthTacacsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassification
//
//
// Traffic Classification.
//
// id is for ID of the resource.
func (a LtmApi) GetClassification(id string) (*LtmClassification, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassification), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetClassification")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassification)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationApplication
//
//
// Traffic Classification Application.
//
// id is for ID of the resource.
func (a LtmApi) GetClassificationApplication(id string) (*LtmClassificationApplication, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/application/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationApplication), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetClassificationApplication")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationApplication)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationApplicationList
//
//
// Traffic Classification Application..
func (a LtmApi) GetClassificationApplicationList() (*LtmClassificationApplicationList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/application"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationApplicationList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationCategory
//
//
// Traffic Classification Category.
//
// id is for ID of the resource.
func (a LtmApi) GetClassificationCategory(id string) (*LtmClassificationCategory, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/category/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationCategory), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetClassificationCategory")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationCategory)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationCategoryList
//
//
// Traffic Classification Category..
func (a LtmApi) GetClassificationCategoryList() (*LtmClassificationCategoryList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/category"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationCategoryList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationList
//
//
// Traffic Classification..
func (a LtmApi) GetClassificationList() (*LtmClassificationList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationSignatureDefinition
//
//
// Configure status for classification signature updates..
//
// id is for ID of the resource.
func (a LtmApi) GetClassificationSignatureDefinition(id string) (*LtmClassificationSignatureDefinition, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/signatureDefinition/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationSignatureDefinition), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetClassificationSignatureDefinition")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationSignatureDefinition)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationSignatureDefinitionList
//
//
// Configure status for classification signature updates...
func (a LtmApi) GetClassificationSignatureDefinitionList() (*LtmClassificationSignatureDefinitionList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/signatureDefinition"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationSignatureDefinitionList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationSignatureUpdateSchedule
//
//
// Configure scheduling for classification signature updates..
//
// id is for ID of the resource.
func (a LtmApi) GetClassificationSignatureUpdateSchedule(id string) (*LtmClassificationSignatureUpdateSchedule, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/signatureUpdateSchedule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationSignatureUpdateSchedule), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetClassificationSignatureUpdateSchedule")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationSignatureUpdateSchedule)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationSignatureUpdateScheduleList
//
//
// Configure scheduling for classification signature updates...
func (a LtmApi) GetClassificationSignatureUpdateScheduleList() (*LtmClassificationSignatureUpdateScheduleList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/signatureUpdateSchedule"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationSignatureUpdateScheduleList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationSignatureVersion
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetClassificationSignatureVersion(id string) (*LtmClassificationSignatureVersion, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/signatureVersion/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationSignatureVersion), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetClassificationSignatureVersion")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationSignatureVersion)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationSignatureVersionList
//
//
// ..
func (a LtmApi) GetClassificationSignatureVersionList() (*LtmClassificationSignatureVersionList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/signatureVersion"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationSignatureVersionList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationSignaturesList
//
//
// Load classification signatures file either from folder /var/log/dpi/signatures/, or from the folder specified in the name of the file...
func (a LtmApi) GetClassificationSignaturesList() (*LtmClassificationSignaturesList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/signatures"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationSignaturesList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationStats
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetClassificationStats(id string) (*LtmClassificationStats, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/stats/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationStats), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetClassificationStats")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationStats)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationStatsApplication
//
//
// Statistics of classified applications.
//
// id is for ID of the resource.
func (a LtmApi) GetClassificationStatsApplication(id string) (*LtmClassificationStatsApplication, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/stats/application/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationStatsApplication), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetClassificationStatsApplication")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationStatsApplication)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationStatsApplicationList
//
//
// Statistics of classified applications..
func (a LtmApi) GetClassificationStatsApplicationList() (*LtmClassificationStatsApplicationList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/stats/application"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationStatsApplicationList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationStatsList
//
//
// ..
func (a LtmApi) GetClassificationStatsList() (*LtmClassificationStatsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/stats"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationStatsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationStatsUrlCategory
//
//
// Statistics of classified url-category.
//
// id is for ID of the resource.
func (a LtmApi) GetClassificationStatsUrlCategory(id string) (*LtmClassificationStatsUrlCategory, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/stats/urlCategory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationStatsUrlCategory), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetClassificationStatsUrlCategory")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationStatsUrlCategory)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationStatsUrlCategoryList
//
//
// Statistics of classified url-category..
func (a LtmApi) GetClassificationStatsUrlCategoryList() (*LtmClassificationStatsUrlCategoryList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/stats/urlCategory"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationStatsUrlCategoryList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationUpdateSignaturesList
//
//
// Run classification signatures update...
func (a LtmApi) GetClassificationUpdateSignaturesList() (*LtmClassificationUpdateSignaturesList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/updateSignatures"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationUpdateSignaturesList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationUrlCatPolicy
//
//
// URL Categorization policy.
//
// id is for ID of the resource.
func (a LtmApi) GetClassificationUrlCatPolicy(id string) (*LtmClassificationUrlCatPolicy, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urlCatPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationUrlCatPolicy), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetClassificationUrlCatPolicy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationUrlCatPolicy)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationUrlCatPolicyList
//
//
// URL Categorization policy..
func (a LtmApi) GetClassificationUrlCatPolicyList() (*LtmClassificationUrlCatPolicyList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urlCatPolicy"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationUrlCatPolicyList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationUrlCategory
//
//
// URL Classification Category.
//
// id is for ID of the resource.
func (a LtmApi) GetClassificationUrlCategory(id string) (*LtmClassificationUrlCategory, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urlCategory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationUrlCategory), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetClassificationUrlCategory")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationUrlCategory)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationUrlCategoryList
//
//
// URL Classification Category..
func (a LtmApi) GetClassificationUrlCategoryList() (*LtmClassificationUrlCategoryList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urlCategory"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationUrlCategoryList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationUrldbFeedList
//
//
// Reusable URLDB feed lists for URL Categorization..
//
// id is for ID of the resource.
func (a LtmApi) GetClassificationUrldbFeedList(id string) (*LtmClassificationUrldbFeedList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urldbFeedList/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationUrldbFeedList), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetClassificationUrldbFeedList")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationUrldbFeedList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationUrldbFeedListList
//
//
// Reusable URLDB feed lists for URL Categorization...
func (a LtmApi) GetClassificationUrldbFeedListList() (*LtmClassificationUrldbFeedListList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urldbFeedList"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationUrldbFeedListList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationUrldbFile
//
//
// File object for custom url category database..
//
// id is for ID of the resource.
func (a LtmApi) GetClassificationUrldbFile(id string) (*LtmClassificationUrldbFile, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urldbFile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationUrldbFile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetClassificationUrldbFile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationUrldbFile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClassificationUrldbFileList
//
//
// File object for custom url category database...
func (a LtmApi) GetClassificationUrldbFileList() (*LtmClassificationUrldbFileList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urldbFile"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClassificationUrldbFileList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClientssl
//
//
// Manages request sent to TMM for SSL specific operations such as deletion of cached items..
//
// id is for ID of the resource.
func (a LtmApi) GetClientssl(id string) (*LtmClientssl, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/clientssl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClientssl), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetClientssl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClientssl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClientsslList
//
//
// Manages request sent to TMM for SSL specific operations such as deletion of cached items...
func (a LtmApi) GetClientsslList() (*LtmClientsslList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/clientssl"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClientsslList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClientsslOcspStaplingResponsesList
//
//
// Deletes the cached OCSP responses...
func (a LtmApi) GetClientsslOcspStaplingResponsesList() (*LtmClientsslOcspStaplingResponsesList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/clientssl/ocspStaplingResponses"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClientsslOcspStaplingResponsesList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClientsslProxy
//
//
// Manage SSL Forward Proxy cached certificates.
//
// id is for ID of the resource.
func (a LtmApi) GetClientsslProxy(id string) (*LtmClientsslProxy, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/clientsslProxy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClientsslProxy), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetClientsslProxy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClientsslProxy)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClientsslProxyCachedCerts
//
//
// Displays or deletes SSL Forward Proxy cached certificates.
//
// id is for ID of the resource.
func (a LtmApi) GetClientsslProxyCachedCerts(id string) (*LtmClientsslProxyCachedCerts, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/clientsslProxy/cachedCerts/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClientsslProxyCachedCerts), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetClientsslProxyCachedCerts")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClientsslProxyCachedCerts)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClientsslProxyCachedCertsList
//
//
// Displays or deletes SSL Forward Proxy cached certificates..
func (a LtmApi) GetClientsslProxyCachedCertsList() (*LtmClientsslProxyCachedCertsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/clientsslProxy/cachedCerts"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClientsslProxyCachedCertsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetClientsslProxyList
//
//
// Manage SSL Forward Proxy cached certificates..
func (a LtmApi) GetClientsslProxyList() (*LtmClientsslProxyList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/clientsslProxy"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmClientsslProxyList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDataGroup
//
//
// Data group configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetDataGroup(id string) (*LtmDataGroup, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dataGroup/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDataGroup), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDataGroup")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDataGroup)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDataGroupExternal
//
//
// External data group configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetDataGroupExternal(id string) (*LtmDataGroupExternal, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dataGroup/external/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDataGroupExternal), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDataGroupExternal")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDataGroupExternal)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDataGroupExternalList
//
//
// External data group configuration..
func (a LtmApi) GetDataGroupExternalList() (*LtmDataGroupExternalList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dataGroup/external"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDataGroupExternalList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDataGroupInternal
//
//
// Internal data group configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetDataGroupInternal(id string) (*LtmDataGroupInternal, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dataGroup/internal/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDataGroupInternal), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDataGroupInternal")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDataGroupInternal)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDataGroupInternalList
//
//
// Internal data group configuration..
func (a LtmApi) GetDataGroupInternalList() (*LtmDataGroupInternalList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dataGroup/internal"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDataGroupInternalList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDataGroupList
//
//
// Data group configuration..
func (a LtmApi) GetDataGroupList() (*LtmDataGroupList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dataGroup"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDataGroupList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDefaultNodeMonitor
//
//
// Configure the default-monitor rule.
//
// id is for ID of the resource.
func (a LtmApi) GetDefaultNodeMonitor(id string) (*LtmDefaultNodeMonitor, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/defaultNodeMonitor/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDefaultNodeMonitor), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDefaultNodeMonitor")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDefaultNodeMonitor)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDefaultNodeMonitorList
//
//
// Configure the default-monitor rule..
func (a LtmApi) GetDefaultNodeMonitorList() (*LtmDefaultNodeMonitorList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/defaultNodeMonitor"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDefaultNodeMonitorList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDns
//
//
// DNS configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetDns(id string) (*LtmDns, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDns), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDns")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDns)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsAnalytics
//
//
// AVR DNS statistics configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetDnsAnalytics(id string) (*LtmDnsAnalytics, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/analytics/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsAnalytics), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDnsAnalytics")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsAnalytics)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsAnalyticsGlobalSettings
//
//
// AVR DNS statistics global settings affecting all DNS listeners..
//
// id is for ID of the resource.
func (a LtmApi) GetDnsAnalyticsGlobalSettings(id string) (*LtmDnsAnalyticsGlobalSettings, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/analytics/globalSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsAnalyticsGlobalSettings), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDnsAnalyticsGlobalSettings")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsAnalyticsGlobalSettings)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsAnalyticsGlobalSettingsList
//
//
// AVR DNS statistics global settings affecting all DNS listeners...
func (a LtmApi) GetDnsAnalyticsGlobalSettingsList() (*LtmDnsAnalyticsGlobalSettingsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/analytics/globalSettings"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsAnalyticsGlobalSettingsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsAnalyticsList
//
//
// AVR DNS statistics configuration...
func (a LtmApi) GetDnsAnalyticsList() (*LtmDnsAnalyticsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/analytics"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsAnalyticsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsCache
//
//
// DNS cache configuration to generate non-authoritative DNS responses..
//
// id is for ID of the resource.
func (a LtmApi) GetDnsCache(id string) (*LtmDnsCache, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsCache), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDnsCache")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsCache)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsCacheGlobalSettings
//
//
// DNS Cache global settings affecting all caches..
//
// id is for ID of the resource.
func (a LtmApi) GetDnsCacheGlobalSettings(id string) (*LtmDnsCacheGlobalSettings, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/globalSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsCacheGlobalSettings), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDnsCacheGlobalSettings")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsCacheGlobalSettings)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsCacheGlobalSettingsList
//
//
// DNS Cache global settings affecting all caches...
func (a LtmApi) GetDnsCacheGlobalSettingsList() (*LtmDnsCacheGlobalSettingsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/globalSettings"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsCacheGlobalSettingsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsCacheList
//
//
// DNS cache configuration to generate non-authoritative DNS responses...
func (a LtmApi) GetDnsCacheList() (*LtmDnsCacheList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsCacheList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsCacheRecords
//
//
// DNS Cache sub-caches&#39; contents (e.g. resource records)..
//
// id is for ID of the resource.
func (a LtmApi) GetDnsCacheRecords(id string) (*LtmDnsCacheRecords, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/records/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsCacheRecords), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDnsCacheRecords")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsCacheRecords)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsCacheRecordsKey
//
//
// DNS Cache DNSKEY cache entries..
//
// id is for ID of the resource.
func (a LtmApi) GetDnsCacheRecordsKey(id string) (*LtmDnsCacheRecordsKey, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/records/key/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsCacheRecordsKey), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDnsCacheRecordsKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsCacheRecordsKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsCacheRecordsKeyList
//
//
// DNS Cache DNSKEY cache entries...
func (a LtmApi) GetDnsCacheRecordsKeyList() (*LtmDnsCacheRecordsKeyList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/records/key"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsCacheRecordsKeyList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsCacheRecordsList
//
//
// DNS Cache sub-caches&#39; contents (e.g. resource records)...
func (a LtmApi) GetDnsCacheRecordsList() (*LtmDnsCacheRecordsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/records"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsCacheRecordsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsCacheRecordsMsg
//
//
// DNS Cache message cache entries (i.e. complete DNS messages)..
//
// id is for ID of the resource.
func (a LtmApi) GetDnsCacheRecordsMsg(id string) (*LtmDnsCacheRecordsMsg, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/records/msg/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsCacheRecordsMsg), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDnsCacheRecordsMsg")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsCacheRecordsMsg)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsCacheRecordsMsgList
//
//
// DNS Cache message cache entries (i.e. complete DNS messages)...
func (a LtmApi) GetDnsCacheRecordsMsgList() (*LtmDnsCacheRecordsMsgList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/records/msg"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsCacheRecordsMsgList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsCacheRecordsNameserver
//
//
// DNS Cache Nameserver entries.
//
// id is for ID of the resource.
func (a LtmApi) GetDnsCacheRecordsNameserver(id string) (*LtmDnsCacheRecordsNameserver, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/records/nameserver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsCacheRecordsNameserver), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDnsCacheRecordsNameserver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsCacheRecordsNameserver)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsCacheRecordsNameserverList
//
//
// DNS Cache Nameserver entries..
func (a LtmApi) GetDnsCacheRecordsNameserverList() (*LtmDnsCacheRecordsNameserverList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/records/nameserver"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsCacheRecordsNameserverList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsCacheRecordsRrset
//
//
// DNS Cache Resource Record entries.
//
// id is for ID of the resource.
func (a LtmApi) GetDnsCacheRecordsRrset(id string) (*LtmDnsCacheRecordsRrset, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/records/rrset/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsCacheRecordsRrset), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDnsCacheRecordsRrset")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsCacheRecordsRrset)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsCacheRecordsRrsetList
//
//
// DNS Cache Resource Record entries..
func (a LtmApi) GetDnsCacheRecordsRrsetList() (*LtmDnsCacheRecordsRrsetList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/records/rrset"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsCacheRecordsRrsetList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsCacheResolver
//
//
// DNS Cache with recursive resolver..
//
// id is for ID of the resource.
func (a LtmApi) GetDnsCacheResolver(id string) (*LtmDnsCacheResolver, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/resolver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsCacheResolver), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDnsCacheResolver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsCacheResolver)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsCacheResolverList
//
//
// DNS Cache with recursive resolver...
func (a LtmApi) GetDnsCacheResolverList() (*LtmDnsCacheResolverList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/resolver"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsCacheResolverList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsCacheTransparent
//
//
// DNS Cache without a resolver (responses from serverside cached)..
//
// id is for ID of the resource.
func (a LtmApi) GetDnsCacheTransparent(id string) (*LtmDnsCacheTransparent, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/transparent/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsCacheTransparent), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDnsCacheTransparent")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsCacheTransparent)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsCacheTransparentList
//
//
// DNS Cache without a resolver (responses from serverside cached)...
func (a LtmApi) GetDnsCacheTransparentList() (*LtmDnsCacheTransparentList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/transparent"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsCacheTransparentList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsCacheValidatingResolver
//
//
// DNS Cache with recursive resolver and DNSSEC validation..
//
// id is for ID of the resource.
func (a LtmApi) GetDnsCacheValidatingResolver(id string) (*LtmDnsCacheValidatingResolver, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/validatingResolver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsCacheValidatingResolver), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDnsCacheValidatingResolver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsCacheValidatingResolver)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsCacheValidatingResolverList
//
//
// DNS Cache with recursive resolver and DNSSEC validation...
func (a LtmApi) GetDnsCacheValidatingResolverList() (*LtmDnsCacheValidatingResolverList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/validatingResolver"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsCacheValidatingResolverList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsDnsExpressDbList
//
//
// DNS Express database loaded into BIG-IP...
func (a LtmApi) GetDnsDnsExpressDbList() (*LtmDnsDnsExpressDbList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/dnsExpressDb"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsDnsExpressDbList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsDnssec
//
//
// DNS Security Extensions (dynamic signing on BIG-IP).
//
// id is for ID of the resource.
func (a LtmApi) GetDnsDnssec(id string) (*LtmDnsDnssec, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/dnssec/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsDnssec), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDnsDnssec")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsDnssec)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsDnssecKey
//
//
// DNSSEC key configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetDnsDnssecKey(id string) (*LtmDnsDnssecKey, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/dnssec/key/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsDnssecKey), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDnsDnssecKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsDnssecKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsDnssecKeyList
//
//
// DNSSEC key configuration..
func (a LtmApi) GetDnsDnssecKeyList() (*LtmDnsDnssecKeyList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/dnssec/key"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsDnssecKeyList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsDnssecKeyTmGeneration
//
//
// DNSSEC key generation configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetDnsDnssecKeyTmGeneration(id string) (*LtmDnsDnssecKeyTmGeneration, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/dnssec/key/tmGeneration/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsDnssecKeyTmGeneration), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDnsDnssecKeyTmGeneration")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsDnssecKeyTmGeneration)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsDnssecKeyTmGenerationList
//
//
// DNSSEC key generation configuration..
func (a LtmApi) GetDnsDnssecKeyTmGenerationList() (*LtmDnsDnssecKeyTmGenerationList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/dnssec/key/tmGeneration"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsDnssecKeyTmGenerationList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsDnssecList
//
//
// DNS Security Extensions (dynamic signing on BIG-IP)..
func (a LtmApi) GetDnsDnssecList() (*LtmDnsDnssecList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/dnssec"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsDnssecList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsDnssecZone
//
//
// DNSSEC zone configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetDnsDnssecZone(id string) (*LtmDnsDnssecZone, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/dnssec/zone/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsDnssecZone), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDnsDnssecZone")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsDnssecZone)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsDnssecZoneList
//
//
// DNSSEC zone configuration..
func (a LtmApi) GetDnsDnssecZoneList() (*LtmDnsDnssecZoneList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/dnssec/zone"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsDnssecZoneList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsList
//
//
// DNS configuration..
func (a LtmApi) GetDnsList() (*LtmDnsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsNameserver
//
//
// DNS nameserver configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetDnsNameserver(id string) (*LtmDnsNameserver, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/nameserver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsNameserver), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDnsNameserver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsNameserver)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsNameserverList
//
//
// DNS nameserver configuration...
func (a LtmApi) GetDnsNameserverList() (*LtmDnsNameserverList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/nameserver"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsNameserverList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsTsigKey
//
//
// TSIG Key configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetDnsTsigKey(id string) (*LtmDnsTsigKey, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/tsigKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsTsigKey), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDnsTsigKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsTsigKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsTsigKeyList
//
//
// TSIG Key configuration...
func (a LtmApi) GetDnsTsigKeyList() (*LtmDnsTsigKeyList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/tsigKey"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsTsigKeyList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsZone
//
//
// Zone configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetDnsZone(id string) (*LtmDnsZone, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/zone/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsZone), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetDnsZone")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsZone)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetDnsZoneList
//
//
// Zone configuration...
func (a LtmApi) GetDnsZoneList() (*LtmDnsZoneList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/zone"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmDnsZoneList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetEvictionPolicy
//
//
// Defines an eviction policy, used to select which flows to evict when approaching limits..
//
// id is for ID of the resource.
func (a LtmApi) GetEvictionPolicy(id string) (*LtmEvictionPolicy, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/evictionPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmEvictionPolicy), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetEvictionPolicy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmEvictionPolicy)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetEvictionPolicyList
//
//
// Defines an eviction policy, used to select which flows to evict when approaching limits...
func (a LtmApi) GetEvictionPolicyList() (*LtmEvictionPolicyList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/evictionPolicy"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmEvictionPolicyList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetGlobalSettings
//
//
// Local Traffic Manager options.
//
// id is for ID of the resource.
func (a LtmApi) GetGlobalSettings(id string) (*LtmGlobalSettings, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/globalSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmGlobalSettings), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetGlobalSettings")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmGlobalSettings)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetGlobalSettingsConnection
//
//
// General configuration options for connections.
//
// id is for ID of the resource.
func (a LtmApi) GetGlobalSettingsConnection(id string) (*LtmGlobalSettingsConnection, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/globalSettings/connection/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmGlobalSettingsConnection), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetGlobalSettingsConnection")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmGlobalSettingsConnection)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetGlobalSettingsConnectionList
//
//
// General configuration options for connections..
func (a LtmApi) GetGlobalSettingsConnectionList() (*LtmGlobalSettingsConnectionList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/globalSettings/connection"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmGlobalSettingsConnectionList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetGlobalSettingsGeneral
//
//
// General configuration options.
//
// id is for ID of the resource.
func (a LtmApi) GetGlobalSettingsGeneral(id string) (*LtmGlobalSettingsGeneral, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/globalSettings/general/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmGlobalSettingsGeneral), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetGlobalSettingsGeneral")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmGlobalSettingsGeneral)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetGlobalSettingsGeneralList
//
//
// General configuration options..
func (a LtmApi) GetGlobalSettingsGeneralList() (*LtmGlobalSettingsGeneralList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/globalSettings/general"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmGlobalSettingsGeneralList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetGlobalSettingsList
//
//
// Local Traffic Manager options..
func (a LtmApi) GetGlobalSettingsList() (*LtmGlobalSettingsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/globalSettings"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmGlobalSettingsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetGlobalSettingsTrafficControl
//
//
// General configuration options for traffic.
//
// id is for ID of the resource.
func (a LtmApi) GetGlobalSettingsTrafficControl(id string) (*LtmGlobalSettingsTrafficControl, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/globalSettings/trafficControl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmGlobalSettingsTrafficControl), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetGlobalSettingsTrafficControl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmGlobalSettingsTrafficControl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetGlobalSettingsTrafficControlList
//
//
// General configuration options for traffic..
func (a LtmApi) GetGlobalSettingsTrafficControlList() (*LtmGlobalSettingsTrafficControlList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/globalSettings/trafficControl"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmGlobalSettingsTrafficControlList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHtmlRule
//
//
// Generalized HTML rule-based patcher.
//
// id is for ID of the resource.
func (a LtmApi) GetHtmlRule(id string) (*LtmHtmlRule, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRule), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetHtmlRule")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmHtmlRule)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHtmlRuleCommentRaiseEvent
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetHtmlRuleCommentRaiseEvent(id string) (*LtmHtmlRuleCommentRaiseEvent, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/commentRaiseEvent/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleCommentRaiseEvent), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetHtmlRuleCommentRaiseEvent")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmHtmlRuleCommentRaiseEvent)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHtmlRuleCommentRaiseEventList
//
//
// ..
func (a LtmApi) GetHtmlRuleCommentRaiseEventList() (*LtmHtmlRuleCommentRaiseEventList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/commentRaiseEvent"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmHtmlRuleCommentRaiseEventList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHtmlRuleCommentRemove
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetHtmlRuleCommentRemove(id string) (*LtmHtmlRuleCommentRemove, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/commentRemove/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleCommentRemove), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetHtmlRuleCommentRemove")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmHtmlRuleCommentRemove)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHtmlRuleCommentRemoveList
//
//
// ..
func (a LtmApi) GetHtmlRuleCommentRemoveList() (*LtmHtmlRuleCommentRemoveList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/commentRemove"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmHtmlRuleCommentRemoveList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHtmlRuleList
//
//
// Generalized HTML rule-based patcher..
func (a LtmApi) GetHtmlRuleList() (*LtmHtmlRuleList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmHtmlRuleList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHtmlRuleTagAppendHtml
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetHtmlRuleTagAppendHtml(id string) (*LtmHtmlRuleTagAppendHtml, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagAppendHtml/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleTagAppendHtml), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetHtmlRuleTagAppendHtml")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmHtmlRuleTagAppendHtml)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHtmlRuleTagAppendHtmlList
//
//
// ..
func (a LtmApi) GetHtmlRuleTagAppendHtmlList() (*LtmHtmlRuleTagAppendHtmlList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagAppendHtml"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmHtmlRuleTagAppendHtmlList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHtmlRuleTagPrependHtml
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetHtmlRuleTagPrependHtml(id string) (*LtmHtmlRuleTagPrependHtml, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagPrependHtml/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleTagPrependHtml), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetHtmlRuleTagPrependHtml")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmHtmlRuleTagPrependHtml)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHtmlRuleTagPrependHtmlList
//
//
// ..
func (a LtmApi) GetHtmlRuleTagPrependHtmlList() (*LtmHtmlRuleTagPrependHtmlList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagPrependHtml"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmHtmlRuleTagPrependHtmlList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHtmlRuleTagRaiseEvent
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetHtmlRuleTagRaiseEvent(id string) (*LtmHtmlRuleTagRaiseEvent, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagRaiseEvent/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleTagRaiseEvent), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetHtmlRuleTagRaiseEvent")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmHtmlRuleTagRaiseEvent)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHtmlRuleTagRaiseEventList
//
//
// ..
func (a LtmApi) GetHtmlRuleTagRaiseEventList() (*LtmHtmlRuleTagRaiseEventList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagRaiseEvent"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmHtmlRuleTagRaiseEventList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHtmlRuleTagRemove
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetHtmlRuleTagRemove(id string) (*LtmHtmlRuleTagRemove, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagRemove/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleTagRemove), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetHtmlRuleTagRemove")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmHtmlRuleTagRemove)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHtmlRuleTagRemoveAttribute
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetHtmlRuleTagRemoveAttribute(id string) (*LtmHtmlRuleTagRemoveAttribute, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagRemoveAttribute/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleTagRemoveAttribute), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetHtmlRuleTagRemoveAttribute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmHtmlRuleTagRemoveAttribute)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHtmlRuleTagRemoveAttributeList
//
//
// ..
func (a LtmApi) GetHtmlRuleTagRemoveAttributeList() (*LtmHtmlRuleTagRemoveAttributeList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagRemoveAttribute"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmHtmlRuleTagRemoveAttributeList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetHtmlRuleTagRemoveList
//
//
// ..
func (a LtmApi) GetHtmlRuleTagRemoveList() (*LtmHtmlRuleTagRemoveList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagRemove"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmHtmlRuleTagRemoveList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIfile
//
//
// iFile Configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetIfile(id string) (*LtmIfile, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/ifile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmIfile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetIfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmIfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetIfileList
//
//
// iFile Configuration..
func (a LtmApi) GetIfileList() (*LtmIfileList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/ifile"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmIfileList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLsnLogProfile
//
//
// Defines the configuration for logging of LSN flows..
//
// id is for ID of the resource.
func (a LtmApi) GetLsnLogProfile(id string) (*LtmLsnLogProfile, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/lsnLogProfile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmLsnLogProfile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetLsnLogProfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmLsnLogProfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLsnLogProfileList
//
//
// Defines the configuration for logging of LSN flows...
func (a LtmApi) GetLsnLogProfileList() (*LtmLsnLogProfileList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/lsnLogProfile"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmLsnLogProfileList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLsnPool
//
//
// LSNAT/CGNAT translation address configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetLsnPool(id string) (*LtmLsnPool, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/lsnPool/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmLsnPool), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetLsnPool")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmLsnPool)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetLsnPoolList
//
//
// LSNAT/CGNAT translation address configuration..
func (a LtmApi) GetLsnPoolList() (*LtmLsnPoolList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/lsnPool"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmLsnPoolList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRouting
//
//
// Message routing framework configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRouting(id string) (*LtmMessageRouting, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRouting), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRouting")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRouting)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingDiameter
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingDiameter(id string) (*LtmMessageRoutingDiameter, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameter), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingDiameter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingDiameter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingDiameterList
//
//
// ..
func (a LtmApi) GetMessageRoutingDiameterList() (*LtmMessageRoutingDiameterList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingDiameterList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingDiameterPeer
//
//
// Peed for routing generic message protocol messages..
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingDiameterPeer(id string) (*LtmMessageRoutingDiameterPeer, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/peer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterPeer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingDiameterPeer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingDiameterPeer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingDiameterPeerList
//
//
// Peed for routing generic message protocol messages...
func (a LtmApi) GetMessageRoutingDiameterPeerList() (*LtmMessageRoutingDiameterPeerList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/peer"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingDiameterPeerList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingDiameterProfile
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingDiameterProfile(id string) (*LtmMessageRoutingDiameterProfile, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/profile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterProfile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingDiameterProfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingDiameterProfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingDiameterProfileList
//
//
// ..
func (a LtmApi) GetMessageRoutingDiameterProfileList() (*LtmMessageRoutingDiameterProfileList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/profile"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingDiameterProfileList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingDiameterProfileRouter
//
//
// Configures a Diameter Router profile..
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingDiameterProfileRouter(id string) (*LtmMessageRoutingDiameterProfileRouter, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/profile/router/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterProfileRouter), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingDiameterProfileRouter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingDiameterProfileRouter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingDiameterProfileRouterList
//
//
// Configures a Diameter Router profile...
func (a LtmApi) GetMessageRoutingDiameterProfileRouterList() (*LtmMessageRoutingDiameterProfileRouterList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/profile/router"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingDiameterProfileRouterList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingDiameterProfileSession
//
//
// Configures a Diameter Session profile..
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingDiameterProfileSession(id string) (*LtmMessageRoutingDiameterProfileSession, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/profile/session/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterProfileSession), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingDiameterProfileSession")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingDiameterProfileSession)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingDiameterProfileSessionList
//
//
// Configures a Diameter Session profile...
func (a LtmApi) GetMessageRoutingDiameterProfileSessionList() (*LtmMessageRoutingDiameterProfileSessionList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/profile/session"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingDiameterProfileSessionList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingDiameterRoute
//
//
// Configures a static route for use in Diameter message routing..
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingDiameterRoute(id string) (*LtmMessageRoutingDiameterRoute, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/route/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterRoute), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingDiameterRoute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingDiameterRoute)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingDiameterRouteList
//
//
// Configures a static route for use in Diameter message routing...
func (a LtmApi) GetMessageRoutingDiameterRouteList() (*LtmMessageRoutingDiameterRouteList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/route"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingDiameterRouteList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingDiameterTransportConfig
//
//
// Defines the configuration for an outgoing connection..
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingDiameterTransportConfig(id string) (*LtmMessageRoutingDiameterTransportConfig, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/transportConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterTransportConfig), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingDiameterTransportConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingDiameterTransportConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingDiameterTransportConfigList
//
//
// Defines the configuration for an outgoing connection...
func (a LtmApi) GetMessageRoutingDiameterTransportConfigList() (*LtmMessageRoutingDiameterTransportConfigList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/transportConfig"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingDiameterTransportConfigList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingDiameterTransportConfigProfiles
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingDiameterTransportConfigProfiles(id string) (*LtmMessageRoutingDiameterTransportConfigProfiles, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/transportConfig/profiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterTransportConfigProfiles), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingDiameterTransportConfigProfiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingDiameterTransportConfigProfiles)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingDiameterTransportConfigProfilesList
//
//
// ..
func (a LtmApi) GetMessageRoutingDiameterTransportConfigProfilesList() (*LtmMessageRoutingDiameterTransportConfigProfilesList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/transportConfig/profiles"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingDiameterTransportConfigProfilesList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingGeneric
//
//
// Generic message protocol.
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingGeneric(id string) (*LtmMessageRoutingGeneric, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGeneric), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingGeneric")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingGeneric)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingGenericList
//
//
// Generic message protocol..
func (a LtmApi) GetMessageRoutingGenericList() (*LtmMessageRoutingGenericList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingGenericList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingGenericPeer
//
//
// Peed for routing generic message protocol messages..
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingGenericPeer(id string) (*LtmMessageRoutingGenericPeer, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/peer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericPeer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingGenericPeer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingGenericPeer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingGenericPeerList
//
//
// Peed for routing generic message protocol messages...
func (a LtmApi) GetMessageRoutingGenericPeerList() (*LtmMessageRoutingGenericPeerList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/peer"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingGenericPeerList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingGenericProtocol
//
//
// Generic message parser for use with the message routing framework..
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingGenericProtocol(id string) (*LtmMessageRoutingGenericProtocol, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/protocol/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericProtocol), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingGenericProtocol")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingGenericProtocol)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingGenericProtocolList
//
//
// Generic message parser for use with the message routing framework...
func (a LtmApi) GetMessageRoutingGenericProtocolList() (*LtmMessageRoutingGenericProtocolList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/protocol"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingGenericProtocolList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingGenericRoute
//
//
// Static route for routing generic message protocol messages..
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingGenericRoute(id string) (*LtmMessageRoutingGenericRoute, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/route/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericRoute), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingGenericRoute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingGenericRoute)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingGenericRouteList
//
//
// Static route for routing generic message protocol messages...
func (a LtmApi) GetMessageRoutingGenericRouteList() (*LtmMessageRoutingGenericRouteList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/route"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingGenericRouteList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingGenericRouter
//
//
// Message routing instance for generic message protocol..
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingGenericRouter(id string) (*LtmMessageRoutingGenericRouter, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/router/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericRouter), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingGenericRouter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingGenericRouter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingGenericRouterList
//
//
// Message routing instance for generic message protocol...
func (a LtmApi) GetMessageRoutingGenericRouterList() (*LtmMessageRoutingGenericRouterList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/router"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingGenericRouterList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingGenericTransportConfig
//
//
// Defines the configuration for an outgoing connection..
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingGenericTransportConfig(id string) (*LtmMessageRoutingGenericTransportConfig, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/transportConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericTransportConfig), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingGenericTransportConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingGenericTransportConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingGenericTransportConfigList
//
//
// Defines the configuration for an outgoing connection...
func (a LtmApi) GetMessageRoutingGenericTransportConfigList() (*LtmMessageRoutingGenericTransportConfigList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/transportConfig"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingGenericTransportConfigList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingGenericTransportConfigProfiles
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingGenericTransportConfigProfiles(id string) (*LtmMessageRoutingGenericTransportConfigProfiles, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/transportConfig/profiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericTransportConfigProfiles), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingGenericTransportConfigProfiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingGenericTransportConfigProfiles)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingGenericTransportConfigProfilesList
//
//
// ..
func (a LtmApi) GetMessageRoutingGenericTransportConfigProfilesList() (*LtmMessageRoutingGenericTransportConfigProfilesList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/transportConfig/profiles"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingGenericTransportConfigProfilesList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingList
//
//
// Message routing framework configuration..
func (a LtmApi) GetMessageRoutingList() (*LtmMessageRoutingList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingSip
//
//
// SIP message protocol.
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingSip(id string) (*LtmMessageRoutingSip, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSip), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingSip")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingSip)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingSipList
//
//
// SIP message protocol..
func (a LtmApi) GetMessageRoutingSipList() (*LtmMessageRoutingSipList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingSipList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingSipPeer
//
//
// Peed for routing generic message protocol messages..
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingSipPeer(id string) (*LtmMessageRoutingSipPeer, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/peer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipPeer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingSipPeer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingSipPeer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingSipPeerList
//
//
// Peed for routing generic message protocol messages...
func (a LtmApi) GetMessageRoutingSipPeerList() (*LtmMessageRoutingSipPeerList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/peer"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingSipPeerList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingSipProfile
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingSipProfile(id string) (*LtmMessageRoutingSipProfile, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/profile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipProfile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingSipProfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingSipProfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingSipProfileList
//
//
// ..
func (a LtmApi) GetMessageRoutingSipProfileList() (*LtmMessageRoutingSipProfileList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/profile"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingSipProfileList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingSipProfileRouter
//
//
// Configures a Session Initiation Protocol (SIP) Router profile..
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingSipProfileRouter(id string) (*LtmMessageRoutingSipProfileRouter, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/profile/router/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipProfileRouter), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingSipProfileRouter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingSipProfileRouter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingSipProfileRouterList
//
//
// Configures a Session Initiation Protocol (SIP) Router profile...
func (a LtmApi) GetMessageRoutingSipProfileRouterList() (*LtmMessageRoutingSipProfileRouterList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/profile/router"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingSipProfileRouterList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingSipProfileSession
//
//
// Configures a Session Initiation Protocol (SIP) Session profile..
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingSipProfileSession(id string) (*LtmMessageRoutingSipProfileSession, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/profile/session/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipProfileSession), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingSipProfileSession")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingSipProfileSession)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingSipProfileSessionList
//
//
// Configures a Session Initiation Protocol (SIP) Session profile...
func (a LtmApi) GetMessageRoutingSipProfileSessionList() (*LtmMessageRoutingSipProfileSessionList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/profile/session"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingSipProfileSessionList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingSipRoute
//
//
// Configures a static route for use in Session Initiation Protocol (SIP) message routing..
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingSipRoute(id string) (*LtmMessageRoutingSipRoute, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/route/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipRoute), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingSipRoute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingSipRoute)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingSipRouteList
//
//
// Configures a static route for use in Session Initiation Protocol (SIP) message routing...
func (a LtmApi) GetMessageRoutingSipRouteList() (*LtmMessageRoutingSipRouteList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/route"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingSipRouteList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingSipTransportConfig
//
//
// Defines the configuration for an outgoing connection..
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingSipTransportConfig(id string) (*LtmMessageRoutingSipTransportConfig, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/transportConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipTransportConfig), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingSipTransportConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingSipTransportConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingSipTransportConfigList
//
//
// Defines the configuration for an outgoing connection...
func (a LtmApi) GetMessageRoutingSipTransportConfigList() (*LtmMessageRoutingSipTransportConfigList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/transportConfig"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingSipTransportConfigList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingSipTransportConfigProfiles
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetMessageRoutingSipTransportConfigProfiles(id string) (*LtmMessageRoutingSipTransportConfigProfiles, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/transportConfig/profiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipTransportConfigProfiles), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMessageRoutingSipTransportConfigProfiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingSipTransportConfigProfiles)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMessageRoutingSipTransportConfigProfilesList
//
//
// ..
func (a LtmApi) GetMessageRoutingSipTransportConfigProfilesList() (*LtmMessageRoutingSipTransportConfigProfilesList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/transportConfig/profiles"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMessageRoutingSipTransportConfigProfilesList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitor
//
//
// LTM monitor templates.
//
// id is for ID of the resource.
func (a LtmApi) GetMonitor(id string) (*LtmMonitor, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitor), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitor")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitor)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorDiameter
//
//
// Diameter monitor configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorDiameter(id string) (*LtmMonitorDiameter, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/diameter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorDiameter), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorDiameter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorDiameter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorDiameterList
//
//
// Diameter monitor configuration..
func (a LtmApi) GetMonitorDiameterList() (*LtmMonitorDiameterList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/diameter"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorDiameterList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorDns
//
//
// DNS monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorDns(id string) (*LtmMonitorDns, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/dns/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorDns), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorDns")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorDns)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorDnsList
//
//
// DNS monitor configuration...
func (a LtmApi) GetMonitorDnsList() (*LtmMonitorDnsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/dns"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorDnsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorExternal
//
//
// External monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorExternal(id string) (*LtmMonitorExternal, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/external/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorExternal), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorExternal")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorExternal)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorExternalList
//
//
// External monitor configuration...
func (a LtmApi) GetMonitorExternalList() (*LtmMonitorExternalList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/external"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorExternalList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorFirepass
//
//
// Firepass monitor configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorFirepass(id string) (*LtmMonitorFirepass, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/firepass/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorFirepass), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorFirepass")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorFirepass)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorFirepassList
//
//
// Firepass monitor configuration..
func (a LtmApi) GetMonitorFirepassList() (*LtmMonitorFirepassList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/firepass"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorFirepassList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorFtp
//
//
// FTP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorFtp(id string) (*LtmMonitorFtp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/ftp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorFtp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorFtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorFtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorFtpList
//
//
// FTP monitor configuration...
func (a LtmApi) GetMonitorFtpList() (*LtmMonitorFtpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/ftp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorFtpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorGatewayIcmp
//
//
// Gateway ICMP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorGatewayIcmp(id string) (*LtmMonitorGatewayIcmp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/gatewayIcmp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorGatewayIcmp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorGatewayIcmp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorGatewayIcmp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorGatewayIcmpList
//
//
// Gateway ICMP monitor configuration...
func (a LtmApi) GetMonitorGatewayIcmpList() (*LtmMonitorGatewayIcmpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/gatewayIcmp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorGatewayIcmpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorHttp
//
//
// HTTP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorHttp(id string) (*LtmMonitorHttp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/http/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorHttp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorHttp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorHttp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorHttpList
//
//
// HTTP monitor configuration...
func (a LtmApi) GetMonitorHttpList() (*LtmMonitorHttpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/http"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorHttpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorHttps
//
//
// HTTPS monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorHttps(id string) (*LtmMonitorHttps, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/https/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorHttps), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorHttps")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorHttps)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorHttpsList
//
//
// HTTPS monitor configuration...
func (a LtmApi) GetMonitorHttpsList() (*LtmMonitorHttpsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/https"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorHttpsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorIcmp
//
//
// ICMP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorIcmp(id string) (*LtmMonitorIcmp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/icmp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorIcmp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorIcmp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorIcmp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorIcmpList
//
//
// ICMP monitor configuration...
func (a LtmApi) GetMonitorIcmpList() (*LtmMonitorIcmpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/icmp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorIcmpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorImap
//
//
// IMAP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorImap(id string) (*LtmMonitorImap, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/imap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorImap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorImap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorImap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorImapList
//
//
// IMAP monitor configuration...
func (a LtmApi) GetMonitorImapList() (*LtmMonitorImapList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/imap"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorImapList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorInband
//
//
// Inband monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorInband(id string) (*LtmMonitorInband, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/inband/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorInband), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorInband")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorInband)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorInbandList
//
//
// Inband monitor configuration...
func (a LtmApi) GetMonitorInbandList() (*LtmMonitorInbandList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/inband"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorInbandList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorLdap
//
//
// LDAP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorLdap(id string) (*LtmMonitorLdap, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/ldap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorLdap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorLdap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorLdapList
//
//
// LDAP monitor configuration...
func (a LtmApi) GetMonitorLdapList() (*LtmMonitorLdapList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/ldap"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorLdapList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorList
//
//
// LTM monitor templates..
func (a LtmApi) GetMonitorList() (*LtmMonitorList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorModuleScore
//
//
// Module score monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorModuleScore(id string) (*LtmMonitorModuleScore, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/moduleScore/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorModuleScore), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorModuleScore")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorModuleScore)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorModuleScoreList
//
//
// Module score monitor configuration...
func (a LtmApi) GetMonitorModuleScoreList() (*LtmMonitorModuleScoreList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/moduleScore"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorModuleScoreList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorMssql
//
//
// MSSQL monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorMssql(id string) (*LtmMonitorMssql, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/mssql/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorMssql), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorMssql")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorMssql)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorMssqlList
//
//
// MSSQL monitor configuration...
func (a LtmApi) GetMonitorMssqlList() (*LtmMonitorMssqlList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/mssql"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorMssqlList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorMysql
//
//
// MySQL monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorMysql(id string) (*LtmMonitorMysql, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/mysql/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorMysql), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorMysql")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorMysql)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorMysqlList
//
//
// MySQL monitor configuration...
func (a LtmApi) GetMonitorMysqlList() (*LtmMonitorMysqlList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/mysql"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorMysqlList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorNntp
//
//
// NNTP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorNntp(id string) (*LtmMonitorNntp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/nntp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorNntp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorNntp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorNntp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorNntpList
//
//
// NNTP monitor configuration...
func (a LtmApi) GetMonitorNntpList() (*LtmMonitorNntpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/nntp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorNntpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorNone
//
//
// The NULL monitor..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorNone(id string) (*LtmMonitorNone, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/none/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorNone), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorNone")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorNone)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorNoneList
//
//
// The NULL monitor...
func (a LtmApi) GetMonitorNoneList() (*LtmMonitorNoneList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/none"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorNoneList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorOracle
//
//
// Oracle monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorOracle(id string) (*LtmMonitorOracle, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/oracle/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorOracle), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorOracle")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorOracle)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorOracleList
//
//
// Oracle monitor configuration...
func (a LtmApi) GetMonitorOracleList() (*LtmMonitorOracleList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/oracle"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorOracleList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorPop3
//
//
// POP3 monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorPop3(id string) (*LtmMonitorPop3, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/pop3/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorPop3), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorPop3")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorPop3)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorPop3List
//
//
// POP3 monitor configuration...
func (a LtmApi) GetMonitorPop3List() (*LtmMonitorPop3List, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/pop3"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorPop3List)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorPostgresql
//
//
// Postgresql monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorPostgresql(id string) (*LtmMonitorPostgresql, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/postgresql/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorPostgresql), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorPostgresql")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorPostgresql)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorPostgresqlList
//
//
// Postgresql monitor configuration...
func (a LtmApi) GetMonitorPostgresqlList() (*LtmMonitorPostgresqlList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/postgresql"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorPostgresqlList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorRadius
//
//
// Radius monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorRadius(id string) (*LtmMonitorRadius, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/radius/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorRadius), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorRadius")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorRadius)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorRadiusAccounting
//
//
// Radius accounting monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorRadiusAccounting(id string) (*LtmMonitorRadiusAccounting, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/radiusAccounting/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorRadiusAccounting), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorRadiusAccounting")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorRadiusAccounting)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorRadiusAccountingList
//
//
// Radius accounting monitor configuration...
func (a LtmApi) GetMonitorRadiusAccountingList() (*LtmMonitorRadiusAccountingList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/radiusAccounting"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorRadiusAccountingList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorRadiusList
//
//
// Radius monitor configuration...
func (a LtmApi) GetMonitorRadiusList() (*LtmMonitorRadiusList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/radius"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorRadiusList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorRealServer
//
//
// Real Server monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorRealServer(id string) (*LtmMonitorRealServer, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/realServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorRealServer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorRealServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorRealServer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorRealServerList
//
//
// Real Server monitor configuration...
func (a LtmApi) GetMonitorRealServerList() (*LtmMonitorRealServerList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/realServer"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorRealServerList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorRpc
//
//
// RPC monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorRpc(id string) (*LtmMonitorRpc, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/rpc/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorRpc), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorRpc")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorRpc)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorRpcList
//
//
// RPC monitor configuration...
func (a LtmApi) GetMonitorRpcList() (*LtmMonitorRpcList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/rpc"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorRpcList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorSasp
//
//
// SASP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorSasp(id string) (*LtmMonitorSasp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/sasp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSasp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorSasp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorSasp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorSaspList
//
//
// SASP monitor configuration...
func (a LtmApi) GetMonitorSaspList() (*LtmMonitorSaspList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/sasp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorSaspList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorScripted
//
//
// Scripted monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorScripted(id string) (*LtmMonitorScripted, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/scripted/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorScripted), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorScripted")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorScripted)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorScriptedList
//
//
// Scripted monitor configuration...
func (a LtmApi) GetMonitorScriptedList() (*LtmMonitorScriptedList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/scripted"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorScriptedList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorSip
//
//
// SIP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorSip(id string) (*LtmMonitorSip, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/sip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSip), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorSip")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorSip)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorSipList
//
//
// SIP monitor configuration...
func (a LtmApi) GetMonitorSipList() (*LtmMonitorSipList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/sip"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorSipList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorSmb
//
//
// SMB monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorSmb(id string) (*LtmMonitorSmb, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/smb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSmb), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorSmb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorSmb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorSmbList
//
//
// SMB monitor configuration...
func (a LtmApi) GetMonitorSmbList() (*LtmMonitorSmbList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/smb"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorSmbList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorSmtp
//
//
// SMTP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorSmtp(id string) (*LtmMonitorSmtp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/smtp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSmtp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorSmtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorSmtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorSmtpList
//
//
// SMTP monitor configuration...
func (a LtmApi) GetMonitorSmtpList() (*LtmMonitorSmtpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/smtp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorSmtpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorSnmpDca
//
//
// SNMP DCA monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorSnmpDca(id string) (*LtmMonitorSnmpDca, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/snmpDca/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSnmpDca), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorSnmpDca")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorSnmpDca)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorSnmpDcaBase
//
//
// SNMP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorSnmpDcaBase(id string) (*LtmMonitorSnmpDcaBase, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/snmpDcaBase/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSnmpDcaBase), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorSnmpDcaBase")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorSnmpDcaBase)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorSnmpDcaBaseList
//
//
// SNMP monitor configuration...
func (a LtmApi) GetMonitorSnmpDcaBaseList() (*LtmMonitorSnmpDcaBaseList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/snmpDcaBase"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorSnmpDcaBaseList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorSnmpDcaList
//
//
// SNMP DCA monitor configuration...
func (a LtmApi) GetMonitorSnmpDcaList() (*LtmMonitorSnmpDcaList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/snmpDca"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorSnmpDcaList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorSoap
//
//
// SOAP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorSoap(id string) (*LtmMonitorSoap, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/soap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSoap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorSoap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorSoap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorSoapList
//
//
// SOAP monitor configuration...
func (a LtmApi) GetMonitorSoapList() (*LtmMonitorSoapList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/soap"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorSoapList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorTcp
//
//
// TCP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorTcp(id string) (*LtmMonitorTcp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/tcp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorTcp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorTcp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorTcp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorTcpEcho
//
//
// TCP Echo monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorTcpEcho(id string) (*LtmMonitorTcpEcho, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/tcpEcho/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorTcpEcho), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorTcpEcho")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorTcpEcho)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorTcpEchoList
//
//
// TCP Echo monitor configuration...
func (a LtmApi) GetMonitorTcpEchoList() (*LtmMonitorTcpEchoList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/tcpEcho"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorTcpEchoList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorTcpHalfOpen
//
//
// TCP Half Open monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorTcpHalfOpen(id string) (*LtmMonitorTcpHalfOpen, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/tcpHalfOpen/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorTcpHalfOpen), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorTcpHalfOpen")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorTcpHalfOpen)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorTcpHalfOpenList
//
//
// TCP Half Open monitor configuration...
func (a LtmApi) GetMonitorTcpHalfOpenList() (*LtmMonitorTcpHalfOpenList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/tcpHalfOpen"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorTcpHalfOpenList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorTcpList
//
//
// TCP monitor configuration...
func (a LtmApi) GetMonitorTcpList() (*LtmMonitorTcpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/tcp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorTcpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorUdp
//
//
// UDP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorUdp(id string) (*LtmMonitorUdp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/udp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorUdp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorUdp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorUdp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorUdpList
//
//
// UDP monitor configuration...
func (a LtmApi) GetMonitorUdpList() (*LtmMonitorUdpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/udp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorUdpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorVirtualLocation
//
//
// Virtual Location monitor configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorVirtualLocation(id string) (*LtmMonitorVirtualLocation, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/virtualLocation/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorVirtualLocation), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorVirtualLocation")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorVirtualLocation)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorVirtualLocationList
//
//
// Virtual Location monitor configuration..
func (a LtmApi) GetMonitorVirtualLocationList() (*LtmMonitorVirtualLocationList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/virtualLocation"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorVirtualLocationList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorWap
//
//
// WAP monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorWap(id string) (*LtmMonitorWap, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/wap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorWap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorWap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorWap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorWapList
//
//
// WAP monitor configuration...
func (a LtmApi) GetMonitorWapList() (*LtmMonitorWapList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/wap"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorWapList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorWmi
//
//
// WMI monitor configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetMonitorWmi(id string) (*LtmMonitorWmi, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/wmi/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorWmi), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetMonitorWmi")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorWmi)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetMonitorWmiList
//
//
// WMI monitor configuration...
func (a LtmApi) GetMonitorWmiList() (*LtmMonitorWmiList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/wmi"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmMonitorWmiList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetNat
//
//
// Network address translation configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetNat(id string) (*LtmNat, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/nat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmNat), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetNat")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmNat)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetNatList
//
//
// Network address translation configuration..
func (a LtmApi) GetNatList() (*LtmNatList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/nat"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmNatList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetNode
//
//
// Node specific pool member configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetNode(id string) (*LtmNode, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/node/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmNode), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetNode")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmNode)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetNodeList
//
//
// Node specific pool member configuration..
func (a LtmApi) GetNodeList() (*LtmNodeList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/node"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmNodeList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistence
//
//
// Virtual server persistence configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetPersistence(id string) (*LtmPersistence, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistence), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetPersistence")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistence)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistenceCookie
//
//
// Virtual server Cookie persistence profile.
//
// id is for ID of the resource.
func (a LtmApi) GetPersistenceCookie(id string) (*LtmPersistenceCookie, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/cookie/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceCookie), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetPersistenceCookie")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistenceCookie)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistenceCookieList
//
//
// Virtual server Cookie persistence profile..
func (a LtmApi) GetPersistenceCookieList() (*LtmPersistenceCookieList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/cookie"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistenceCookieList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistenceDestAddr
//
//
// Virtual server Destination Address Affinity persistence profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetPersistenceDestAddr(id string) (*LtmPersistenceDestAddr, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/destAddr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceDestAddr), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetPersistenceDestAddr")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistenceDestAddr)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistenceDestAddrList
//
//
// Virtual server Destination Address Affinity persistence profile configuration..
func (a LtmApi) GetPersistenceDestAddrList() (*LtmPersistenceDestAddrList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/destAddr"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistenceDestAddrList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistenceGlobalSettings
//
//
// Global settings for persistence.
//
// id is for ID of the resource.
func (a LtmApi) GetPersistenceGlobalSettings(id string) (*LtmPersistenceGlobalSettings, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/globalSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceGlobalSettings), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetPersistenceGlobalSettings")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistenceGlobalSettings)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistenceGlobalSettingsList
//
//
// Global settings for persistence..
func (a LtmApi) GetPersistenceGlobalSettingsList() (*LtmPersistenceGlobalSettingsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/globalSettings"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistenceGlobalSettingsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistenceHash
//
//
// Virtual server Hash persistence profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetPersistenceHash(id string) (*LtmPersistenceHash, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/hash/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceHash), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetPersistenceHash")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistenceHash)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistenceHashList
//
//
// Virtual server Hash persistence profile configuration..
func (a LtmApi) GetPersistenceHashList() (*LtmPersistenceHashList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/hash"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistenceHashList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistenceList
//
//
// Virtual server persistence configuration..
func (a LtmApi) GetPersistenceList() (*LtmPersistenceList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistenceList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistenceMsrdp
//
//
// Virtual server Microsoft Remote Desktop (MSRDP) persistence profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetPersistenceMsrdp(id string) (*LtmPersistenceMsrdp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/msrdp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceMsrdp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetPersistenceMsrdp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistenceMsrdp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistenceMsrdpList
//
//
// Virtual server Microsoft Remote Desktop (MSRDP) persistence profile configuration..
func (a LtmApi) GetPersistenceMsrdpList() (*LtmPersistenceMsrdpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/msrdp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistenceMsrdpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistencePersistRecords
//
//
// Displays or delete records in the persistence table..
//
// id is for ID of the resource.
func (a LtmApi) GetPersistencePersistRecords(id string) (*LtmPersistencePersistRecords, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/persistRecords/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistencePersistRecords), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetPersistencePersistRecords")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistencePersistRecords)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistencePersistRecordsList
//
//
// Displays or delete records in the persistence table...
func (a LtmApi) GetPersistencePersistRecordsList() (*LtmPersistencePersistRecordsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/persistRecords"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistencePersistRecordsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistenceSip
//
//
// Virtual server SIP persistence profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetPersistenceSip(id string) (*LtmPersistenceSip, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/sip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceSip), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetPersistenceSip")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistenceSip)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistenceSipList
//
//
// Virtual server SIP persistence profile configuration..
func (a LtmApi) GetPersistenceSipList() (*LtmPersistenceSipList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/sip"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistenceSipList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistenceSourceAddr
//
//
// Virtual server Source Address persistence profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetPersistenceSourceAddr(id string) (*LtmPersistenceSourceAddr, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/sourceAddr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceSourceAddr), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetPersistenceSourceAddr")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistenceSourceAddr)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistenceSourceAddrList
//
//
// Virtual server Source Address persistence profile configuration..
func (a LtmApi) GetPersistenceSourceAddrList() (*LtmPersistenceSourceAddrList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/sourceAddr"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistenceSourceAddrList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistenceSsl
//
//
// Virtual server SSL persistence profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetPersistenceSsl(id string) (*LtmPersistenceSsl, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/ssl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceSsl), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetPersistenceSsl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistenceSsl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistenceSslList
//
//
// Virtual server SSL persistence profile configuration..
func (a LtmApi) GetPersistenceSslList() (*LtmPersistenceSslList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/ssl"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistenceSslList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistenceUniversal
//
//
// Virtual server Universal persistence profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetPersistenceUniversal(id string) (*LtmPersistenceUniversal, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/universal/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceUniversal), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetPersistenceUniversal")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistenceUniversal)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPersistenceUniversalList
//
//
// Virtual server Universal persistence profile configuration..
func (a LtmApi) GetPersistenceUniversalList() (*LtmPersistenceUniversalList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/universal"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPersistenceUniversalList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPolicy
//
//
// Centralized Policy Matching configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetPolicy(id string) (*LtmPolicy, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicy), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetPolicy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPolicy)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPolicyList
//
//
// Centralized Policy Matching configuration..
func (a LtmApi) GetPolicyList() (*LtmPolicyList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPolicyList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPolicyRules
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetPolicyRules(id string) (*LtmPolicyRules, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/rules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicyRules), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetPolicyRules")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPolicyRules)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPolicyRulesActions
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetPolicyRulesActions(id string) (*LtmPolicyRulesActions, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/rules/actions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicyRulesActions), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetPolicyRulesActions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPolicyRulesActions)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPolicyRulesActionsList
//
//
// ..
func (a LtmApi) GetPolicyRulesActionsList() (*LtmPolicyRulesActionsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/rules/actions"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPolicyRulesActionsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPolicyRulesConditions
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetPolicyRulesConditions(id string) (*LtmPolicyRulesConditions, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/rules/conditions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicyRulesConditions), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetPolicyRulesConditions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPolicyRulesConditions)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPolicyRulesConditionsList
//
//
// ..
func (a LtmApi) GetPolicyRulesConditionsList() (*LtmPolicyRulesConditionsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/rules/conditions"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPolicyRulesConditionsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPolicyRulesList
//
//
// ..
func (a LtmApi) GetPolicyRulesList() (*LtmPolicyRulesList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/rules"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPolicyRulesList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPolicyStrategy
//
//
// Centralized Policy Matching rule selection strategy.
//
// id is for ID of the resource.
func (a LtmApi) GetPolicyStrategy(id string) (*LtmPolicyStrategy, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policyStrategy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicyStrategy), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetPolicyStrategy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPolicyStrategy)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPolicyStrategyList
//
//
// Centralized Policy Matching rule selection strategy..
func (a LtmApi) GetPolicyStrategyList() (*LtmPolicyStrategyList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policyStrategy"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPolicyStrategyList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPolicyStrategyOperands
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetPolicyStrategyOperands(id string) (*LtmPolicyStrategyOperands, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policyStrategy/operands/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicyStrategyOperands), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetPolicyStrategyOperands")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPolicyStrategyOperands)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPolicyStrategyOperandsList
//
//
// ..
func (a LtmApi) GetPolicyStrategyOperandsList() (*LtmPolicyStrategyOperandsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policyStrategy/operands"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPolicyStrategyOperandsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPool
//
//
// Load balancing pool configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetPool(id string) (*LtmPool, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/pool/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPool), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetPool")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPool)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPoolList
//
//
// Load balancing pool configuration..
func (a LtmApi) GetPoolList() (*LtmPoolList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/pool"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPoolList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPoolMembers
//
//
// Manage the set of pool members that are associated with a load balancing pool.
//
// pid is for ID of the parent resource
//
// id is for ID of the resource.
func (a LtmApi) GetPoolMembers(pid string, id string) (*LtmPoolMembers, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/pool/{pid}/members/{id}"
	path = strings.Replace(path, "{"+"pid"+"}", fmt.Sprintf("%v", pid), -1)
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'pid' is set
	if &pid == nil {
		return new(LtmPoolMembers), nil, errors.New("Missing required parameter 'pid' when calling LtmApi->GetPoolMembers")
	}
	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPoolMembers), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetPoolMembers")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPoolMembers)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetPoolMembersList
//
//
// Manage the set of pool members that are associated with a load balancing pool.
//
// pid is for ID of the parent resource.
func (a LtmApi) GetPoolMembersList(pid string) (*LtmPoolMembersList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/pool/{pid}/members"
	path = strings.Replace(path, "{"+"pid"+"}", fmt.Sprintf("%v", pid), -1)

	// verify the required parameter 'pid' is set
	if &pid == nil {
		return new(LtmPoolMembersList), nil, errors.New("Missing required parameter 'pid' when calling LtmApi->GetPoolMembersList")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmPoolMembersList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfile
//
//
// Virtual server profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfile(id string) (*LtmProfile, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileAnalytics
//
//
// Virtual server analytics profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileAnalytics(id string) (*LtmProfileAnalytics, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/analytics/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileAnalytics), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileAnalytics")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileAnalytics)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileAnalyticsAlerts
//
//
// Manage the set of analytics alerts that are associated with an analytics profile..
//
// id is for ID of the resource.
func (a LtmApi) GetProfileAnalyticsAlerts(id string) (*LtmProfileAnalyticsAlerts, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/analytics/alerts/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileAnalyticsAlerts), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileAnalyticsAlerts")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileAnalyticsAlerts)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileAnalyticsAlertsList
//
//
// Manage the set of analytics alerts that are associated with an analytics profile...
func (a LtmApi) GetProfileAnalyticsAlertsList() (*LtmProfileAnalyticsAlertsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/analytics/alerts"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileAnalyticsAlertsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileAnalyticsList
//
//
// Virtual server analytics profile configuration..
func (a LtmApi) GetProfileAnalyticsList() (*LtmProfileAnalyticsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/analytics"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileAnalyticsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileAnalyticsTrafficCapture
//
//
// Manage the set of analytics alerts that are associated with an analytics profile..
//
// id is for ID of the resource.
func (a LtmApi) GetProfileAnalyticsTrafficCapture(id string) (*LtmProfileAnalyticsTrafficCapture, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/analytics/trafficCapture/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileAnalyticsTrafficCapture), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileAnalyticsTrafficCapture")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileAnalyticsTrafficCapture)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileAnalyticsTrafficCaptureList
//
//
// Manage the set of analytics alerts that are associated with an analytics profile...
func (a LtmApi) GetProfileAnalyticsTrafficCaptureList() (*LtmProfileAnalyticsTrafficCaptureList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/analytics/trafficCapture"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileAnalyticsTrafficCaptureList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileCertificateAuthority
//
//
// Virtual server Certificate Authority profile configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetProfileCertificateAuthority(id string) (*LtmProfileCertificateAuthority, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/certificateAuthority/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileCertificateAuthority), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileCertificateAuthority")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileCertificateAuthority)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileCertificateAuthorityList
//
//
// Virtual server Certificate Authority profile configuration...
func (a LtmApi) GetProfileCertificateAuthorityList() (*LtmProfileCertificateAuthorityList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/certificateAuthority"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileCertificateAuthorityList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileClassification
//
//
// Virtual server classification profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileClassification(id string) (*LtmProfileClassification, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/classification/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileClassification), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileClassification")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileClassification)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileClassificationList
//
//
// Virtual server classification profile configuration..
func (a LtmApi) GetProfileClassificationList() (*LtmProfileClassificationList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/classification"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileClassificationList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileClientLdap
//
//
// Virtual server Client LDAP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileClientLdap(id string) (*LtmProfileClientLdap, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/clientLdap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileClientLdap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileClientLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileClientLdap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileClientLdapList
//
//
// Virtual server Client LDAP traffic profile configuration..
func (a LtmApi) GetProfileClientLdapList() (*LtmProfileClientLdapList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/clientLdap"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileClientLdapList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileClientSsl
//
//
// Virtual server client-side proxy SSL profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileClientSsl(id string) (*LtmProfileClientSsl, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/clientSsl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileClientSsl), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileClientSsl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileClientSsl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileClientSslList
//
//
// Virtual server client-side proxy SSL profile configuration..
func (a LtmApi) GetProfileClientSslList() (*LtmProfileClientSslList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/clientSsl"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileClientSslList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileDhcpv4
//
//
// Dynamic Host Configuration Protocol, DHCPv4, profile to manage DHCPv4 network traffic..
//
// id is for ID of the resource.
func (a LtmApi) GetProfileDhcpv4(id string) (*LtmProfileDhcpv4, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dhcpv4/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileDhcpv4), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileDhcpv4")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileDhcpv4)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileDhcpv4List
//
//
// Dynamic Host Configuration Protocol, DHCPv4, profile to manage DHCPv4 network traffic...
func (a LtmApi) GetProfileDhcpv4List() (*LtmProfileDhcpv4List, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dhcpv4"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileDhcpv4List)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileDhcpv6
//
//
// Dynamic Host Configuration Protocol, DHCPv6, profile to manage DHCPv6 network traffic..
//
// id is for ID of the resource.
func (a LtmApi) GetProfileDhcpv6(id string) (*LtmProfileDhcpv6, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dhcpv6/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileDhcpv6), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileDhcpv6")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileDhcpv6)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileDhcpv6List
//
//
// Dynamic Host Configuration Protocol, DHCPv6, profile to manage DHCPv6 network traffic...
func (a LtmApi) GetProfileDhcpv6List() (*LtmProfileDhcpv6List, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dhcpv6"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileDhcpv6List)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileDiameter
//
//
// Virtual server Diameter traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileDiameter(id string) (*LtmProfileDiameter, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/diameter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileDiameter), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileDiameter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileDiameter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileDiameterList
//
//
// Virtual server Diameter traffic profile configuration..
func (a LtmApi) GetProfileDiameterList() (*LtmProfileDiameterList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/diameter"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileDiameterList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileDns
//
//
// Virtual server DNS traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileDns(id string) (*LtmProfileDns, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dns/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileDns), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileDns")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileDns)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileDnsList
//
//
// Virtual server DNS traffic profile configuration..
func (a LtmApi) GetProfileDnsList() (*LtmProfileDnsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dns"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileDnsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileDnsLogging
//
//
// High-speed logging settings for the DNS profile..
//
// id is for ID of the resource.
func (a LtmApi) GetProfileDnsLogging(id string) (*LtmProfileDnsLogging, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dnsLogging/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileDnsLogging), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileDnsLogging")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileDnsLogging)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileDnsLoggingList
//
//
// High-speed logging settings for the DNS profile...
func (a LtmApi) GetProfileDnsLoggingList() (*LtmProfileDnsLoggingList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dnsLogging"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileDnsLoggingList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileFasthttp
//
//
// Virtual server Fast HTTP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileFasthttp(id string) (*LtmProfileFasthttp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/fasthttp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileFasthttp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileFasthttp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileFasthttp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileFasthttpList
//
//
// Virtual server Fast HTTP traffic profile configuration..
func (a LtmApi) GetProfileFasthttpList() (*LtmProfileFasthttpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/fasthttp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileFasthttpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileFastl4
//
//
// Virtual server FastL4 traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileFastl4(id string) (*LtmProfileFastl4, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/fastl4/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileFastl4), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileFastl4")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileFastl4)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileFastl4List
//
//
// Virtual server FastL4 traffic profile configuration..
func (a LtmApi) GetProfileFastl4List() (*LtmProfileFastl4List, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/fastl4"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileFastl4List)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileFix
//
//
// Virtual server Financial Information eXchange(FIX) profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileFix(id string) (*LtmProfileFix, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/fix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileFix), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileFix")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileFix)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileFixList
//
//
// Virtual server Financial Information eXchange(FIX) profile configuration..
func (a LtmApi) GetProfileFixList() (*LtmProfileFixList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/fix"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileFixList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileFtp
//
//
// Virtual server FTP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileFtp(id string) (*LtmProfileFtp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ftp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileFtp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileFtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileFtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileFtpList
//
//
// Virtual server FTP traffic profile configuration..
func (a LtmApi) GetProfileFtpList() (*LtmProfileFtpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ftp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileFtpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileGtp
//
//
// Virtual server GTP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileGtp(id string) (*LtmProfileGtp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/gtp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileGtp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileGtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileGtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileGtpList
//
//
// Virtual server GTP traffic profile configuration..
func (a LtmApi) GetProfileGtpList() (*LtmProfileGtpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/gtp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileGtpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileHtml
//
//
// Virtual server HTML profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileHtml(id string) (*LtmProfileHtml, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/html/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileHtml), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileHtml")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileHtml)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileHtmlList
//
//
// Virtual server HTML profile configuration..
func (a LtmApi) GetProfileHtmlList() (*LtmProfileHtmlList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/html"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileHtmlList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileHttp
//
//
// Virtual server HTTP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileHttp(id string) (*LtmProfileHttp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/http/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileHttp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileHttp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileHttp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileHttp2
//
//
// Virtual server HTTP/2 traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileHttp2(id string) (*LtmProfileHttp2, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/http2/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileHttp2), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileHttp2")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileHttp2)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileHttp2List
//
//
// Virtual server HTTP/2 traffic profile configuration..
func (a LtmApi) GetProfileHttp2List() (*LtmProfileHttp2List, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/http2"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileHttp2List)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileHttpCompression
//
//
// Virtual server HTTP compression profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileHttpCompression(id string) (*LtmProfileHttpCompression, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/httpCompression/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileHttpCompression), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileHttpCompression")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileHttpCompression)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileHttpCompressionList
//
//
// Virtual server HTTP compression profile configuration..
func (a LtmApi) GetProfileHttpCompressionList() (*LtmProfileHttpCompressionList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/httpCompression"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileHttpCompressionList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileHttpList
//
//
// Virtual server HTTP traffic profile configuration..
func (a LtmApi) GetProfileHttpList() (*LtmProfileHttpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/http"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileHttpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileIcap
//
//
// Virtual server Internet Content Adaptation Protocol (ICAP) profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileIcap(id string) (*LtmProfileIcap, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/icap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileIcap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileIcap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileIcap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileIcapList
//
//
// Virtual server Internet Content Adaptation Protocol (ICAP) profile configuration..
func (a LtmApi) GetProfileIcapList() (*LtmProfileIcapList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/icap"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileIcapList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileIiop
//
//
// Virtual server IIOP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileIiop(id string) (*LtmProfileIiop, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/iiop/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileIiop), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileIiop")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileIiop)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileIiopList
//
//
// Virtual server IIOP traffic profile configuration..
func (a LtmApi) GetProfileIiopList() (*LtmProfileIiopList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/iiop"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileIiopList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileIpother
//
//
// Virtual server IPOTHER for non-TCP and non-UDP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileIpother(id string) (*LtmProfileIpother, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ipother/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileIpother), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileIpother")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileIpother)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileIpotherList
//
//
// Virtual server IPOTHER for non-TCP and non-UDP traffic profile configuration..
func (a LtmApi) GetProfileIpotherList() (*LtmProfileIpotherList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ipother"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileIpotherList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileList
//
//
// Virtual server profile configuration..
func (a LtmApi) GetProfileList() (*LtmProfileList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileMblb
//
//
// MBLB profile configuration (experimental).
//
// id is for ID of the resource.
func (a LtmApi) GetProfileMblb(id string) (*LtmProfileMblb, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/mblb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileMblb), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileMblb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileMblb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileMblbList
//
//
// MBLB profile configuration (experimental)..
func (a LtmApi) GetProfileMblbList() (*LtmProfileMblbList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/mblb"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileMblbList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileMssql
//
//
// Virtual server MSSQL profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileMssql(id string) (*LtmProfileMssql, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/mssql/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileMssql), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileMssql")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileMssql)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileMssqlList
//
//
// Virtual server MSSQL profile configuration..
func (a LtmApi) GetProfileMssqlList() (*LtmProfileMssqlList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/mssql"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileMssqlList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileNtlm
//
//
// Virtual server NT Lan Manager profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileNtlm(id string) (*LtmProfileNtlm, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ntlm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileNtlm), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileNtlm")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileNtlm)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileNtlmList
//
//
// Virtual server NT Lan Manager profile configuration..
func (a LtmApi) GetProfileNtlmList() (*LtmProfileNtlmList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ntlm"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileNtlmList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileOcspStaplingParams
//
//
// OCSP Stapling Parameters for clientssl profiles. This object should be associated with a cert-key-chain object in a clientssl profile..
//
// id is for ID of the resource.
func (a LtmApi) GetProfileOcspStaplingParams(id string) (*LtmProfileOcspStaplingParams, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ocspStaplingParams/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileOcspStaplingParams), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileOcspStaplingParams")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileOcspStaplingParams)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileOcspStaplingParamsList
//
//
// OCSP Stapling Parameters for clientssl profiles. This object should be associated with a cert-key-chain object in a clientssl profile...
func (a LtmApi) GetProfileOcspStaplingParamsList() (*LtmProfileOcspStaplingParamsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ocspStaplingParams"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileOcspStaplingParamsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileOneConnect
//
//
// Virtual server OneConnect profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileOneConnect(id string) (*LtmProfileOneConnect, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/oneConnect/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileOneConnect), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileOneConnect")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileOneConnect)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileOneConnectList
//
//
// Virtual server OneConnect profile configuration..
func (a LtmApi) GetProfileOneConnectList() (*LtmProfileOneConnectList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/oneConnect"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileOneConnectList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfilePcp
//
//
// LSN Pool PCP configuration profile.
//
// id is for ID of the resource.
func (a LtmApi) GetProfilePcp(id string) (*LtmProfilePcp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/pcp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfilePcp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfilePcp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfilePcp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfilePcpList
//
//
// LSN Pool PCP configuration profile..
func (a LtmApi) GetProfilePcpList() (*LtmProfilePcpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/pcp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfilePcpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfilePptp
//
//
// Virtual server Point to Point Tunneling Protocol (PPTP) profile configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetProfilePptp(id string) (*LtmProfilePptp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/pptp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfilePptp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfilePptp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfilePptp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfilePptpList
//
//
// Virtual server Point to Point Tunneling Protocol (PPTP) profile configuration...
func (a LtmApi) GetProfilePptpList() (*LtmProfilePptpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/pptp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfilePptpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileQoe
//
//
// Virtual server Quality of Experience profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileQoe(id string) (*LtmProfileQoe, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/qoe/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileQoe), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileQoe")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileQoe)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileQoeList
//
//
// Virtual server Quality of Experience profile configuration..
func (a LtmApi) GetProfileQoeList() (*LtmProfileQoeList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/qoe"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileQoeList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileRadius
//
//
// Virtual server Radius traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileRadius(id string) (*LtmProfileRadius, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/radius/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRadius), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileRadius")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileRadius)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileRadiusList
//
//
// Virtual server Radius traffic profile configuration..
func (a LtmApi) GetProfileRadiusList() (*LtmProfileRadiusList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/radius"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileRadiusList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileRamcache
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetProfileRamcache(id string) (*LtmProfileRamcache, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ramcache/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRamcache), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileRamcache")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileRamcache)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileRamcacheList
//
//
// ..
func (a LtmApi) GetProfileRamcacheList() (*LtmProfileRamcacheList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ramcache"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileRamcacheList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileRequestAdapt
//
//
// Virtual server HTTP request adaptation profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileRequestAdapt(id string) (*LtmProfileRequestAdapt, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/requestAdapt/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRequestAdapt), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileRequestAdapt")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileRequestAdapt)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileRequestAdaptList
//
//
// Virtual server HTTP request adaptation profile configuration..
func (a LtmApi) GetProfileRequestAdaptList() (*LtmProfileRequestAdaptList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/requestAdapt"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileRequestAdaptList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileRequestLog
//
//
// Virtual server request logging profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileRequestLog(id string) (*LtmProfileRequestLog, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/requestLog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRequestLog), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileRequestLog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileRequestLog)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileRequestLogList
//
//
// Virtual server request logging profile configuration..
func (a LtmApi) GetProfileRequestLogList() (*LtmProfileRequestLogList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/requestLog"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileRequestLogList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileResponseAdapt
//
//
// Virtual server HTTP response adaptation profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileResponseAdapt(id string) (*LtmProfileResponseAdapt, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/responseAdapt/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileResponseAdapt), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileResponseAdapt")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileResponseAdapt)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileResponseAdaptList
//
//
// Virtual server HTTP response adaptation profile configuration..
func (a LtmApi) GetProfileResponseAdaptList() (*LtmProfileResponseAdaptList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/responseAdapt"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileResponseAdaptList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileRewrite
//
//
// Virtual server Rewrite profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileRewrite(id string) (*LtmProfileRewrite, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/rewrite/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRewrite), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileRewrite")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileRewrite)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileRewriteList
//
//
// Virtual server Rewrite profile configuration..
func (a LtmApi) GetProfileRewriteList() (*LtmProfileRewriteList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/rewrite"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileRewriteList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileRewriteUriRules
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetProfileRewriteUriRules(id string) (*LtmProfileRewriteUriRules, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/rewrite/uriRules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRewriteUriRules), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileRewriteUriRules")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileRewriteUriRules)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileRewriteUriRulesList
//
//
// ..
func (a LtmApi) GetProfileRewriteUriRulesList() (*LtmProfileRewriteUriRulesList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/rewrite/uriRules"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileRewriteUriRulesList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileRtsp
//
//
// Virtual server RTSP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileRtsp(id string) (*LtmProfileRtsp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/rtsp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRtsp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileRtsp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileRtsp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileRtspList
//
//
// Virtual server RTSP traffic profile configuration..
func (a LtmApi) GetProfileRtspList() (*LtmProfileRtspList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/rtsp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileRtspList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileSctp
//
//
// Virtual server SCTP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileSctp(id string) (*LtmProfileSctp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/sctp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSctp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileSctp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileSctp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileSctpList
//
//
// Virtual server SCTP traffic profile configuration..
func (a LtmApi) GetProfileSctpList() (*LtmProfileSctpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/sctp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileSctpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileServerLdap
//
//
// Virtual server Server LDAP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileServerLdap(id string) (*LtmProfileServerLdap, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/serverLdap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileServerLdap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileServerLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileServerLdap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileServerLdapList
//
//
// Virtual server Server LDAP traffic profile configuration..
func (a LtmApi) GetProfileServerLdapList() (*LtmProfileServerLdapList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/serverLdap"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileServerLdapList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileServerSsl
//
//
// Virtual server server-side proxy SSL profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileServerSsl(id string) (*LtmProfileServerSsl, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/serverSsl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileServerSsl), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileServerSsl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileServerSsl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileServerSslList
//
//
// Virtual server server-side proxy SSL profile configuration..
func (a LtmApi) GetProfileServerSslList() (*LtmProfileServerSslList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/serverSsl"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileServerSslList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileSip
//
//
// Virtual server SIP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileSip(id string) (*LtmProfileSip, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/sip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSip), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileSip")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileSip)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileSipList
//
//
// Virtual server SIP traffic profile configuration..
func (a LtmApi) GetProfileSipList() (*LtmProfileSipList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/sip"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileSipList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileSmtp
//
//
// Virtual server SMTP profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileSmtp(id string) (*LtmProfileSmtp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/smtp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSmtp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileSmtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileSmtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileSmtpList
//
//
// Virtual server SMTP profile configuration..
func (a LtmApi) GetProfileSmtpList() (*LtmProfileSmtpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/smtp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileSmtpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileSmtps
//
//
// Virtual server SMTPs traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileSmtps(id string) (*LtmProfileSmtps, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/smtps/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSmtps), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileSmtps")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileSmtps)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileSmtpsList
//
//
// Virtual server SMTPs traffic profile configuration..
func (a LtmApi) GetProfileSmtpsList() (*LtmProfileSmtpsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/smtps"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileSmtpsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileSocks
//
//
// Virtual server SOCKS traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileSocks(id string) (*LtmProfileSocks, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/socks/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSocks), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileSocks")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileSocks)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileSocksList
//
//
// Virtual server SOCKS traffic profile configuration..
func (a LtmApi) GetProfileSocksList() (*LtmProfileSocksList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/socks"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileSocksList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileSpdy
//
//
// Virtual server SPDY traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileSpdy(id string) (*LtmProfileSpdy, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/spdy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSpdy), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileSpdy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileSpdy)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileSpdyList
//
//
// Virtual server SPDY traffic profile configuration..
func (a LtmApi) GetProfileSpdyList() (*LtmProfileSpdyList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/spdy"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileSpdyList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileStatistics
//
//
// Virtual server custom statistics configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileStatistics(id string) (*LtmProfileStatistics, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/statistics/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileStatistics), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileStatistics")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileStatistics)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileStatisticsList
//
//
// Virtual server custom statistics configuration..
func (a LtmApi) GetProfileStatisticsList() (*LtmProfileStatisticsList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/statistics"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileStatisticsList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileStream
//
//
// Virtual server Stream traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileStream(id string) (*LtmProfileStream, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/stream/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileStream), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileStream")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileStream)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileStreamList
//
//
// Virtual server Stream traffic profile configuration..
func (a LtmApi) GetProfileStreamList() (*LtmProfileStreamList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/stream"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileStreamList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileTcp
//
//
// Virtual server TCP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileTcp(id string) (*LtmProfileTcp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/tcp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileTcp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileTcp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileTcp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileTcpList
//
//
// Virtual server TCP traffic profile configuration..
func (a LtmApi) GetProfileTcpList() (*LtmProfileTcpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/tcp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileTcpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileTftp
//
//
// Virtual server TFTP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileTftp(id string) (*LtmProfileTftp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/tftp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileTftp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileTftp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileTftp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileTftpList
//
//
// Virtual server TFTP traffic profile configuration..
func (a LtmApi) GetProfileTftpList() (*LtmProfileTftpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/tftp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileTftpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileUdp
//
//
// Virtual server UDP traffic profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileUdp(id string) (*LtmProfileUdp, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/udp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileUdp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileUdp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileUdp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileUdpList
//
//
// Virtual server UDP traffic profile configuration..
func (a LtmApi) GetProfileUdpList() (*LtmProfileUdpList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/udp"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileUdpList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileWaCacheList
//
//
// ..
func (a LtmApi) GetProfileWaCacheList() (*LtmProfileWaCacheList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/waCache"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileWaCacheList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileWebAcceleration
//
//
// Virtual server Web Acceleration profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileWebAcceleration(id string) (*LtmProfileWebAcceleration, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/webAcceleration/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileWebAcceleration), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileWebAcceleration")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileWebAcceleration)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileWebAccelerationList
//
//
// Virtual server Web Acceleration profile configuration..
func (a LtmApi) GetProfileWebAccelerationList() (*LtmProfileWebAccelerationList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/webAcceleration"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileWebAccelerationList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileWebSecurity
//
//
// Virtual server Web Security profile configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileWebSecurity(id string) (*LtmProfileWebSecurity, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/webSecurity/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileWebSecurity), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileWebSecurity")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileWebSecurity)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileWebSecurityList
//
//
// Virtual server Web Security profile configuration..
func (a LtmApi) GetProfileWebSecurityList() (*LtmProfileWebSecurityList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/webSecurity"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileWebSecurityList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileXml
//
//
// Virtual server XML configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetProfileXml(id string) (*LtmProfileXml, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/xml/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileXml), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetProfileXml")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileXml)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetProfileXmlList
//
//
// Virtual server XML configuration..
func (a LtmApi) GetProfileXmlList() (*LtmProfileXmlList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/xml"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmProfileXmlList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetRule
//
//
// iRules configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetRule(id string) (*LtmRule, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/rule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmRule), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetRule")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmRule)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetRuleList
//
//
// iRules configuration..
func (a LtmApi) GetRuleList() (*LtmRuleList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/rule"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmRuleList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSnat
//
//
// Secure network address translation (SNAT) configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetSnat(id string) (*LtmSnat, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/snat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmSnat), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetSnat")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmSnat)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSnatList
//
//
// Secure network address translation (SNAT) configuration..
func (a LtmApi) GetSnatList() (*LtmSnatList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/snat"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmSnatList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSnatTranslation
//
//
// SNAT translation address configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetSnatTranslation(id string) (*LtmSnatTranslation, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/snatTranslation/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmSnatTranslation), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetSnatTranslation")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmSnatTranslation)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSnatTranslationList
//
//
// SNAT translation address configuration..
func (a LtmApi) GetSnatTranslationList() (*LtmSnatTranslationList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/snatTranslation"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmSnatTranslationList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSnatpool
//
//
// Collections of SNAT translation addresses.
//
// id is for ID of the resource.
func (a LtmApi) GetSnatpool(id string) (*LtmSnatpool, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/snatpool/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmSnatpool), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetSnatpool")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmSnatpool)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetSnatpoolList
//
//
// Collections of SNAT translation addresses..
func (a LtmApi) GetSnatpoolList() (*LtmSnatpoolList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/snatpool"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmSnatpoolList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetTacdb
//
//
// TACDB configuration..
//
// id is for ID of the resource.
func (a LtmApi) GetTacdb(id string) (*LtmTacdb, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/tacdb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmTacdb), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetTacdb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmTacdb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetTacdbCustomdb
//
//
// Custom tacdb for detection of device type and OS..
//
// id is for ID of the resource.
func (a LtmApi) GetTacdbCustomdb(id string) (*LtmTacdbCustomdb, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/tacdb/customdb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmTacdbCustomdb), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetTacdbCustomdb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmTacdbCustomdb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetTacdbCustomdbFile
//
//
// File object for custom tacdb. User should NOT use it. Daemon use it internally..
//
// id is for ID of the resource.
func (a LtmApi) GetTacdbCustomdbFile(id string) (*LtmTacdbCustomdbFile, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/tacdb/customdbFile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmTacdbCustomdbFile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetTacdbCustomdbFile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmTacdbCustomdbFile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetTacdbCustomdbFileList
//
//
// File object for custom tacdb. User should NOT use it. Daemon use it internally...
func (a LtmApi) GetTacdbCustomdbFileList() (*LtmTacdbCustomdbFileList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/tacdb/customdbFile"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmTacdbCustomdbFileList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetTacdbCustomdbList
//
//
// Custom tacdb for detection of device type and OS...
func (a LtmApi) GetTacdbCustomdbList() (*LtmTacdbCustomdbList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/tacdb/customdb"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmTacdbCustomdbList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetTacdbList
//
//
// TACDB configuration...
func (a LtmApi) GetTacdbList() (*LtmTacdbList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/tacdb"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmTacdbList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetTrafficClass
//
//
// Traffic Class Configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetTrafficClass(id string) (*LtmTrafficClass, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/trafficClass/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmTrafficClass), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetTrafficClass")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmTrafficClass)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetTrafficClassList
//
//
// Traffic Class Configuration..
func (a LtmApi) GetTrafficClassList() (*LtmTrafficClassList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/trafficClass"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmTrafficClassList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetUrlcatQuery
//
//
// Query url category.
//
// id is for ID of the resource.
func (a LtmApi) GetUrlcatQuery(id string) (*LtmUrlcatQuery, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/urlcatQuery/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmUrlcatQuery), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetUrlcatQuery")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmUrlcatQuery)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetUrlcatQueryList
//
//
// Query url category..
func (a LtmApi) GetUrlcatQueryList() (*LtmUrlcatQueryList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/urlcatQuery"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmUrlcatQueryList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetVirtual
//
//
// Virtual server configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetVirtual(id string) (*LtmVirtual, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmVirtual), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetVirtual")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmVirtual)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetVirtualAddress
//
//
// Virtual server IP address configuration.
//
// id is for ID of the resource.
func (a LtmApi) GetVirtualAddress(id string) (*LtmVirtualAddress, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtualAddress/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmVirtualAddress), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetVirtualAddress")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmVirtualAddress)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetVirtualAddressList
//
//
// Virtual server IP address configuration..
func (a LtmApi) GetVirtualAddressList() (*LtmVirtualAddressList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtualAddress"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmVirtualAddressList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetVirtualFwActive
//
//
// Firewall policy rule entry.
//
// id is for ID of the resource.
func (a LtmApi) GetVirtualFwActive(id string) (*LtmVirtualFwActive, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/fwActive/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmVirtualFwActive), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetVirtualFwActive")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmVirtualFwActive)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetVirtualFwActiveList
//
//
// Firewall policy rule entry..
func (a LtmApi) GetVirtualFwActiveList() (*LtmVirtualFwActiveList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/fwActive"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmVirtualFwActiveList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetVirtualFwEnforcedPolicyRules
//
//
// Firewall policy rule entry.
//
// id is for ID of the resource.
func (a LtmApi) GetVirtualFwEnforcedPolicyRules(id string) (*LtmVirtualFwEnforcedPolicyRules, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/fwEnforcedPolicyRules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmVirtualFwEnforcedPolicyRules), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetVirtualFwEnforcedPolicyRules")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmVirtualFwEnforcedPolicyRules)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetVirtualFwEnforcedPolicyRulesList
//
//
// Firewall policy rule entry..
func (a LtmApi) GetVirtualFwEnforcedPolicyRulesList() (*LtmVirtualFwEnforcedPolicyRulesList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/fwEnforcedPolicyRules"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmVirtualFwEnforcedPolicyRulesList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetVirtualFwStagedPolicyRules
//
//
// Firewall policy rule entry.
//
// id is for ID of the resource.
func (a LtmApi) GetVirtualFwStagedPolicyRules(id string) (*LtmVirtualFwStagedPolicyRules, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/fwStagedPolicyRules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmVirtualFwStagedPolicyRules), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetVirtualFwStagedPolicyRules")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmVirtualFwStagedPolicyRules)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetVirtualFwStagedPolicyRulesList
//
//
// Firewall policy rule entry..
func (a LtmApi) GetVirtualFwStagedPolicyRulesList() (*LtmVirtualFwStagedPolicyRulesList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/fwStagedPolicyRules"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmVirtualFwStagedPolicyRulesList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetVirtualList
//
//
// Virtual server configuration..
func (a LtmApi) GetVirtualList() (*LtmVirtualList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmVirtualList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetVirtualPolicies
//
//
// .
//
// id is for ID of the resource.
func (a LtmApi) GetVirtualPolicies(id string) (*LtmVirtualPolicies, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/policies/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmVirtualPolicies), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetVirtualPolicies")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmVirtualPolicies)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetVirtualPoliciesList
//
//
// ..
func (a LtmApi) GetVirtualPoliciesList() (*LtmVirtualPoliciesList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/policies"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmVirtualPoliciesList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetVirtualProfiles
//
//
// Manage the set of profiles that are associated with virtual servers.
//
// id is for ID of the resource.
func (a LtmApi) GetVirtualProfiles(id string) (*LtmVirtualProfiles, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/profiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmVirtualProfiles), nil, errors.New("Missing required parameter 'id' when calling LtmApi->GetVirtualProfiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmVirtualProfiles)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// GetVirtualProfilesList
//
//
// Manage the set of profiles that are associated with virtual servers..
func (a LtmApi) GetVirtualProfilesList() (*LtmVirtualProfilesList, *APIResponse, error) {

	var httpMethod = "Get"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/profiles"

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	var successPayload = new(LtmVirtualProfilesList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchAlgLogProfile
//
//
// Defines the configuration for logging of ALG flows..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchAlgLogProfile(id string, object LtmAlgLogProfile) (*LtmAlgLogProfile, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/algLogProfile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAlgLogProfile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchAlgLogProfile")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAlgLogProfile), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchAlgLogProfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAlgLogProfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchAuthCrldpServer
//
//
// Certificate Revocation List Distribution Point (CRDLP) server configuration, for use with a CRLDP authentication profile.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchAuthCrldpServer(id string, object LtmAuthCrldpServer) (*LtmAuthCrldpServer, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/crldpServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthCrldpServer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchAuthCrldpServer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthCrldpServer), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchAuthCrldpServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthCrldpServer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchAuthKerberosDelegation
//
//
// Kerberos configuration for remote client authentication.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchAuthKerberosDelegation(id string, object LtmAuthKerberosDelegation) (*LtmAuthKerberosDelegation, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/kerberosDelegation/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthKerberosDelegation), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchAuthKerberosDelegation")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthKerberosDelegation), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchAuthKerberosDelegation")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthKerberosDelegation)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchAuthLdap
//
//
// LDAP configuration for remote LDAP client authentication.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchAuthLdap(id string, object LtmAuthLdap) (*LtmAuthLdap, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/ldap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthLdap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchAuthLdap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthLdap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchAuthLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthLdap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchAuthOcspResponder
//
//
// Online Certificate System Protocol (OCSP) responder configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchAuthOcspResponder(id string, object LtmAuthOcspResponder) (*LtmAuthOcspResponder, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/ocspResponder/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthOcspResponder), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchAuthOcspResponder")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthOcspResponder), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchAuthOcspResponder")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthOcspResponder)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchAuthProfile
//
//
// Virtual server traffic Authentication profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchAuthProfile(id string, object LtmAuthProfile) (*LtmAuthProfile, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/profile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthProfile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchAuthProfile")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthProfile), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchAuthProfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthProfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchAuthRadius
//
//
// RADIUS configuration for remote RADIUS client authentication.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchAuthRadius(id string, object LtmAuthRadius) (*LtmAuthRadius, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/radius/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthRadius), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchAuthRadius")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthRadius), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchAuthRadius")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthRadius)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchAuthRadiusServer
//
//
// RADIUS server configuration for use with RADIUS authentication profiles.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchAuthRadiusServer(id string, object LtmAuthRadiusServer) (*LtmAuthRadiusServer, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/radiusServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthRadiusServer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchAuthRadiusServer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthRadiusServer), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchAuthRadiusServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthRadiusServer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchAuthSslCcLdap
//
//
// SSL client certificate configuration, for use with remote SSL-based LDAP authorization.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchAuthSslCcLdap(id string, object LtmAuthSslCcLdap) (*LtmAuthSslCcLdap, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/sslCcLdap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthSslCcLdap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchAuthSslCcLdap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthSslCcLdap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchAuthSslCcLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthSslCcLdap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchAuthSslCrldp
//
//
// SSL client certificate configuration, for use with remote SSL-based CRLDP authorization.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchAuthSslCrldp(id string, object LtmAuthSslCrldp) (*LtmAuthSslCrldp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/sslCrldp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthSslCrldp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchAuthSslCrldp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthSslCrldp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchAuthSslCrldp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthSslCrldp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchAuthSslOcsp
//
//
// OCSP configuration for implementing remote OCSP-based client authentication.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchAuthSslOcsp(id string, object LtmAuthSslOcsp) (*LtmAuthSslOcsp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/sslOcsp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthSslOcsp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchAuthSslOcsp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthSslOcsp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchAuthSslOcsp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthSslOcsp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchAuthTacacs
//
//
// TACACS+ configuration for remote TACACS+ client authentication.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchAuthTacacs(id string, object LtmAuthTacacs) (*LtmAuthTacacs, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/tacacs/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthTacacs), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchAuthTacacs")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthTacacs), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchAuthTacacs")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthTacacs)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchClassificationApplication
//
//
// Traffic Classification Application.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchClassificationApplication(id string, object LtmClassificationApplication) (*LtmClassificationApplication, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/application/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationApplication), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchClassificationApplication")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationApplication), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchClassificationApplication")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationApplication)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchClassificationCategory
//
//
// Traffic Classification Category.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchClassificationCategory(id string, object LtmClassificationCategory) (*LtmClassificationCategory, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/category/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationCategory), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchClassificationCategory")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationCategory), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchClassificationCategory")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationCategory)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchClassificationSignatureUpdateSchedule
//
//
// Configure scheduling for classification signature updates..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchClassificationSignatureUpdateSchedule(id string, object LtmClassificationSignatureUpdateSchedule) (*LtmClassificationSignatureUpdateSchedule, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/signatureUpdateSchedule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationSignatureUpdateSchedule), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchClassificationSignatureUpdateSchedule")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationSignatureUpdateSchedule), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchClassificationSignatureUpdateSchedule")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationSignatureUpdateSchedule)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchClassificationSignatureVersion
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchClassificationSignatureVersion(id string, object LtmClassificationSignatureVersion) (*LtmClassificationSignatureVersion, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/signatureVersion/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationSignatureVersion), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchClassificationSignatureVersion")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationSignatureVersion), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchClassificationSignatureVersion")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationSignatureVersion)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchClassificationUrlCatPolicy
//
//
// URL Categorization policy.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchClassificationUrlCatPolicy(id string, object LtmClassificationUrlCatPolicy) (*LtmClassificationUrlCatPolicy, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urlCatPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationUrlCatPolicy), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchClassificationUrlCatPolicy")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationUrlCatPolicy), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchClassificationUrlCatPolicy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationUrlCatPolicy)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchClassificationUrlCategory
//
//
// URL Classification Category.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchClassificationUrlCategory(id string, object LtmClassificationUrlCategory) (*LtmClassificationUrlCategory, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urlCategory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationUrlCategory), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchClassificationUrlCategory")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationUrlCategory), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchClassificationUrlCategory")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationUrlCategory)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchClassificationUrldbFeedList
//
//
// Reusable URLDB feed lists for URL Categorization..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchClassificationUrldbFeedList(id string, object LtmClassificationUrldbFeedList) (*LtmClassificationUrldbFeedList, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urldbFeedList/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationUrldbFeedList), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchClassificationUrldbFeedList")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationUrldbFeedList), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchClassificationUrldbFeedList")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationUrldbFeedList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchClassificationUrldbFile
//
//
// File object for custom url category database..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchClassificationUrldbFile(id string, object LtmClassificationUrldbFile) (*LtmClassificationUrldbFile, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urldbFile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationUrldbFile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchClassificationUrldbFile")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationUrldbFile), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchClassificationUrldbFile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationUrldbFile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDataGroupExternal
//
//
// External data group configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchDataGroupExternal(id string, object LtmDataGroupExternal) (*LtmDataGroupExternal, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dataGroup/external/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDataGroupExternal), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchDataGroupExternal")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDataGroupExternal), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchDataGroupExternal")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDataGroupExternal)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDataGroupInternal
//
//
// Internal data group configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchDataGroupInternal(id string, object LtmDataGroupInternal) (*LtmDataGroupInternal, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dataGroup/internal/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDataGroupInternal), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchDataGroupInternal")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDataGroupInternal), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchDataGroupInternal")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDataGroupInternal)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDefaultNodeMonitor
//
//
// Configure the default-monitor rule.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchDefaultNodeMonitor(id string, object LtmDefaultNodeMonitor) (*LtmDefaultNodeMonitor, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/defaultNodeMonitor/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDefaultNodeMonitor), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchDefaultNodeMonitor")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDefaultNodeMonitor), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchDefaultNodeMonitor")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDefaultNodeMonitor)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDnsAnalyticsGlobalSettings
//
//
// AVR DNS statistics global settings affecting all DNS listeners..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchDnsAnalyticsGlobalSettings(id string, object LtmDnsAnalyticsGlobalSettings) (*LtmDnsAnalyticsGlobalSettings, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/analytics/globalSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsAnalyticsGlobalSettings), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchDnsAnalyticsGlobalSettings")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsAnalyticsGlobalSettings), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchDnsAnalyticsGlobalSettings")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsAnalyticsGlobalSettings)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDnsCacheGlobalSettings
//
//
// DNS Cache global settings affecting all caches..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchDnsCacheGlobalSettings(id string, object LtmDnsCacheGlobalSettings) (*LtmDnsCacheGlobalSettings, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/globalSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsCacheGlobalSettings), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchDnsCacheGlobalSettings")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsCacheGlobalSettings), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchDnsCacheGlobalSettings")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsCacheGlobalSettings)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDnsCacheResolver
//
//
// DNS Cache with recursive resolver..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchDnsCacheResolver(id string, object LtmDnsCacheResolver) (*LtmDnsCacheResolver, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/resolver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsCacheResolver), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchDnsCacheResolver")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsCacheResolver), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchDnsCacheResolver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsCacheResolver)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDnsCacheTransparent
//
//
// DNS Cache without a resolver (responses from serverside cached)..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchDnsCacheTransparent(id string, object LtmDnsCacheTransparent) (*LtmDnsCacheTransparent, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/transparent/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsCacheTransparent), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchDnsCacheTransparent")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsCacheTransparent), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchDnsCacheTransparent")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsCacheTransparent)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDnsCacheValidatingResolver
//
//
// DNS Cache with recursive resolver and DNSSEC validation..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchDnsCacheValidatingResolver(id string, object LtmDnsCacheValidatingResolver) (*LtmDnsCacheValidatingResolver, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/validatingResolver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsCacheValidatingResolver), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchDnsCacheValidatingResolver")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsCacheValidatingResolver), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchDnsCacheValidatingResolver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsCacheValidatingResolver)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDnsDnssecKey
//
//
// DNSSEC key configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchDnsDnssecKey(id string, object LtmDnsDnssecKey) (*LtmDnsDnssecKey, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/dnssec/key/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsDnssecKey), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchDnsDnssecKey")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsDnssecKey), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchDnsDnssecKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsDnssecKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDnsDnssecKeyTmGeneration
//
//
// DNSSEC key generation configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchDnsDnssecKeyTmGeneration(id string, object LtmDnsDnssecKeyTmGeneration) (*LtmDnsDnssecKeyTmGeneration, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/dnssec/key/tmGeneration/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsDnssecKeyTmGeneration), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchDnsDnssecKeyTmGeneration")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsDnssecKeyTmGeneration), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchDnsDnssecKeyTmGeneration")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsDnssecKeyTmGeneration)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDnsDnssecZone
//
//
// DNSSEC zone configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchDnsDnssecZone(id string, object LtmDnsDnssecZone) (*LtmDnsDnssecZone, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/dnssec/zone/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsDnssecZone), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchDnsDnssecZone")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsDnssecZone), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchDnsDnssecZone")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsDnssecZone)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDnsNameserver
//
//
// DNS nameserver configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchDnsNameserver(id string, object LtmDnsNameserver) (*LtmDnsNameserver, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/nameserver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsNameserver), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchDnsNameserver")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsNameserver), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchDnsNameserver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsNameserver)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDnsTsigKey
//
//
// TSIG Key configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchDnsTsigKey(id string, object LtmDnsTsigKey) (*LtmDnsTsigKey, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/tsigKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsTsigKey), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchDnsTsigKey")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsTsigKey), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchDnsTsigKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsTsigKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchDnsZone
//
//
// Zone configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchDnsZone(id string, object LtmDnsZone) (*LtmDnsZone, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/zone/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsZone), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchDnsZone")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsZone), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchDnsZone")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsZone)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchEvictionPolicy
//
//
// Defines an eviction policy, used to select which flows to evict when approaching limits..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchEvictionPolicy(id string, object LtmEvictionPolicy) (*LtmEvictionPolicy, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/evictionPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmEvictionPolicy), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchEvictionPolicy")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmEvictionPolicy), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchEvictionPolicy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmEvictionPolicy)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchGlobalSettingsConnection
//
//
// General configuration options for connections.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchGlobalSettingsConnection(id string, object LtmGlobalSettingsConnection) (*LtmGlobalSettingsConnection, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/globalSettings/connection/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmGlobalSettingsConnection), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchGlobalSettingsConnection")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmGlobalSettingsConnection), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchGlobalSettingsConnection")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmGlobalSettingsConnection)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchGlobalSettingsGeneral
//
//
// General configuration options.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchGlobalSettingsGeneral(id string, object LtmGlobalSettingsGeneral) (*LtmGlobalSettingsGeneral, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/globalSettings/general/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmGlobalSettingsGeneral), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchGlobalSettingsGeneral")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmGlobalSettingsGeneral), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchGlobalSettingsGeneral")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmGlobalSettingsGeneral)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchGlobalSettingsTrafficControl
//
//
// General configuration options for traffic.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchGlobalSettingsTrafficControl(id string, object LtmGlobalSettingsTrafficControl) (*LtmGlobalSettingsTrafficControl, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/globalSettings/trafficControl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmGlobalSettingsTrafficControl), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchGlobalSettingsTrafficControl")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmGlobalSettingsTrafficControl), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchGlobalSettingsTrafficControl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmGlobalSettingsTrafficControl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchHtmlRuleCommentRaiseEvent
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchHtmlRuleCommentRaiseEvent(id string, object LtmHtmlRuleCommentRaiseEvent) (*LtmHtmlRuleCommentRaiseEvent, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/commentRaiseEvent/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleCommentRaiseEvent), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchHtmlRuleCommentRaiseEvent")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmHtmlRuleCommentRaiseEvent), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchHtmlRuleCommentRaiseEvent")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmHtmlRuleCommentRaiseEvent)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchHtmlRuleCommentRemove
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchHtmlRuleCommentRemove(id string, object LtmHtmlRuleCommentRemove) (*LtmHtmlRuleCommentRemove, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/commentRemove/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleCommentRemove), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchHtmlRuleCommentRemove")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmHtmlRuleCommentRemove), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchHtmlRuleCommentRemove")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmHtmlRuleCommentRemove)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchHtmlRuleTagAppendHtml
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchHtmlRuleTagAppendHtml(id string, object LtmHtmlRuleTagAppendHtml) (*LtmHtmlRuleTagAppendHtml, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagAppendHtml/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleTagAppendHtml), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchHtmlRuleTagAppendHtml")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmHtmlRuleTagAppendHtml), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchHtmlRuleTagAppendHtml")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmHtmlRuleTagAppendHtml)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchHtmlRuleTagPrependHtml
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchHtmlRuleTagPrependHtml(id string, object LtmHtmlRuleTagPrependHtml) (*LtmHtmlRuleTagPrependHtml, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagPrependHtml/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleTagPrependHtml), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchHtmlRuleTagPrependHtml")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmHtmlRuleTagPrependHtml), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchHtmlRuleTagPrependHtml")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmHtmlRuleTagPrependHtml)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchHtmlRuleTagRaiseEvent
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchHtmlRuleTagRaiseEvent(id string, object LtmHtmlRuleTagRaiseEvent) (*LtmHtmlRuleTagRaiseEvent, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagRaiseEvent/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleTagRaiseEvent), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchHtmlRuleTagRaiseEvent")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmHtmlRuleTagRaiseEvent), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchHtmlRuleTagRaiseEvent")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmHtmlRuleTagRaiseEvent)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchHtmlRuleTagRemove
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchHtmlRuleTagRemove(id string, object LtmHtmlRuleTagRemove) (*LtmHtmlRuleTagRemove, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagRemove/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleTagRemove), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchHtmlRuleTagRemove")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmHtmlRuleTagRemove), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchHtmlRuleTagRemove")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmHtmlRuleTagRemove)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchHtmlRuleTagRemoveAttribute
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchHtmlRuleTagRemoveAttribute(id string, object LtmHtmlRuleTagRemoveAttribute) (*LtmHtmlRuleTagRemoveAttribute, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagRemoveAttribute/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleTagRemoveAttribute), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchHtmlRuleTagRemoveAttribute")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmHtmlRuleTagRemoveAttribute), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchHtmlRuleTagRemoveAttribute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmHtmlRuleTagRemoveAttribute)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchIfile
//
//
// iFile Configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchIfile(id string, object LtmIfile) (*LtmIfile, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/ifile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmIfile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchIfile")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmIfile), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchIfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmIfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchLsnLogProfile
//
//
// Defines the configuration for logging of LSN flows..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchLsnLogProfile(id string, object LtmLsnLogProfile) (*LtmLsnLogProfile, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/lsnLogProfile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmLsnLogProfile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchLsnLogProfile")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmLsnLogProfile), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchLsnLogProfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmLsnLogProfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchLsnPool
//
//
// LSNAT/CGNAT translation address configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchLsnPool(id string, object LtmLsnPool) (*LtmLsnPool, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/lsnPool/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmLsnPool), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchLsnPool")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmLsnPool), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchLsnPool")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmLsnPool)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMessageRoutingDiameterPeer
//
//
// Peed for routing generic message protocol messages..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMessageRoutingDiameterPeer(id string, object LtmMessageRoutingDiameterPeer) (*LtmMessageRoutingDiameterPeer, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/peer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterPeer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMessageRoutingDiameterPeer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingDiameterPeer), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMessageRoutingDiameterPeer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingDiameterPeer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMessageRoutingDiameterProfileRouter
//
//
// Configures a Diameter Router profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMessageRoutingDiameterProfileRouter(id string, object LtmMessageRoutingDiameterProfileRouter) (*LtmMessageRoutingDiameterProfileRouter, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/profile/router/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterProfileRouter), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMessageRoutingDiameterProfileRouter")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingDiameterProfileRouter), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMessageRoutingDiameterProfileRouter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingDiameterProfileRouter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMessageRoutingDiameterProfileSession
//
//
// Configures a Diameter Session profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMessageRoutingDiameterProfileSession(id string, object LtmMessageRoutingDiameterProfileSession) (*LtmMessageRoutingDiameterProfileSession, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/profile/session/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterProfileSession), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMessageRoutingDiameterProfileSession")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingDiameterProfileSession), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMessageRoutingDiameterProfileSession")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingDiameterProfileSession)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMessageRoutingDiameterRoute
//
//
// Configures a static route for use in Diameter message routing..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMessageRoutingDiameterRoute(id string, object LtmMessageRoutingDiameterRoute) (*LtmMessageRoutingDiameterRoute, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/route/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterRoute), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMessageRoutingDiameterRoute")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingDiameterRoute), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMessageRoutingDiameterRoute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingDiameterRoute)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMessageRoutingDiameterTransportConfig
//
//
// Defines the configuration for an outgoing connection..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMessageRoutingDiameterTransportConfig(id string, object LtmMessageRoutingDiameterTransportConfig) (*LtmMessageRoutingDiameterTransportConfig, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/transportConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterTransportConfig), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMessageRoutingDiameterTransportConfig")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingDiameterTransportConfig), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMessageRoutingDiameterTransportConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingDiameterTransportConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMessageRoutingDiameterTransportConfigProfiles
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMessageRoutingDiameterTransportConfigProfiles(id string, object LtmMessageRoutingDiameterTransportConfigProfiles) (*LtmMessageRoutingDiameterTransportConfigProfiles, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/transportConfig/profiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterTransportConfigProfiles), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMessageRoutingDiameterTransportConfigProfiles")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingDiameterTransportConfigProfiles), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMessageRoutingDiameterTransportConfigProfiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingDiameterTransportConfigProfiles)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMessageRoutingGenericPeer
//
//
// Peed for routing generic message protocol messages..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMessageRoutingGenericPeer(id string, object LtmMessageRoutingGenericPeer) (*LtmMessageRoutingGenericPeer, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/peer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericPeer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMessageRoutingGenericPeer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingGenericPeer), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMessageRoutingGenericPeer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingGenericPeer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMessageRoutingGenericProtocol
//
//
// Generic message parser for use with the message routing framework..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMessageRoutingGenericProtocol(id string, object LtmMessageRoutingGenericProtocol) (*LtmMessageRoutingGenericProtocol, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/protocol/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericProtocol), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMessageRoutingGenericProtocol")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingGenericProtocol), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMessageRoutingGenericProtocol")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingGenericProtocol)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMessageRoutingGenericRoute
//
//
// Static route for routing generic message protocol messages..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMessageRoutingGenericRoute(id string, object LtmMessageRoutingGenericRoute) (*LtmMessageRoutingGenericRoute, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/route/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericRoute), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMessageRoutingGenericRoute")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingGenericRoute), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMessageRoutingGenericRoute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingGenericRoute)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMessageRoutingGenericRouter
//
//
// Message routing instance for generic message protocol..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMessageRoutingGenericRouter(id string, object LtmMessageRoutingGenericRouter) (*LtmMessageRoutingGenericRouter, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/router/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericRouter), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMessageRoutingGenericRouter")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingGenericRouter), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMessageRoutingGenericRouter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingGenericRouter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMessageRoutingGenericTransportConfig
//
//
// Defines the configuration for an outgoing connection..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMessageRoutingGenericTransportConfig(id string, object LtmMessageRoutingGenericTransportConfig) (*LtmMessageRoutingGenericTransportConfig, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/transportConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericTransportConfig), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMessageRoutingGenericTransportConfig")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingGenericTransportConfig), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMessageRoutingGenericTransportConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingGenericTransportConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMessageRoutingGenericTransportConfigProfiles
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMessageRoutingGenericTransportConfigProfiles(id string, object LtmMessageRoutingGenericTransportConfigProfiles) (*LtmMessageRoutingGenericTransportConfigProfiles, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/transportConfig/profiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericTransportConfigProfiles), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMessageRoutingGenericTransportConfigProfiles")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingGenericTransportConfigProfiles), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMessageRoutingGenericTransportConfigProfiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingGenericTransportConfigProfiles)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMessageRoutingSipPeer
//
//
// Peed for routing generic message protocol messages..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMessageRoutingSipPeer(id string, object LtmMessageRoutingSipPeer) (*LtmMessageRoutingSipPeer, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/peer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipPeer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMessageRoutingSipPeer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingSipPeer), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMessageRoutingSipPeer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingSipPeer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMessageRoutingSipProfileRouter
//
//
// Configures a Session Initiation Protocol (SIP) Router profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMessageRoutingSipProfileRouter(id string, object LtmMessageRoutingSipProfileRouter) (*LtmMessageRoutingSipProfileRouter, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/profile/router/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipProfileRouter), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMessageRoutingSipProfileRouter")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingSipProfileRouter), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMessageRoutingSipProfileRouter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingSipProfileRouter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMessageRoutingSipProfileSession
//
//
// Configures a Session Initiation Protocol (SIP) Session profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMessageRoutingSipProfileSession(id string, object LtmMessageRoutingSipProfileSession) (*LtmMessageRoutingSipProfileSession, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/profile/session/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipProfileSession), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMessageRoutingSipProfileSession")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingSipProfileSession), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMessageRoutingSipProfileSession")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingSipProfileSession)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMessageRoutingSipRoute
//
//
// Configures a static route for use in Session Initiation Protocol (SIP) message routing..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMessageRoutingSipRoute(id string, object LtmMessageRoutingSipRoute) (*LtmMessageRoutingSipRoute, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/route/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipRoute), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMessageRoutingSipRoute")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingSipRoute), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMessageRoutingSipRoute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingSipRoute)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMessageRoutingSipTransportConfig
//
//
// Defines the configuration for an outgoing connection..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMessageRoutingSipTransportConfig(id string, object LtmMessageRoutingSipTransportConfig) (*LtmMessageRoutingSipTransportConfig, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/transportConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipTransportConfig), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMessageRoutingSipTransportConfig")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingSipTransportConfig), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMessageRoutingSipTransportConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingSipTransportConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMessageRoutingSipTransportConfigProfiles
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMessageRoutingSipTransportConfigProfiles(id string, object LtmMessageRoutingSipTransportConfigProfiles) (*LtmMessageRoutingSipTransportConfigProfiles, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/transportConfig/profiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipTransportConfigProfiles), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMessageRoutingSipTransportConfigProfiles")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingSipTransportConfigProfiles), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMessageRoutingSipTransportConfigProfiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingSipTransportConfigProfiles)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorDiameter
//
//
// Diameter monitor configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorDiameter(id string, object LtmMonitorDiameter) (*LtmMonitorDiameter, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/diameter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorDiameter), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorDiameter")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorDiameter), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorDiameter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorDiameter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorDns
//
//
// DNS monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorDns(id string, object LtmMonitorDns) (*LtmMonitorDns, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/dns/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorDns), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorDns")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorDns), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorDns")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorDns)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorExternal
//
//
// External monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorExternal(id string, object LtmMonitorExternal) (*LtmMonitorExternal, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/external/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorExternal), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorExternal")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorExternal), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorExternal")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorExternal)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorFirepass
//
//
// Firepass monitor configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorFirepass(id string, object LtmMonitorFirepass) (*LtmMonitorFirepass, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/firepass/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorFirepass), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorFirepass")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorFirepass), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorFirepass")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorFirepass)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorFtp
//
//
// FTP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorFtp(id string, object LtmMonitorFtp) (*LtmMonitorFtp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/ftp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorFtp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorFtp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorFtp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorFtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorFtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorGatewayIcmp
//
//
// Gateway ICMP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorGatewayIcmp(id string, object LtmMonitorGatewayIcmp) (*LtmMonitorGatewayIcmp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/gatewayIcmp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorGatewayIcmp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorGatewayIcmp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorGatewayIcmp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorGatewayIcmp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorGatewayIcmp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorHttp
//
//
// HTTP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorHttp(id string, object LtmMonitorHttp) (*LtmMonitorHttp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/http/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorHttp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorHttp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorHttp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorHttp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorHttp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorHttps
//
//
// HTTPS monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorHttps(id string, object LtmMonitorHttps) (*LtmMonitorHttps, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/https/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorHttps), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorHttps")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorHttps), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorHttps")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorHttps)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorIcmp
//
//
// ICMP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorIcmp(id string, object LtmMonitorIcmp) (*LtmMonitorIcmp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/icmp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorIcmp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorIcmp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorIcmp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorIcmp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorIcmp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorImap
//
//
// IMAP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorImap(id string, object LtmMonitorImap) (*LtmMonitorImap, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/imap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorImap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorImap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorImap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorImap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorImap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorInband
//
//
// Inband monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorInband(id string, object LtmMonitorInband) (*LtmMonitorInband, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/inband/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorInband), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorInband")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorInband), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorInband")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorInband)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorLdap
//
//
// LDAP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorLdap(id string, object LtmMonitorLdap) (*LtmMonitorLdap, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/ldap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorLdap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorLdap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorLdap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorLdap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorModuleScore
//
//
// Module score monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorModuleScore(id string, object LtmMonitorModuleScore) (*LtmMonitorModuleScore, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/moduleScore/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorModuleScore), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorModuleScore")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorModuleScore), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorModuleScore")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorModuleScore)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorMssql
//
//
// MSSQL monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorMssql(id string, object LtmMonitorMssql) (*LtmMonitorMssql, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/mssql/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorMssql), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorMssql")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorMssql), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorMssql")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorMssql)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorMysql
//
//
// MySQL monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorMysql(id string, object LtmMonitorMysql) (*LtmMonitorMysql, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/mysql/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorMysql), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorMysql")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorMysql), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorMysql")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorMysql)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorNntp
//
//
// NNTP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorNntp(id string, object LtmMonitorNntp) (*LtmMonitorNntp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/nntp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorNntp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorNntp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorNntp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorNntp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorNntp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorNone
//
//
// The NULL monitor..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorNone(id string, object LtmMonitorNone) (*LtmMonitorNone, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/none/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorNone), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorNone")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorNone), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorNone")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorNone)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorOracle
//
//
// Oracle monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorOracle(id string, object LtmMonitorOracle) (*LtmMonitorOracle, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/oracle/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorOracle), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorOracle")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorOracle), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorOracle")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorOracle)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorPop3
//
//
// POP3 monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorPop3(id string, object LtmMonitorPop3) (*LtmMonitorPop3, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/pop3/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorPop3), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorPop3")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorPop3), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorPop3")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorPop3)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorPostgresql
//
//
// Postgresql monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorPostgresql(id string, object LtmMonitorPostgresql) (*LtmMonitorPostgresql, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/postgresql/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorPostgresql), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorPostgresql")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorPostgresql), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorPostgresql")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorPostgresql)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorRadius
//
//
// Radius monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorRadius(id string, object LtmMonitorRadius) (*LtmMonitorRadius, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/radius/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorRadius), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorRadius")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorRadius), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorRadius")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorRadius)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorRadiusAccounting
//
//
// Radius accounting monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorRadiusAccounting(id string, object LtmMonitorRadiusAccounting) (*LtmMonitorRadiusAccounting, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/radiusAccounting/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorRadiusAccounting), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorRadiusAccounting")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorRadiusAccounting), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorRadiusAccounting")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorRadiusAccounting)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorRealServer
//
//
// Real Server monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorRealServer(id string, object LtmMonitorRealServer) (*LtmMonitorRealServer, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/realServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorRealServer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorRealServer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorRealServer), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorRealServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorRealServer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorRpc
//
//
// RPC monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorRpc(id string, object LtmMonitorRpc) (*LtmMonitorRpc, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/rpc/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorRpc), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorRpc")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorRpc), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorRpc")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorRpc)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorSasp
//
//
// SASP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorSasp(id string, object LtmMonitorSasp) (*LtmMonitorSasp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/sasp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSasp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorSasp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorSasp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorSasp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorSasp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorScripted
//
//
// Scripted monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorScripted(id string, object LtmMonitorScripted) (*LtmMonitorScripted, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/scripted/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorScripted), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorScripted")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorScripted), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorScripted")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorScripted)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorSip
//
//
// SIP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorSip(id string, object LtmMonitorSip) (*LtmMonitorSip, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/sip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSip), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorSip")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorSip), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorSip")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorSip)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorSmb
//
//
// SMB monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorSmb(id string, object LtmMonitorSmb) (*LtmMonitorSmb, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/smb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSmb), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorSmb")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorSmb), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorSmb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorSmb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorSmtp
//
//
// SMTP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorSmtp(id string, object LtmMonitorSmtp) (*LtmMonitorSmtp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/smtp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSmtp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorSmtp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorSmtp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorSmtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorSmtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorSnmpDca
//
//
// SNMP DCA monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorSnmpDca(id string, object LtmMonitorSnmpDca) (*LtmMonitorSnmpDca, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/snmpDca/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSnmpDca), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorSnmpDca")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorSnmpDca), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorSnmpDca")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorSnmpDca)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorSnmpDcaBase
//
//
// SNMP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorSnmpDcaBase(id string, object LtmMonitorSnmpDcaBase) (*LtmMonitorSnmpDcaBase, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/snmpDcaBase/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSnmpDcaBase), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorSnmpDcaBase")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorSnmpDcaBase), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorSnmpDcaBase")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorSnmpDcaBase)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorSoap
//
//
// SOAP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorSoap(id string, object LtmMonitorSoap) (*LtmMonitorSoap, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/soap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSoap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorSoap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorSoap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorSoap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorSoap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorTcp
//
//
// TCP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorTcp(id string, object LtmMonitorTcp) (*LtmMonitorTcp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/tcp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorTcp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorTcp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorTcp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorTcp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorTcp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorTcpEcho
//
//
// TCP Echo monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorTcpEcho(id string, object LtmMonitorTcpEcho) (*LtmMonitorTcpEcho, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/tcpEcho/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorTcpEcho), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorTcpEcho")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorTcpEcho), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorTcpEcho")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorTcpEcho)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorTcpHalfOpen
//
//
// TCP Half Open monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorTcpHalfOpen(id string, object LtmMonitorTcpHalfOpen) (*LtmMonitorTcpHalfOpen, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/tcpHalfOpen/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorTcpHalfOpen), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorTcpHalfOpen")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorTcpHalfOpen), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorTcpHalfOpen")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorTcpHalfOpen)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorUdp
//
//
// UDP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorUdp(id string, object LtmMonitorUdp) (*LtmMonitorUdp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/udp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorUdp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorUdp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorUdp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorUdp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorUdp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorVirtualLocation
//
//
// Virtual Location monitor configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorVirtualLocation(id string, object LtmMonitorVirtualLocation) (*LtmMonitorVirtualLocation, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/virtualLocation/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorVirtualLocation), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorVirtualLocation")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorVirtualLocation), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorVirtualLocation")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorVirtualLocation)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorWap
//
//
// WAP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorWap(id string, object LtmMonitorWap) (*LtmMonitorWap, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/wap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorWap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorWap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorWap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorWap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorWap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchMonitorWmi
//
//
// WMI monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchMonitorWmi(id string, object LtmMonitorWmi) (*LtmMonitorWmi, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/wmi/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorWmi), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchMonitorWmi")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorWmi), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchMonitorWmi")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorWmi)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchNat
//
//
// Network address translation configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchNat(id string, object LtmNat) (*LtmNat, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/nat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmNat), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchNat")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmNat), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchNat")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmNat)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchNode
//
//
// Node specific pool member configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchNode(id string, object LtmNode) (*LtmNode, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/node/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmNode), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchNode")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmNode), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchNode")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmNode)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchPersistenceCookie
//
//
// Virtual server Cookie persistence profile.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchPersistenceCookie(id string, object LtmPersistenceCookie) (*LtmPersistenceCookie, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/cookie/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceCookie), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchPersistenceCookie")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceCookie), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchPersistenceCookie")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceCookie)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchPersistenceDestAddr
//
//
// Virtual server Destination Address Affinity persistence profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchPersistenceDestAddr(id string, object LtmPersistenceDestAddr) (*LtmPersistenceDestAddr, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/destAddr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceDestAddr), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchPersistenceDestAddr")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceDestAddr), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchPersistenceDestAddr")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceDestAddr)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchPersistenceGlobalSettings
//
//
// Global settings for persistence.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchPersistenceGlobalSettings(id string, object LtmPersistenceGlobalSettings) (*LtmPersistenceGlobalSettings, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/globalSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceGlobalSettings), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchPersistenceGlobalSettings")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceGlobalSettings), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchPersistenceGlobalSettings")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceGlobalSettings)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchPersistenceHash
//
//
// Virtual server Hash persistence profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchPersistenceHash(id string, object LtmPersistenceHash) (*LtmPersistenceHash, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/hash/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceHash), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchPersistenceHash")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceHash), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchPersistenceHash")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceHash)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchPersistenceMsrdp
//
//
// Virtual server Microsoft Remote Desktop (MSRDP) persistence profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchPersistenceMsrdp(id string, object LtmPersistenceMsrdp) (*LtmPersistenceMsrdp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/msrdp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceMsrdp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchPersistenceMsrdp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceMsrdp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchPersistenceMsrdp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceMsrdp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchPersistenceSip
//
//
// Virtual server SIP persistence profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchPersistenceSip(id string, object LtmPersistenceSip) (*LtmPersistenceSip, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/sip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceSip), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchPersistenceSip")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceSip), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchPersistenceSip")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceSip)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchPersistenceSourceAddr
//
//
// Virtual server Source Address persistence profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchPersistenceSourceAddr(id string, object LtmPersistenceSourceAddr) (*LtmPersistenceSourceAddr, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/sourceAddr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceSourceAddr), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchPersistenceSourceAddr")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceSourceAddr), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchPersistenceSourceAddr")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceSourceAddr)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchPersistenceSsl
//
//
// Virtual server SSL persistence profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchPersistenceSsl(id string, object LtmPersistenceSsl) (*LtmPersistenceSsl, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/ssl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceSsl), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchPersistenceSsl")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceSsl), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchPersistenceSsl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceSsl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchPersistenceUniversal
//
//
// Virtual server Universal persistence profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchPersistenceUniversal(id string, object LtmPersistenceUniversal) (*LtmPersistenceUniversal, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/universal/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceUniversal), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchPersistenceUniversal")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceUniversal), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchPersistenceUniversal")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceUniversal)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchPolicy
//
//
// Centralized Policy Matching configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchPolicy(id string, object LtmPolicy) (*LtmPolicy, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicy), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchPolicy")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPolicy), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchPolicy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPolicy)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchPolicyRules
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchPolicyRules(id string, object LtmPolicyRules) (*LtmPolicyRules, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/rules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicyRules), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchPolicyRules")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPolicyRules), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchPolicyRules")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPolicyRules)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchPolicyRulesActions
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchPolicyRulesActions(id string, object LtmPolicyRulesActions) (*LtmPolicyRulesActions, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/rules/actions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicyRulesActions), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchPolicyRulesActions")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPolicyRulesActions), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchPolicyRulesActions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPolicyRulesActions)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchPolicyRulesConditions
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchPolicyRulesConditions(id string, object LtmPolicyRulesConditions) (*LtmPolicyRulesConditions, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/rules/conditions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicyRulesConditions), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchPolicyRulesConditions")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPolicyRulesConditions), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchPolicyRulesConditions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPolicyRulesConditions)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchPolicyStrategy
//
//
// Centralized Policy Matching rule selection strategy.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchPolicyStrategy(id string, object LtmPolicyStrategy) (*LtmPolicyStrategy, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policyStrategy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicyStrategy), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchPolicyStrategy")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPolicyStrategy), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchPolicyStrategy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPolicyStrategy)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchPolicyStrategyOperands
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchPolicyStrategyOperands(id string, object LtmPolicyStrategyOperands) (*LtmPolicyStrategyOperands, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policyStrategy/operands/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicyStrategyOperands), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchPolicyStrategyOperands")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPolicyStrategyOperands), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchPolicyStrategyOperands")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPolicyStrategyOperands)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchPool
//
//
// Load balancing pool configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchPool(id string, object LtmPool) (*LtmPool, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/pool/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPool), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchPool")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPool), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchPool")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPool)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchPoolMembers
//
//
// Manage the set of pool members that are associated with a load balancing pool.
//
// pid is for ID of the parent resource
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchPoolMembers(pid string, id string, object LtmPoolMembers) (*LtmPoolMembers, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/pool/{pid}/members/{id}"
	path = strings.Replace(path, "{"+"pid"+"}", fmt.Sprintf("%v", pid), -1)
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'pid' is set
	if &pid == nil {
		return new(LtmPoolMembers), nil, errors.New("Missing required parameter 'pid' when calling LtmApi->PatchPoolMembers")
	}
	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPoolMembers), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchPoolMembers")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPoolMembers), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchPoolMembers")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPoolMembers)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileAnalytics
//
//
// Virtual server analytics profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileAnalytics(id string, object LtmProfileAnalytics) (*LtmProfileAnalytics, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/analytics/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileAnalytics), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileAnalytics")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileAnalytics), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileAnalytics")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileAnalytics)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileAnalyticsAlerts
//
//
// Manage the set of analytics alerts that are associated with an analytics profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileAnalyticsAlerts(id string, object LtmProfileAnalyticsAlerts) (*LtmProfileAnalyticsAlerts, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/analytics/alerts/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileAnalyticsAlerts), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileAnalyticsAlerts")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileAnalyticsAlerts), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileAnalyticsAlerts")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileAnalyticsAlerts)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileAnalyticsTrafficCapture
//
//
// Manage the set of analytics alerts that are associated with an analytics profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileAnalyticsTrafficCapture(id string, object LtmProfileAnalyticsTrafficCapture) (*LtmProfileAnalyticsTrafficCapture, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/analytics/trafficCapture/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileAnalyticsTrafficCapture), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileAnalyticsTrafficCapture")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileAnalyticsTrafficCapture), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileAnalyticsTrafficCapture")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileAnalyticsTrafficCapture)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileCertificateAuthority
//
//
// Virtual server Certificate Authority profile configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileCertificateAuthority(id string, object LtmProfileCertificateAuthority) (*LtmProfileCertificateAuthority, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/certificateAuthority/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileCertificateAuthority), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileCertificateAuthority")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileCertificateAuthority), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileCertificateAuthority")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileCertificateAuthority)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileClassification
//
//
// Virtual server classification profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileClassification(id string, object LtmProfileClassification) (*LtmProfileClassification, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/classification/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileClassification), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileClassification")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileClassification), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileClassification")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileClassification)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileClientLdap
//
//
// Virtual server Client LDAP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileClientLdap(id string, object LtmProfileClientLdap) (*LtmProfileClientLdap, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/clientLdap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileClientLdap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileClientLdap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileClientLdap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileClientLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileClientLdap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileClientSsl
//
//
// Virtual server client-side proxy SSL profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileClientSsl(id string, object LtmProfileClientSsl) (*LtmProfileClientSsl, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/clientSsl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileClientSsl), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileClientSsl")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileClientSsl), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileClientSsl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileClientSsl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileDhcpv4
//
//
// Dynamic Host Configuration Protocol, DHCPv4, profile to manage DHCPv4 network traffic..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileDhcpv4(id string, object LtmProfileDhcpv4) (*LtmProfileDhcpv4, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dhcpv4/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileDhcpv4), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileDhcpv4")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileDhcpv4), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileDhcpv4")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileDhcpv4)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileDhcpv6
//
//
// Dynamic Host Configuration Protocol, DHCPv6, profile to manage DHCPv6 network traffic..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileDhcpv6(id string, object LtmProfileDhcpv6) (*LtmProfileDhcpv6, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dhcpv6/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileDhcpv6), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileDhcpv6")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileDhcpv6), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileDhcpv6")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileDhcpv6)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileDiameter
//
//
// Virtual server Diameter traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileDiameter(id string, object LtmProfileDiameter) (*LtmProfileDiameter, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/diameter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileDiameter), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileDiameter")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileDiameter), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileDiameter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileDiameter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileDns
//
//
// Virtual server DNS traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileDns(id string, object LtmProfileDns) (*LtmProfileDns, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dns/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileDns), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileDns")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileDns), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileDns")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileDns)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileDnsLogging
//
//
// High-speed logging settings for the DNS profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileDnsLogging(id string, object LtmProfileDnsLogging) (*LtmProfileDnsLogging, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dnsLogging/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileDnsLogging), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileDnsLogging")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileDnsLogging), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileDnsLogging")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileDnsLogging)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileFasthttp
//
//
// Virtual server Fast HTTP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileFasthttp(id string, object LtmProfileFasthttp) (*LtmProfileFasthttp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/fasthttp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileFasthttp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileFasthttp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileFasthttp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileFasthttp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileFasthttp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileFastl4
//
//
// Virtual server FastL4 traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileFastl4(id string, object LtmProfileFastl4) (*LtmProfileFastl4, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/fastl4/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileFastl4), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileFastl4")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileFastl4), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileFastl4")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileFastl4)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileFix
//
//
// Virtual server Financial Information eXchange(FIX) profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileFix(id string, object LtmProfileFix) (*LtmProfileFix, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/fix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileFix), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileFix")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileFix), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileFix")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileFix)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileFtp
//
//
// Virtual server FTP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileFtp(id string, object LtmProfileFtp) (*LtmProfileFtp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ftp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileFtp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileFtp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileFtp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileFtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileFtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileGtp
//
//
// Virtual server GTP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileGtp(id string, object LtmProfileGtp) (*LtmProfileGtp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/gtp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileGtp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileGtp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileGtp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileGtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileGtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileHtml
//
//
// Virtual server HTML profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileHtml(id string, object LtmProfileHtml) (*LtmProfileHtml, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/html/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileHtml), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileHtml")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileHtml), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileHtml")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileHtml)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileHttp
//
//
// Virtual server HTTP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileHttp(id string, object LtmProfileHttp) (*LtmProfileHttp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/http/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileHttp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileHttp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileHttp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileHttp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileHttp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileHttp2
//
//
// Virtual server HTTP/2 traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileHttp2(id string, object LtmProfileHttp2) (*LtmProfileHttp2, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/http2/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileHttp2), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileHttp2")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileHttp2), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileHttp2")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileHttp2)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileHttpCompression
//
//
// Virtual server HTTP compression profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileHttpCompression(id string, object LtmProfileHttpCompression) (*LtmProfileHttpCompression, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/httpCompression/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileHttpCompression), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileHttpCompression")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileHttpCompression), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileHttpCompression")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileHttpCompression)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileIcap
//
//
// Virtual server Internet Content Adaptation Protocol (ICAP) profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileIcap(id string, object LtmProfileIcap) (*LtmProfileIcap, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/icap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileIcap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileIcap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileIcap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileIcap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileIcap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileIiop
//
//
// Virtual server IIOP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileIiop(id string, object LtmProfileIiop) (*LtmProfileIiop, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/iiop/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileIiop), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileIiop")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileIiop), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileIiop")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileIiop)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileIpother
//
//
// Virtual server IPOTHER for non-TCP and non-UDP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileIpother(id string, object LtmProfileIpother) (*LtmProfileIpother, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ipother/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileIpother), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileIpother")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileIpother), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileIpother")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileIpother)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileMblb
//
//
// MBLB profile configuration (experimental).
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileMblb(id string, object LtmProfileMblb) (*LtmProfileMblb, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/mblb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileMblb), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileMblb")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileMblb), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileMblb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileMblb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileMssql
//
//
// Virtual server MSSQL profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileMssql(id string, object LtmProfileMssql) (*LtmProfileMssql, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/mssql/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileMssql), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileMssql")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileMssql), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileMssql")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileMssql)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileNtlm
//
//
// Virtual server NT Lan Manager profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileNtlm(id string, object LtmProfileNtlm) (*LtmProfileNtlm, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ntlm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileNtlm), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileNtlm")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileNtlm), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileNtlm")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileNtlm)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileOcspStaplingParams
//
//
// OCSP Stapling Parameters for clientssl profiles. This object should be associated with a cert-key-chain object in a clientssl profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileOcspStaplingParams(id string, object LtmProfileOcspStaplingParams) (*LtmProfileOcspStaplingParams, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ocspStaplingParams/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileOcspStaplingParams), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileOcspStaplingParams")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileOcspStaplingParams), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileOcspStaplingParams")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileOcspStaplingParams)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileOneConnect
//
//
// Virtual server OneConnect profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileOneConnect(id string, object LtmProfileOneConnect) (*LtmProfileOneConnect, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/oneConnect/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileOneConnect), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileOneConnect")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileOneConnect), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileOneConnect")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileOneConnect)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfilePcp
//
//
// LSN Pool PCP configuration profile.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfilePcp(id string, object LtmProfilePcp) (*LtmProfilePcp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/pcp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfilePcp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfilePcp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfilePcp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfilePcp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfilePcp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfilePptp
//
//
// Virtual server Point to Point Tunneling Protocol (PPTP) profile configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfilePptp(id string, object LtmProfilePptp) (*LtmProfilePptp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/pptp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfilePptp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfilePptp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfilePptp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfilePptp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfilePptp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileQoe
//
//
// Virtual server Quality of Experience profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileQoe(id string, object LtmProfileQoe) (*LtmProfileQoe, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/qoe/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileQoe), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileQoe")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileQoe), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileQoe")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileQoe)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileRadius
//
//
// Virtual server Radius traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileRadius(id string, object LtmProfileRadius) (*LtmProfileRadius, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/radius/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRadius), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileRadius")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileRadius), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileRadius")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileRadius)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileRequestAdapt
//
//
// Virtual server HTTP request adaptation profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileRequestAdapt(id string, object LtmProfileRequestAdapt) (*LtmProfileRequestAdapt, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/requestAdapt/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRequestAdapt), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileRequestAdapt")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileRequestAdapt), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileRequestAdapt")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileRequestAdapt)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileRequestLog
//
//
// Virtual server request logging profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileRequestLog(id string, object LtmProfileRequestLog) (*LtmProfileRequestLog, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/requestLog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRequestLog), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileRequestLog")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileRequestLog), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileRequestLog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileRequestLog)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileResponseAdapt
//
//
// Virtual server HTTP response adaptation profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileResponseAdapt(id string, object LtmProfileResponseAdapt) (*LtmProfileResponseAdapt, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/responseAdapt/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileResponseAdapt), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileResponseAdapt")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileResponseAdapt), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileResponseAdapt")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileResponseAdapt)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileRewrite
//
//
// Virtual server Rewrite profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileRewrite(id string, object LtmProfileRewrite) (*LtmProfileRewrite, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/rewrite/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRewrite), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileRewrite")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileRewrite), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileRewrite")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileRewrite)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileRewriteUriRules
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileRewriteUriRules(id string, object LtmProfileRewriteUriRules) (*LtmProfileRewriteUriRules, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/rewrite/uriRules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRewriteUriRules), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileRewriteUriRules")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileRewriteUriRules), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileRewriteUriRules")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileRewriteUriRules)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileRtsp
//
//
// Virtual server RTSP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileRtsp(id string, object LtmProfileRtsp) (*LtmProfileRtsp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/rtsp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRtsp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileRtsp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileRtsp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileRtsp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileRtsp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileSctp
//
//
// Virtual server SCTP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileSctp(id string, object LtmProfileSctp) (*LtmProfileSctp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/sctp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSctp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileSctp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileSctp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileSctp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileSctp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileServerLdap
//
//
// Virtual server Server LDAP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileServerLdap(id string, object LtmProfileServerLdap) (*LtmProfileServerLdap, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/serverLdap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileServerLdap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileServerLdap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileServerLdap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileServerLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileServerLdap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileServerSsl
//
//
// Virtual server server-side proxy SSL profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileServerSsl(id string, object LtmProfileServerSsl) (*LtmProfileServerSsl, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/serverSsl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileServerSsl), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileServerSsl")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileServerSsl), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileServerSsl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileServerSsl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileSip
//
//
// Virtual server SIP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileSip(id string, object LtmProfileSip) (*LtmProfileSip, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/sip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSip), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileSip")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileSip), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileSip")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileSip)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileSmtp
//
//
// Virtual server SMTP profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileSmtp(id string, object LtmProfileSmtp) (*LtmProfileSmtp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/smtp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSmtp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileSmtp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileSmtp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileSmtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileSmtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileSmtps
//
//
// Virtual server SMTPs traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileSmtps(id string, object LtmProfileSmtps) (*LtmProfileSmtps, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/smtps/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSmtps), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileSmtps")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileSmtps), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileSmtps")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileSmtps)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileSocks
//
//
// Virtual server SOCKS traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileSocks(id string, object LtmProfileSocks) (*LtmProfileSocks, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/socks/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSocks), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileSocks")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileSocks), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileSocks")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileSocks)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileSpdy
//
//
// Virtual server SPDY traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileSpdy(id string, object LtmProfileSpdy) (*LtmProfileSpdy, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/spdy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSpdy), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileSpdy")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileSpdy), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileSpdy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileSpdy)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileStatistics
//
//
// Virtual server custom statistics configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileStatistics(id string, object LtmProfileStatistics) (*LtmProfileStatistics, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/statistics/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileStatistics), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileStatistics")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileStatistics), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileStatistics")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileStatistics)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileStream
//
//
// Virtual server Stream traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileStream(id string, object LtmProfileStream) (*LtmProfileStream, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/stream/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileStream), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileStream")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileStream), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileStream")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileStream)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileTcp
//
//
// Virtual server TCP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileTcp(id string, object LtmProfileTcp) (*LtmProfileTcp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/tcp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileTcp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileTcp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileTcp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileTcp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileTcp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileTftp
//
//
// Virtual server TFTP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileTftp(id string, object LtmProfileTftp) (*LtmProfileTftp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/tftp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileTftp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileTftp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileTftp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileTftp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileTftp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileUdp
//
//
// Virtual server UDP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileUdp(id string, object LtmProfileUdp) (*LtmProfileUdp, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/udp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileUdp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileUdp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileUdp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileUdp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileUdp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileWebAcceleration
//
//
// Virtual server Web Acceleration profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileWebAcceleration(id string, object LtmProfileWebAcceleration) (*LtmProfileWebAcceleration, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/webAcceleration/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileWebAcceleration), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileWebAcceleration")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileWebAcceleration), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileWebAcceleration")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileWebAcceleration)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchProfileXml
//
//
// Virtual server XML configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchProfileXml(id string, object LtmProfileXml) (*LtmProfileXml, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/xml/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileXml), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchProfileXml")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileXml), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchProfileXml")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileXml)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchRule
//
//
// iRules configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchRule(id string, object LtmRule) (*LtmRule, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/rule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmRule), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchRule")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmRule), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchRule")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmRule)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchSnat
//
//
// Secure network address translation (SNAT) configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchSnat(id string, object LtmSnat) (*LtmSnat, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/snat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmSnat), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchSnat")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmSnat), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchSnat")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmSnat)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchSnatTranslation
//
//
// SNAT translation address configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchSnatTranslation(id string, object LtmSnatTranslation) (*LtmSnatTranslation, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/snatTranslation/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmSnatTranslation), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchSnatTranslation")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmSnatTranslation), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchSnatTranslation")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmSnatTranslation)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchSnatpool
//
//
// Collections of SNAT translation addresses.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchSnatpool(id string, object LtmSnatpool) (*LtmSnatpool, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/snatpool/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmSnatpool), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchSnatpool")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmSnatpool), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchSnatpool")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmSnatpool)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchTacdbCustomdb
//
//
// Custom tacdb for detection of device type and OS..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchTacdbCustomdb(id string, object LtmTacdbCustomdb) (*LtmTacdbCustomdb, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/tacdb/customdb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmTacdbCustomdb), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchTacdbCustomdb")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmTacdbCustomdb), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchTacdbCustomdb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmTacdbCustomdb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchTacdbCustomdbFile
//
//
// File object for custom tacdb. User should NOT use it. Daemon use it internally..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchTacdbCustomdbFile(id string, object LtmTacdbCustomdbFile) (*LtmTacdbCustomdbFile, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/tacdb/customdbFile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmTacdbCustomdbFile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchTacdbCustomdbFile")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmTacdbCustomdbFile), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchTacdbCustomdbFile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmTacdbCustomdbFile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchTrafficClass
//
//
// Traffic Class Configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchTrafficClass(id string, object LtmTrafficClass) (*LtmTrafficClass, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/trafficClass/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmTrafficClass), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchTrafficClass")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmTrafficClass), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchTrafficClass")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmTrafficClass)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchVirtual
//
//
// Virtual server configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchVirtual(id string, object LtmVirtual) (*LtmVirtual, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmVirtual), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchVirtual")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmVirtual), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchVirtual")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmVirtual)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchVirtualAddress
//
//
// Virtual server IP address configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchVirtualAddress(id string, object LtmVirtualAddress) (*LtmVirtualAddress, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtualAddress/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmVirtualAddress), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchVirtualAddress")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmVirtualAddress), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchVirtualAddress")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmVirtualAddress)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchVirtualPolicies
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchVirtualPolicies(id string, object LtmVirtualPolicies) (*LtmVirtualPolicies, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/policies/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmVirtualPolicies), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchVirtualPolicies")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmVirtualPolicies), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchVirtualPolicies")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmVirtualPolicies)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PatchVirtualProfiles
//
//
// Manage the set of profiles that are associated with virtual servers.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PatchVirtualProfiles(id string, object LtmVirtualProfiles) (*LtmVirtualProfiles, *APIResponse, error) {

	var httpMethod = "Patch"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/profiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmVirtualProfiles), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PatchVirtualProfiles")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmVirtualProfiles), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PatchVirtualProfiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmVirtualProfiles)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostAlgLogProfile
//
//
// Defines the configuration for logging of ALG flows..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostAlgLogProfile(id string, object LtmAlgLogProfile) (*LtmAlgLogProfile, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/algLogProfile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAlgLogProfile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostAlgLogProfile")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAlgLogProfile), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostAlgLogProfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAlgLogProfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostAuthCrldpServer
//
//
// Certificate Revocation List Distribution Point (CRDLP) server configuration, for use with a CRLDP authentication profile.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostAuthCrldpServer(id string, object LtmAuthCrldpServer) (*LtmAuthCrldpServer, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/crldpServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthCrldpServer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostAuthCrldpServer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthCrldpServer), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostAuthCrldpServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthCrldpServer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostAuthKerberosDelegation
//
//
// Kerberos configuration for remote client authentication.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostAuthKerberosDelegation(id string, object LtmAuthKerberosDelegation) (*LtmAuthKerberosDelegation, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/kerberosDelegation/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthKerberosDelegation), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostAuthKerberosDelegation")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthKerberosDelegation), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostAuthKerberosDelegation")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthKerberosDelegation)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostAuthLdap
//
//
// LDAP configuration for remote LDAP client authentication.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostAuthLdap(id string, object LtmAuthLdap) (*LtmAuthLdap, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/ldap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthLdap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostAuthLdap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthLdap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostAuthLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthLdap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostAuthOcspResponder
//
//
// Online Certificate System Protocol (OCSP) responder configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostAuthOcspResponder(id string, object LtmAuthOcspResponder) (*LtmAuthOcspResponder, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/ocspResponder/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthOcspResponder), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostAuthOcspResponder")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthOcspResponder), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostAuthOcspResponder")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthOcspResponder)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostAuthProfile
//
//
// Virtual server traffic Authentication profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostAuthProfile(id string, object LtmAuthProfile) (*LtmAuthProfile, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/profile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthProfile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostAuthProfile")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthProfile), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostAuthProfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthProfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostAuthRadius
//
//
// RADIUS configuration for remote RADIUS client authentication.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostAuthRadius(id string, object LtmAuthRadius) (*LtmAuthRadius, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/radius/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthRadius), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostAuthRadius")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthRadius), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostAuthRadius")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthRadius)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostAuthRadiusServer
//
//
// RADIUS server configuration for use with RADIUS authentication profiles.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostAuthRadiusServer(id string, object LtmAuthRadiusServer) (*LtmAuthRadiusServer, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/radiusServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthRadiusServer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostAuthRadiusServer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthRadiusServer), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostAuthRadiusServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthRadiusServer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostAuthSslCcLdap
//
//
// SSL client certificate configuration, for use with remote SSL-based LDAP authorization.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostAuthSslCcLdap(id string, object LtmAuthSslCcLdap) (*LtmAuthSslCcLdap, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/sslCcLdap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthSslCcLdap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostAuthSslCcLdap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthSslCcLdap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostAuthSslCcLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthSslCcLdap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostAuthSslCrldp
//
//
// SSL client certificate configuration, for use with remote SSL-based CRLDP authorization.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostAuthSslCrldp(id string, object LtmAuthSslCrldp) (*LtmAuthSslCrldp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/sslCrldp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthSslCrldp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostAuthSslCrldp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthSslCrldp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostAuthSslCrldp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthSslCrldp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostAuthSslOcsp
//
//
// OCSP configuration for implementing remote OCSP-based client authentication.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostAuthSslOcsp(id string, object LtmAuthSslOcsp) (*LtmAuthSslOcsp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/sslOcsp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthSslOcsp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostAuthSslOcsp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthSslOcsp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostAuthSslOcsp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthSslOcsp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostAuthTacacs
//
//
// TACACS+ configuration for remote TACACS+ client authentication.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostAuthTacacs(id string, object LtmAuthTacacs) (*LtmAuthTacacs, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/tacacs/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthTacacs), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostAuthTacacs")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthTacacs), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostAuthTacacs")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthTacacs)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostClassificationApplication
//
//
// Traffic Classification Application.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostClassificationApplication(id string, object LtmClassificationApplication) (*LtmClassificationApplication, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/application/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationApplication), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostClassificationApplication")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationApplication), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostClassificationApplication")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationApplication)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostClassificationCategory
//
//
// Traffic Classification Category.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostClassificationCategory(id string, object LtmClassificationCategory) (*LtmClassificationCategory, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/category/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationCategory), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostClassificationCategory")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationCategory), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostClassificationCategory")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationCategory)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostClassificationSignatureDefinition
//
//
// Configure status for classification signature updates..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostClassificationSignatureDefinition(id string, object LtmClassificationSignatureDefinition) (*LtmClassificationSignatureDefinition, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/signatureDefinition/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationSignatureDefinition), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostClassificationSignatureDefinition")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationSignatureDefinition), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostClassificationSignatureDefinition")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationSignatureDefinition)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostClassificationSignatures
//
//
// Load classification signatures file either from folder /var/log/dpi/signatures/, or from the folder specified in the name of the file..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostClassificationSignatures(id string, object LtmClassificationSignatures) (*LtmClassificationSignatures, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/signatures/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationSignatures), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostClassificationSignatures")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationSignatures), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostClassificationSignatures")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationSignatures)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostClassificationStatsApplication
//
//
// Statistics of classified applications.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostClassificationStatsApplication(id string, object LtmClassificationStatsApplication) (*LtmClassificationStatsApplication, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/stats/application/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationStatsApplication), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostClassificationStatsApplication")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationStatsApplication), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostClassificationStatsApplication")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationStatsApplication)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostClassificationStatsUrlCategory
//
//
// Statistics of classified url-category.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostClassificationStatsUrlCategory(id string, object LtmClassificationStatsUrlCategory) (*LtmClassificationStatsUrlCategory, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/stats/urlCategory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationStatsUrlCategory), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostClassificationStatsUrlCategory")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationStatsUrlCategory), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostClassificationStatsUrlCategory")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationStatsUrlCategory)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostClassificationUpdateSignatures
//
//
// Run classification signatures update..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostClassificationUpdateSignatures(id string, object LtmClassificationUpdateSignatures) (*LtmClassificationUpdateSignatures, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/updateSignatures/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationUpdateSignatures), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostClassificationUpdateSignatures")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationUpdateSignatures), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostClassificationUpdateSignatures")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationUpdateSignatures)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostClassificationUrlCatPolicy
//
//
// URL Categorization policy.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostClassificationUrlCatPolicy(id string, object LtmClassificationUrlCatPolicy) (*LtmClassificationUrlCatPolicy, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urlCatPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationUrlCatPolicy), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostClassificationUrlCatPolicy")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationUrlCatPolicy), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostClassificationUrlCatPolicy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationUrlCatPolicy)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostClassificationUrlCategory
//
//
// URL Classification Category.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostClassificationUrlCategory(id string, object LtmClassificationUrlCategory) (*LtmClassificationUrlCategory, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urlCategory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationUrlCategory), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostClassificationUrlCategory")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationUrlCategory), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostClassificationUrlCategory")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationUrlCategory)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostClassificationUrldbFeedList
//
//
// Reusable URLDB feed lists for URL Categorization..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostClassificationUrldbFeedList(id string, object LtmClassificationUrldbFeedList) (*LtmClassificationUrldbFeedList, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urldbFeedList/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationUrldbFeedList), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostClassificationUrldbFeedList")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationUrldbFeedList), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostClassificationUrldbFeedList")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationUrldbFeedList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostClassificationUrldbFile
//
//
// File object for custom url category database..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostClassificationUrldbFile(id string, object LtmClassificationUrldbFile) (*LtmClassificationUrldbFile, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urldbFile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationUrldbFile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostClassificationUrldbFile")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationUrldbFile), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostClassificationUrldbFile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationUrldbFile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostDataGroupExternal
//
//
// External data group configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostDataGroupExternal(id string, object LtmDataGroupExternal) (*LtmDataGroupExternal, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dataGroup/external/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDataGroupExternal), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostDataGroupExternal")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDataGroupExternal), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostDataGroupExternal")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDataGroupExternal)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostDataGroupInternal
//
//
// Internal data group configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostDataGroupInternal(id string, object LtmDataGroupInternal) (*LtmDataGroupInternal, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dataGroup/internal/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDataGroupInternal), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostDataGroupInternal")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDataGroupInternal), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostDataGroupInternal")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDataGroupInternal)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostDnsCacheResolver
//
//
// DNS Cache with recursive resolver..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostDnsCacheResolver(id string, object LtmDnsCacheResolver) (*LtmDnsCacheResolver, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/resolver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsCacheResolver), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostDnsCacheResolver")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsCacheResolver), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostDnsCacheResolver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsCacheResolver)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostDnsCacheTransparent
//
//
// DNS Cache without a resolver (responses from serverside cached)..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostDnsCacheTransparent(id string, object LtmDnsCacheTransparent) (*LtmDnsCacheTransparent, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/transparent/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsCacheTransparent), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostDnsCacheTransparent")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsCacheTransparent), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostDnsCacheTransparent")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsCacheTransparent)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostDnsCacheValidatingResolver
//
//
// DNS Cache with recursive resolver and DNSSEC validation..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostDnsCacheValidatingResolver(id string, object LtmDnsCacheValidatingResolver) (*LtmDnsCacheValidatingResolver, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/validatingResolver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsCacheValidatingResolver), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostDnsCacheValidatingResolver")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsCacheValidatingResolver), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostDnsCacheValidatingResolver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsCacheValidatingResolver)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostDnsDnsExpressDb
//
//
// DNS Express database loaded into BIG-IP..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostDnsDnsExpressDb(id string, object LtmDnsDnsExpressDb) (*LtmDnsDnsExpressDb, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/dnsExpressDb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsDnsExpressDb), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostDnsDnsExpressDb")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsDnsExpressDb), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostDnsDnsExpressDb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsDnsExpressDb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostDnsDnssecKey
//
//
// DNSSEC key configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostDnsDnssecKey(id string, object LtmDnsDnssecKey) (*LtmDnsDnssecKey, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/dnssec/key/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsDnssecKey), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostDnsDnssecKey")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsDnssecKey), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostDnsDnssecKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsDnssecKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostDnsDnssecZone
//
//
// DNSSEC zone configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostDnsDnssecZone(id string, object LtmDnsDnssecZone) (*LtmDnsDnssecZone, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/dnssec/zone/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsDnssecZone), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostDnsDnssecZone")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsDnssecZone), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostDnsDnssecZone")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsDnssecZone)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostDnsNameserver
//
//
// DNS nameserver configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostDnsNameserver(id string, object LtmDnsNameserver) (*LtmDnsNameserver, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/nameserver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsNameserver), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostDnsNameserver")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsNameserver), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostDnsNameserver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsNameserver)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostDnsTsigKey
//
//
// TSIG Key configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostDnsTsigKey(id string, object LtmDnsTsigKey) (*LtmDnsTsigKey, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/tsigKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsTsigKey), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostDnsTsigKey")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsTsigKey), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostDnsTsigKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsTsigKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostDnsZone
//
//
// Zone configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostDnsZone(id string, object LtmDnsZone) (*LtmDnsZone, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/zone/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsZone), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostDnsZone")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsZone), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostDnsZone")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsZone)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostEvictionPolicy
//
//
// Defines an eviction policy, used to select which flows to evict when approaching limits..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostEvictionPolicy(id string, object LtmEvictionPolicy) (*LtmEvictionPolicy, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/evictionPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmEvictionPolicy), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostEvictionPolicy")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmEvictionPolicy), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostEvictionPolicy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmEvictionPolicy)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostHtmlRuleCommentRaiseEvent
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostHtmlRuleCommentRaiseEvent(id string, object LtmHtmlRuleCommentRaiseEvent) (*LtmHtmlRuleCommentRaiseEvent, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/commentRaiseEvent/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleCommentRaiseEvent), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostHtmlRuleCommentRaiseEvent")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmHtmlRuleCommentRaiseEvent), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostHtmlRuleCommentRaiseEvent")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmHtmlRuleCommentRaiseEvent)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostHtmlRuleCommentRemove
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostHtmlRuleCommentRemove(id string, object LtmHtmlRuleCommentRemove) (*LtmHtmlRuleCommentRemove, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/commentRemove/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleCommentRemove), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostHtmlRuleCommentRemove")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmHtmlRuleCommentRemove), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostHtmlRuleCommentRemove")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmHtmlRuleCommentRemove)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostHtmlRuleTagAppendHtml
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostHtmlRuleTagAppendHtml(id string, object LtmHtmlRuleTagAppendHtml) (*LtmHtmlRuleTagAppendHtml, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagAppendHtml/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleTagAppendHtml), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostHtmlRuleTagAppendHtml")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmHtmlRuleTagAppendHtml), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostHtmlRuleTagAppendHtml")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmHtmlRuleTagAppendHtml)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostHtmlRuleTagPrependHtml
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostHtmlRuleTagPrependHtml(id string, object LtmHtmlRuleTagPrependHtml) (*LtmHtmlRuleTagPrependHtml, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagPrependHtml/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleTagPrependHtml), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostHtmlRuleTagPrependHtml")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmHtmlRuleTagPrependHtml), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostHtmlRuleTagPrependHtml")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmHtmlRuleTagPrependHtml)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostHtmlRuleTagRaiseEvent
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostHtmlRuleTagRaiseEvent(id string, object LtmHtmlRuleTagRaiseEvent) (*LtmHtmlRuleTagRaiseEvent, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagRaiseEvent/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleTagRaiseEvent), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostHtmlRuleTagRaiseEvent")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmHtmlRuleTagRaiseEvent), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostHtmlRuleTagRaiseEvent")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmHtmlRuleTagRaiseEvent)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostHtmlRuleTagRemove
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostHtmlRuleTagRemove(id string, object LtmHtmlRuleTagRemove) (*LtmHtmlRuleTagRemove, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagRemove/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleTagRemove), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostHtmlRuleTagRemove")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmHtmlRuleTagRemove), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostHtmlRuleTagRemove")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmHtmlRuleTagRemove)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostHtmlRuleTagRemoveAttribute
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostHtmlRuleTagRemoveAttribute(id string, object LtmHtmlRuleTagRemoveAttribute) (*LtmHtmlRuleTagRemoveAttribute, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagRemoveAttribute/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleTagRemoveAttribute), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostHtmlRuleTagRemoveAttribute")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmHtmlRuleTagRemoveAttribute), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostHtmlRuleTagRemoveAttribute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmHtmlRuleTagRemoveAttribute)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostIfile
//
//
// iFile Configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostIfile(id string, object LtmIfile) (*LtmIfile, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/ifile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmIfile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostIfile")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmIfile), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostIfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmIfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostLsnLogProfile
//
//
// Defines the configuration for logging of LSN flows..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostLsnLogProfile(id string, object LtmLsnLogProfile) (*LtmLsnLogProfile, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/lsnLogProfile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmLsnLogProfile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostLsnLogProfile")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmLsnLogProfile), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostLsnLogProfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmLsnLogProfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostLsnPool
//
//
// LSNAT/CGNAT translation address configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostLsnPool(id string, object LtmLsnPool) (*LtmLsnPool, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/lsnPool/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmLsnPool), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostLsnPool")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmLsnPool), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostLsnPool")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmLsnPool)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMessageRoutingDiameterPeer
//
//
// Peed for routing generic message protocol messages..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMessageRoutingDiameterPeer(id string, object LtmMessageRoutingDiameterPeer) (*LtmMessageRoutingDiameterPeer, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/peer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterPeer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMessageRoutingDiameterPeer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingDiameterPeer), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMessageRoutingDiameterPeer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingDiameterPeer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMessageRoutingDiameterProfileRouter
//
//
// Configures a Diameter Router profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMessageRoutingDiameterProfileRouter(id string, object LtmMessageRoutingDiameterProfileRouter) (*LtmMessageRoutingDiameterProfileRouter, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/profile/router/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterProfileRouter), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMessageRoutingDiameterProfileRouter")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingDiameterProfileRouter), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMessageRoutingDiameterProfileRouter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingDiameterProfileRouter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMessageRoutingDiameterProfileSession
//
//
// Configures a Diameter Session profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMessageRoutingDiameterProfileSession(id string, object LtmMessageRoutingDiameterProfileSession) (*LtmMessageRoutingDiameterProfileSession, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/profile/session/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterProfileSession), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMessageRoutingDiameterProfileSession")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingDiameterProfileSession), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMessageRoutingDiameterProfileSession")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingDiameterProfileSession)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMessageRoutingDiameterRoute
//
//
// Configures a static route for use in Diameter message routing..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMessageRoutingDiameterRoute(id string, object LtmMessageRoutingDiameterRoute) (*LtmMessageRoutingDiameterRoute, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/route/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterRoute), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMessageRoutingDiameterRoute")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingDiameterRoute), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMessageRoutingDiameterRoute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingDiameterRoute)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMessageRoutingDiameterTransportConfig
//
//
// Defines the configuration for an outgoing connection..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMessageRoutingDiameterTransportConfig(id string, object LtmMessageRoutingDiameterTransportConfig) (*LtmMessageRoutingDiameterTransportConfig, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/transportConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterTransportConfig), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMessageRoutingDiameterTransportConfig")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingDiameterTransportConfig), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMessageRoutingDiameterTransportConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingDiameterTransportConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMessageRoutingDiameterTransportConfigProfiles
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMessageRoutingDiameterTransportConfigProfiles(id string, object LtmMessageRoutingDiameterTransportConfigProfiles) (*LtmMessageRoutingDiameterTransportConfigProfiles, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/transportConfig/profiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterTransportConfigProfiles), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMessageRoutingDiameterTransportConfigProfiles")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingDiameterTransportConfigProfiles), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMessageRoutingDiameterTransportConfigProfiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingDiameterTransportConfigProfiles)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMessageRoutingGenericPeer
//
//
// Peed for routing generic message protocol messages..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMessageRoutingGenericPeer(id string, object LtmMessageRoutingGenericPeer) (*LtmMessageRoutingGenericPeer, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/peer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericPeer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMessageRoutingGenericPeer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingGenericPeer), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMessageRoutingGenericPeer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingGenericPeer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMessageRoutingGenericProtocol
//
//
// Generic message parser for use with the message routing framework..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMessageRoutingGenericProtocol(id string, object LtmMessageRoutingGenericProtocol) (*LtmMessageRoutingGenericProtocol, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/protocol/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericProtocol), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMessageRoutingGenericProtocol")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingGenericProtocol), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMessageRoutingGenericProtocol")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingGenericProtocol)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMessageRoutingGenericRoute
//
//
// Static route for routing generic message protocol messages..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMessageRoutingGenericRoute(id string, object LtmMessageRoutingGenericRoute) (*LtmMessageRoutingGenericRoute, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/route/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericRoute), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMessageRoutingGenericRoute")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingGenericRoute), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMessageRoutingGenericRoute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingGenericRoute)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMessageRoutingGenericRouter
//
//
// Message routing instance for generic message protocol..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMessageRoutingGenericRouter(id string, object LtmMessageRoutingGenericRouter) (*LtmMessageRoutingGenericRouter, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/router/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericRouter), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMessageRoutingGenericRouter")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingGenericRouter), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMessageRoutingGenericRouter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingGenericRouter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMessageRoutingGenericTransportConfig
//
//
// Defines the configuration for an outgoing connection..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMessageRoutingGenericTransportConfig(id string, object LtmMessageRoutingGenericTransportConfig) (*LtmMessageRoutingGenericTransportConfig, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/transportConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericTransportConfig), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMessageRoutingGenericTransportConfig")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingGenericTransportConfig), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMessageRoutingGenericTransportConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingGenericTransportConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMessageRoutingGenericTransportConfigProfiles
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMessageRoutingGenericTransportConfigProfiles(id string, object LtmMessageRoutingGenericTransportConfigProfiles) (*LtmMessageRoutingGenericTransportConfigProfiles, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/transportConfig/profiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericTransportConfigProfiles), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMessageRoutingGenericTransportConfigProfiles")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingGenericTransportConfigProfiles), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMessageRoutingGenericTransportConfigProfiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingGenericTransportConfigProfiles)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMessageRoutingSipPeer
//
//
// Peed for routing generic message protocol messages..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMessageRoutingSipPeer(id string, object LtmMessageRoutingSipPeer) (*LtmMessageRoutingSipPeer, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/peer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipPeer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMessageRoutingSipPeer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingSipPeer), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMessageRoutingSipPeer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingSipPeer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMessageRoutingSipProfileRouter
//
//
// Configures a Session Initiation Protocol (SIP) Router profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMessageRoutingSipProfileRouter(id string, object LtmMessageRoutingSipProfileRouter) (*LtmMessageRoutingSipProfileRouter, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/profile/router/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipProfileRouter), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMessageRoutingSipProfileRouter")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingSipProfileRouter), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMessageRoutingSipProfileRouter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingSipProfileRouter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMessageRoutingSipProfileSession
//
//
// Configures a Session Initiation Protocol (SIP) Session profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMessageRoutingSipProfileSession(id string, object LtmMessageRoutingSipProfileSession) (*LtmMessageRoutingSipProfileSession, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/profile/session/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipProfileSession), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMessageRoutingSipProfileSession")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingSipProfileSession), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMessageRoutingSipProfileSession")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingSipProfileSession)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMessageRoutingSipRoute
//
//
// Configures a static route for use in Session Initiation Protocol (SIP) message routing..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMessageRoutingSipRoute(id string, object LtmMessageRoutingSipRoute) (*LtmMessageRoutingSipRoute, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/route/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipRoute), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMessageRoutingSipRoute")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingSipRoute), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMessageRoutingSipRoute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingSipRoute)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMessageRoutingSipTransportConfig
//
//
// Defines the configuration for an outgoing connection..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMessageRoutingSipTransportConfig(id string, object LtmMessageRoutingSipTransportConfig) (*LtmMessageRoutingSipTransportConfig, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/transportConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipTransportConfig), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMessageRoutingSipTransportConfig")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingSipTransportConfig), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMessageRoutingSipTransportConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingSipTransportConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMessageRoutingSipTransportConfigProfiles
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMessageRoutingSipTransportConfigProfiles(id string, object LtmMessageRoutingSipTransportConfigProfiles) (*LtmMessageRoutingSipTransportConfigProfiles, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/transportConfig/profiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipTransportConfigProfiles), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMessageRoutingSipTransportConfigProfiles")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingSipTransportConfigProfiles), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMessageRoutingSipTransportConfigProfiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingSipTransportConfigProfiles)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorDiameter
//
//
// Diameter monitor configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorDiameter(id string, object LtmMonitorDiameter) (*LtmMonitorDiameter, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/diameter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorDiameter), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorDiameter")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorDiameter), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorDiameter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorDiameter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorDns
//
//
// DNS monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorDns(id string, object LtmMonitorDns) (*LtmMonitorDns, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/dns/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorDns), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorDns")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorDns), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorDns")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorDns)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorExternal
//
//
// External monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorExternal(id string, object LtmMonitorExternal) (*LtmMonitorExternal, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/external/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorExternal), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorExternal")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorExternal), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorExternal")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorExternal)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorFirepass
//
//
// Firepass monitor configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorFirepass(id string, object LtmMonitorFirepass) (*LtmMonitorFirepass, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/firepass/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorFirepass), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorFirepass")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorFirepass), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorFirepass")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorFirepass)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorFtp
//
//
// FTP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorFtp(id string, object LtmMonitorFtp) (*LtmMonitorFtp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/ftp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorFtp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorFtp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorFtp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorFtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorFtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorGatewayIcmp
//
//
// Gateway ICMP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorGatewayIcmp(id string, object LtmMonitorGatewayIcmp) (*LtmMonitorGatewayIcmp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/gatewayIcmp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorGatewayIcmp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorGatewayIcmp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorGatewayIcmp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorGatewayIcmp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorGatewayIcmp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorHttp
//
//
// HTTP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorHttp(id string, object LtmMonitorHttp) (*LtmMonitorHttp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/http/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorHttp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorHttp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorHttp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorHttp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorHttp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorHttps
//
//
// HTTPS monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorHttps(id string, object LtmMonitorHttps) (*LtmMonitorHttps, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/https/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorHttps), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorHttps")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorHttps), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorHttps")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorHttps)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorIcmp
//
//
// ICMP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorIcmp(id string, object LtmMonitorIcmp) (*LtmMonitorIcmp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/icmp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorIcmp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorIcmp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorIcmp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorIcmp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorIcmp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorImap
//
//
// IMAP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorImap(id string, object LtmMonitorImap) (*LtmMonitorImap, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/imap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorImap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorImap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorImap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorImap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorImap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorInband
//
//
// Inband monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorInband(id string, object LtmMonitorInband) (*LtmMonitorInband, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/inband/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorInband), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorInband")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorInband), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorInband")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorInband)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorLdap
//
//
// LDAP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorLdap(id string, object LtmMonitorLdap) (*LtmMonitorLdap, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/ldap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorLdap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorLdap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorLdap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorLdap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorModuleScore
//
//
// Module score monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorModuleScore(id string, object LtmMonitorModuleScore) (*LtmMonitorModuleScore, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/moduleScore/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorModuleScore), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorModuleScore")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorModuleScore), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorModuleScore")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorModuleScore)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorMssql
//
//
// MSSQL monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorMssql(id string, object LtmMonitorMssql) (*LtmMonitorMssql, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/mssql/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorMssql), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorMssql")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorMssql), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorMssql")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorMssql)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorMysql
//
//
// MySQL monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorMysql(id string, object LtmMonitorMysql) (*LtmMonitorMysql, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/mysql/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorMysql), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorMysql")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorMysql), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorMysql")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorMysql)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorNntp
//
//
// NNTP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorNntp(id string, object LtmMonitorNntp) (*LtmMonitorNntp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/nntp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorNntp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorNntp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorNntp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorNntp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorNntp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorNone
//
//
// The NULL monitor..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorNone(id string, object LtmMonitorNone) (*LtmMonitorNone, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/none/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorNone), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorNone")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorNone), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorNone")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorNone)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorOracle
//
//
// Oracle monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorOracle(id string, object LtmMonitorOracle) (*LtmMonitorOracle, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/oracle/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorOracle), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorOracle")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorOracle), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorOracle")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorOracle)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorPop3
//
//
// POP3 monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorPop3(id string, object LtmMonitorPop3) (*LtmMonitorPop3, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/pop3/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorPop3), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorPop3")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorPop3), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorPop3")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorPop3)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorPostgresql
//
//
// Postgresql monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorPostgresql(id string, object LtmMonitorPostgresql) (*LtmMonitorPostgresql, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/postgresql/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorPostgresql), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorPostgresql")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorPostgresql), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorPostgresql")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorPostgresql)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorRadius
//
//
// Radius monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorRadius(id string, object LtmMonitorRadius) (*LtmMonitorRadius, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/radius/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorRadius), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorRadius")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorRadius), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorRadius")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorRadius)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorRadiusAccounting
//
//
// Radius accounting monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorRadiusAccounting(id string, object LtmMonitorRadiusAccounting) (*LtmMonitorRadiusAccounting, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/radiusAccounting/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorRadiusAccounting), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorRadiusAccounting")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorRadiusAccounting), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorRadiusAccounting")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorRadiusAccounting)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorRealServer
//
//
// Real Server monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorRealServer(id string, object LtmMonitorRealServer) (*LtmMonitorRealServer, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/realServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorRealServer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorRealServer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorRealServer), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorRealServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorRealServer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorRpc
//
//
// RPC monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorRpc(id string, object LtmMonitorRpc) (*LtmMonitorRpc, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/rpc/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorRpc), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorRpc")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorRpc), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorRpc")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorRpc)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorSasp
//
//
// SASP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorSasp(id string, object LtmMonitorSasp) (*LtmMonitorSasp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/sasp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSasp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorSasp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorSasp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorSasp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorSasp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorScripted
//
//
// Scripted monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorScripted(id string, object LtmMonitorScripted) (*LtmMonitorScripted, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/scripted/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorScripted), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorScripted")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorScripted), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorScripted")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorScripted)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorSip
//
//
// SIP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorSip(id string, object LtmMonitorSip) (*LtmMonitorSip, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/sip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSip), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorSip")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorSip), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorSip")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorSip)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorSmb
//
//
// SMB monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorSmb(id string, object LtmMonitorSmb) (*LtmMonitorSmb, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/smb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSmb), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorSmb")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorSmb), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorSmb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorSmb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorSmtp
//
//
// SMTP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorSmtp(id string, object LtmMonitorSmtp) (*LtmMonitorSmtp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/smtp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSmtp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorSmtp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorSmtp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorSmtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorSmtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorSnmpDca
//
//
// SNMP DCA monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorSnmpDca(id string, object LtmMonitorSnmpDca) (*LtmMonitorSnmpDca, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/snmpDca/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSnmpDca), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorSnmpDca")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorSnmpDca), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorSnmpDca")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorSnmpDca)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorSnmpDcaBase
//
//
// SNMP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorSnmpDcaBase(id string, object LtmMonitorSnmpDcaBase) (*LtmMonitorSnmpDcaBase, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/snmpDcaBase/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSnmpDcaBase), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorSnmpDcaBase")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorSnmpDcaBase), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorSnmpDcaBase")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorSnmpDcaBase)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorSoap
//
//
// SOAP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorSoap(id string, object LtmMonitorSoap) (*LtmMonitorSoap, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/soap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSoap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorSoap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorSoap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorSoap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorSoap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorTcp
//
//
// TCP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorTcp(id string, object LtmMonitorTcp) (*LtmMonitorTcp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/tcp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorTcp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorTcp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorTcp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorTcp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorTcp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorTcpEcho
//
//
// TCP Echo monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorTcpEcho(id string, object LtmMonitorTcpEcho) (*LtmMonitorTcpEcho, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/tcpEcho/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorTcpEcho), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorTcpEcho")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorTcpEcho), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorTcpEcho")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorTcpEcho)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorTcpHalfOpen
//
//
// TCP Half Open monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorTcpHalfOpen(id string, object LtmMonitorTcpHalfOpen) (*LtmMonitorTcpHalfOpen, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/tcpHalfOpen/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorTcpHalfOpen), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorTcpHalfOpen")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorTcpHalfOpen), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorTcpHalfOpen")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorTcpHalfOpen)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorUdp
//
//
// UDP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorUdp(id string, object LtmMonitorUdp) (*LtmMonitorUdp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/udp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorUdp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorUdp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorUdp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorUdp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorUdp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorVirtualLocation
//
//
// Virtual Location monitor configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorVirtualLocation(id string, object LtmMonitorVirtualLocation) (*LtmMonitorVirtualLocation, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/virtualLocation/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorVirtualLocation), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorVirtualLocation")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorVirtualLocation), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorVirtualLocation")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorVirtualLocation)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorWap
//
//
// WAP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorWap(id string, object LtmMonitorWap) (*LtmMonitorWap, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/wap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorWap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorWap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorWap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorWap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorWap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostMonitorWmi
//
//
// WMI monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostMonitorWmi(id string, object LtmMonitorWmi) (*LtmMonitorWmi, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/wmi/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorWmi), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostMonitorWmi")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorWmi), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostMonitorWmi")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorWmi)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostNat
//
//
// Network address translation configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostNat(id string, object LtmNat) (*LtmNat, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/nat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmNat), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostNat")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmNat), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostNat")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmNat)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostNode
//
//
// Node specific pool member configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostNode(id string, object LtmNode) (*LtmNode, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/node/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmNode), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostNode")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmNode), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostNode")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmNode)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostPersistenceCookie
//
//
// Virtual server Cookie persistence profile.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostPersistenceCookie(id string, object LtmPersistenceCookie) (*LtmPersistenceCookie, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/cookie/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceCookie), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostPersistenceCookie")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceCookie), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostPersistenceCookie")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceCookie)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostPersistenceDestAddr
//
//
// Virtual server Destination Address Affinity persistence profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostPersistenceDestAddr(id string, object LtmPersistenceDestAddr) (*LtmPersistenceDestAddr, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/destAddr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceDestAddr), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostPersistenceDestAddr")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceDestAddr), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostPersistenceDestAddr")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceDestAddr)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostPersistenceHash
//
//
// Virtual server Hash persistence profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostPersistenceHash(id string, object LtmPersistenceHash) (*LtmPersistenceHash, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/hash/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceHash), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostPersistenceHash")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceHash), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostPersistenceHash")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceHash)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostPersistenceMsrdp
//
//
// Virtual server Microsoft Remote Desktop (MSRDP) persistence profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostPersistenceMsrdp(id string, object LtmPersistenceMsrdp) (*LtmPersistenceMsrdp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/msrdp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceMsrdp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostPersistenceMsrdp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceMsrdp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostPersistenceMsrdp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceMsrdp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostPersistenceSip
//
//
// Virtual server SIP persistence profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostPersistenceSip(id string, object LtmPersistenceSip) (*LtmPersistenceSip, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/sip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceSip), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostPersistenceSip")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceSip), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostPersistenceSip")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceSip)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostPersistenceSourceAddr
//
//
// Virtual server Source Address persistence profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostPersistenceSourceAddr(id string, object LtmPersistenceSourceAddr) (*LtmPersistenceSourceAddr, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/sourceAddr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceSourceAddr), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostPersistenceSourceAddr")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceSourceAddr), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostPersistenceSourceAddr")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceSourceAddr)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostPersistenceSsl
//
//
// Virtual server SSL persistence profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostPersistenceSsl(id string, object LtmPersistenceSsl) (*LtmPersistenceSsl, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/ssl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceSsl), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostPersistenceSsl")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceSsl), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostPersistenceSsl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceSsl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostPersistenceUniversal
//
//
// Virtual server Universal persistence profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostPersistenceUniversal(id string, object LtmPersistenceUniversal) (*LtmPersistenceUniversal, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/universal/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceUniversal), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostPersistenceUniversal")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceUniversal), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostPersistenceUniversal")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceUniversal)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostPolicy
//
//
// Centralized Policy Matching configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostPolicy(id string, object LtmPolicy) (*LtmPolicy, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicy), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostPolicy")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPolicy), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostPolicy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPolicy)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostPolicyRules
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostPolicyRules(id string, object LtmPolicyRules) (*LtmPolicyRules, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/rules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicyRules), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostPolicyRules")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPolicyRules), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostPolicyRules")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPolicyRules)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostPolicyRulesActions
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostPolicyRulesActions(id string, object LtmPolicyRulesActions) (*LtmPolicyRulesActions, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/rules/actions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicyRulesActions), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostPolicyRulesActions")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPolicyRulesActions), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostPolicyRulesActions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPolicyRulesActions)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostPolicyRulesConditions
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostPolicyRulesConditions(id string, object LtmPolicyRulesConditions) (*LtmPolicyRulesConditions, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/rules/conditions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicyRulesConditions), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostPolicyRulesConditions")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPolicyRulesConditions), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostPolicyRulesConditions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPolicyRulesConditions)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostPolicyStrategy
//
//
// Centralized Policy Matching rule selection strategy.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostPolicyStrategy(id string, object LtmPolicyStrategy) (*LtmPolicyStrategy, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policyStrategy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicyStrategy), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostPolicyStrategy")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPolicyStrategy), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostPolicyStrategy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPolicyStrategy)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostPolicyStrategyOperands
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostPolicyStrategyOperands(id string, object LtmPolicyStrategyOperands) (*LtmPolicyStrategyOperands, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policyStrategy/operands/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicyStrategyOperands), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostPolicyStrategyOperands")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPolicyStrategyOperands), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostPolicyStrategyOperands")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPolicyStrategyOperands)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostPool
//
//
// Load balancing pool configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostPool(id string, object LtmPool) (*LtmPool, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/pool/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPool), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostPool")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPool), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostPool")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPool)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostPoolMembers
//
//
// Manage the set of pool members that are associated with a load balancing pool.
//
// pid is for ID of the parent resource
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostPoolMembers(pid string, id string, object LtmPoolMembers) (*LtmPoolMembers, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/pool/{pid}/members/{id}"
	path = strings.Replace(path, "{"+"pid"+"}", fmt.Sprintf("%v", pid), -1)
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'pid' is set
	if &pid == nil {
		return new(LtmPoolMembers), nil, errors.New("Missing required parameter 'pid' when calling LtmApi->PostPoolMembers")
	}
	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPoolMembers), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostPoolMembers")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPoolMembers), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostPoolMembers")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPoolMembers)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileAnalytics
//
//
// Virtual server analytics profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileAnalytics(id string, object LtmProfileAnalytics) (*LtmProfileAnalytics, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/analytics/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileAnalytics), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileAnalytics")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileAnalytics), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileAnalytics")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileAnalytics)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileAnalyticsAlerts
//
//
// Manage the set of analytics alerts that are associated with an analytics profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileAnalyticsAlerts(id string, object LtmProfileAnalyticsAlerts) (*LtmProfileAnalyticsAlerts, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/analytics/alerts/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileAnalyticsAlerts), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileAnalyticsAlerts")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileAnalyticsAlerts), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileAnalyticsAlerts")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileAnalyticsAlerts)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileAnalyticsTrafficCapture
//
//
// Manage the set of analytics alerts that are associated with an analytics profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileAnalyticsTrafficCapture(id string, object LtmProfileAnalyticsTrafficCapture) (*LtmProfileAnalyticsTrafficCapture, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/analytics/trafficCapture/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileAnalyticsTrafficCapture), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileAnalyticsTrafficCapture")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileAnalyticsTrafficCapture), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileAnalyticsTrafficCapture")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileAnalyticsTrafficCapture)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileCertificateAuthority
//
//
// Virtual server Certificate Authority profile configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileCertificateAuthority(id string, object LtmProfileCertificateAuthority) (*LtmProfileCertificateAuthority, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/certificateAuthority/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileCertificateAuthority), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileCertificateAuthority")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileCertificateAuthority), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileCertificateAuthority")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileCertificateAuthority)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileClientLdap
//
//
// Virtual server Client LDAP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileClientLdap(id string, object LtmProfileClientLdap) (*LtmProfileClientLdap, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/clientLdap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileClientLdap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileClientLdap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileClientLdap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileClientLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileClientLdap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileClientSsl
//
//
// Virtual server client-side proxy SSL profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileClientSsl(id string, object LtmProfileClientSsl) (*LtmProfileClientSsl, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/clientSsl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileClientSsl), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileClientSsl")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileClientSsl), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileClientSsl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileClientSsl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileDhcpv4
//
//
// Dynamic Host Configuration Protocol, DHCPv4, profile to manage DHCPv4 network traffic..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileDhcpv4(id string, object LtmProfileDhcpv4) (*LtmProfileDhcpv4, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dhcpv4/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileDhcpv4), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileDhcpv4")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileDhcpv4), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileDhcpv4")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileDhcpv4)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileDhcpv6
//
//
// Dynamic Host Configuration Protocol, DHCPv6, profile to manage DHCPv6 network traffic..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileDhcpv6(id string, object LtmProfileDhcpv6) (*LtmProfileDhcpv6, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dhcpv6/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileDhcpv6), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileDhcpv6")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileDhcpv6), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileDhcpv6")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileDhcpv6)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileDiameter
//
//
// Virtual server Diameter traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileDiameter(id string, object LtmProfileDiameter) (*LtmProfileDiameter, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/diameter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileDiameter), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileDiameter")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileDiameter), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileDiameter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileDiameter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileDns
//
//
// Virtual server DNS traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileDns(id string, object LtmProfileDns) (*LtmProfileDns, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dns/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileDns), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileDns")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileDns), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileDns")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileDns)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileDnsLogging
//
//
// High-speed logging settings for the DNS profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileDnsLogging(id string, object LtmProfileDnsLogging) (*LtmProfileDnsLogging, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dnsLogging/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileDnsLogging), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileDnsLogging")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileDnsLogging), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileDnsLogging")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileDnsLogging)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileFasthttp
//
//
// Virtual server Fast HTTP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileFasthttp(id string, object LtmProfileFasthttp) (*LtmProfileFasthttp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/fasthttp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileFasthttp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileFasthttp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileFasthttp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileFasthttp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileFasthttp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileFastl4
//
//
// Virtual server FastL4 traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileFastl4(id string, object LtmProfileFastl4) (*LtmProfileFastl4, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/fastl4/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileFastl4), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileFastl4")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileFastl4), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileFastl4")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileFastl4)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileFix
//
//
// Virtual server Financial Information eXchange(FIX) profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileFix(id string, object LtmProfileFix) (*LtmProfileFix, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/fix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileFix), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileFix")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileFix), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileFix")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileFix)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileFtp
//
//
// Virtual server FTP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileFtp(id string, object LtmProfileFtp) (*LtmProfileFtp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ftp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileFtp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileFtp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileFtp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileFtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileFtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileGtp
//
//
// Virtual server GTP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileGtp(id string, object LtmProfileGtp) (*LtmProfileGtp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/gtp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileGtp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileGtp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileGtp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileGtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileGtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileHtml
//
//
// Virtual server HTML profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileHtml(id string, object LtmProfileHtml) (*LtmProfileHtml, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/html/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileHtml), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileHtml")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileHtml), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileHtml")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileHtml)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileHttp
//
//
// Virtual server HTTP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileHttp(id string, object LtmProfileHttp) (*LtmProfileHttp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/http/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileHttp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileHttp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileHttp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileHttp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileHttp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileHttp2
//
//
// Virtual server HTTP/2 traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileHttp2(id string, object LtmProfileHttp2) (*LtmProfileHttp2, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/http2/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileHttp2), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileHttp2")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileHttp2), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileHttp2")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileHttp2)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileHttpCompression
//
//
// Virtual server HTTP compression profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileHttpCompression(id string, object LtmProfileHttpCompression) (*LtmProfileHttpCompression, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/httpCompression/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileHttpCompression), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileHttpCompression")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileHttpCompression), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileHttpCompression")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileHttpCompression)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileIcap
//
//
// Virtual server Internet Content Adaptation Protocol (ICAP) profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileIcap(id string, object LtmProfileIcap) (*LtmProfileIcap, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/icap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileIcap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileIcap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileIcap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileIcap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileIcap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileIiop
//
//
// Virtual server IIOP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileIiop(id string, object LtmProfileIiop) (*LtmProfileIiop, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/iiop/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileIiop), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileIiop")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileIiop), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileIiop")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileIiop)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileIpother
//
//
// Virtual server IPOTHER for non-TCP and non-UDP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileIpother(id string, object LtmProfileIpother) (*LtmProfileIpother, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ipother/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileIpother), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileIpother")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileIpother), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileIpother")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileIpother)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileMblb
//
//
// MBLB profile configuration (experimental).
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileMblb(id string, object LtmProfileMblb) (*LtmProfileMblb, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/mblb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileMblb), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileMblb")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileMblb), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileMblb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileMblb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileMssql
//
//
// Virtual server MSSQL profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileMssql(id string, object LtmProfileMssql) (*LtmProfileMssql, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/mssql/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileMssql), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileMssql")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileMssql), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileMssql")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileMssql)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileNtlm
//
//
// Virtual server NT Lan Manager profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileNtlm(id string, object LtmProfileNtlm) (*LtmProfileNtlm, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ntlm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileNtlm), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileNtlm")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileNtlm), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileNtlm")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileNtlm)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileOcspStaplingParams
//
//
// OCSP Stapling Parameters for clientssl profiles. This object should be associated with a cert-key-chain object in a clientssl profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileOcspStaplingParams(id string, object LtmProfileOcspStaplingParams) (*LtmProfileOcspStaplingParams, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ocspStaplingParams/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileOcspStaplingParams), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileOcspStaplingParams")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileOcspStaplingParams), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileOcspStaplingParams")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileOcspStaplingParams)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileOneConnect
//
//
// Virtual server OneConnect profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileOneConnect(id string, object LtmProfileOneConnect) (*LtmProfileOneConnect, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/oneConnect/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileOneConnect), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileOneConnect")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileOneConnect), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileOneConnect")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileOneConnect)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfilePcp
//
//
// LSN Pool PCP configuration profile.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfilePcp(id string, object LtmProfilePcp) (*LtmProfilePcp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/pcp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfilePcp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfilePcp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfilePcp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfilePcp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfilePcp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfilePptp
//
//
// Virtual server Point to Point Tunneling Protocol (PPTP) profile configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfilePptp(id string, object LtmProfilePptp) (*LtmProfilePptp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/pptp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfilePptp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfilePptp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfilePptp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfilePptp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfilePptp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileQoe
//
//
// Virtual server Quality of Experience profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileQoe(id string, object LtmProfileQoe) (*LtmProfileQoe, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/qoe/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileQoe), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileQoe")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileQoe), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileQoe")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileQoe)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileRadius
//
//
// Virtual server Radius traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileRadius(id string, object LtmProfileRadius) (*LtmProfileRadius, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/radius/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRadius), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileRadius")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileRadius), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileRadius")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileRadius)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileRequestAdapt
//
//
// Virtual server HTTP request adaptation profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileRequestAdapt(id string, object LtmProfileRequestAdapt) (*LtmProfileRequestAdapt, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/requestAdapt/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRequestAdapt), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileRequestAdapt")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileRequestAdapt), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileRequestAdapt")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileRequestAdapt)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileRequestLog
//
//
// Virtual server request logging profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileRequestLog(id string, object LtmProfileRequestLog) (*LtmProfileRequestLog, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/requestLog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRequestLog), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileRequestLog")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileRequestLog), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileRequestLog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileRequestLog)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileResponseAdapt
//
//
// Virtual server HTTP response adaptation profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileResponseAdapt(id string, object LtmProfileResponseAdapt) (*LtmProfileResponseAdapt, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/responseAdapt/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileResponseAdapt), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileResponseAdapt")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileResponseAdapt), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileResponseAdapt")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileResponseAdapt)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileRewrite
//
//
// Virtual server Rewrite profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileRewrite(id string, object LtmProfileRewrite) (*LtmProfileRewrite, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/rewrite/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRewrite), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileRewrite")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileRewrite), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileRewrite")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileRewrite)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileRewriteUriRules
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileRewriteUriRules(id string, object LtmProfileRewriteUriRules) (*LtmProfileRewriteUriRules, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/rewrite/uriRules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRewriteUriRules), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileRewriteUriRules")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileRewriteUriRules), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileRewriteUriRules")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileRewriteUriRules)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileRtsp
//
//
// Virtual server RTSP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileRtsp(id string, object LtmProfileRtsp) (*LtmProfileRtsp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/rtsp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRtsp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileRtsp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileRtsp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileRtsp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileRtsp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileSctp
//
//
// Virtual server SCTP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileSctp(id string, object LtmProfileSctp) (*LtmProfileSctp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/sctp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSctp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileSctp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileSctp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileSctp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileSctp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileServerLdap
//
//
// Virtual server Server LDAP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileServerLdap(id string, object LtmProfileServerLdap) (*LtmProfileServerLdap, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/serverLdap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileServerLdap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileServerLdap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileServerLdap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileServerLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileServerLdap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileServerSsl
//
//
// Virtual server server-side proxy SSL profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileServerSsl(id string, object LtmProfileServerSsl) (*LtmProfileServerSsl, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/serverSsl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileServerSsl), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileServerSsl")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileServerSsl), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileServerSsl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileServerSsl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileSip
//
//
// Virtual server SIP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileSip(id string, object LtmProfileSip) (*LtmProfileSip, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/sip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSip), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileSip")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileSip), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileSip")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileSip)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileSmtp
//
//
// Virtual server SMTP profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileSmtp(id string, object LtmProfileSmtp) (*LtmProfileSmtp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/smtp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSmtp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileSmtp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileSmtp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileSmtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileSmtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileSmtps
//
//
// Virtual server SMTPs traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileSmtps(id string, object LtmProfileSmtps) (*LtmProfileSmtps, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/smtps/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSmtps), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileSmtps")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileSmtps), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileSmtps")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileSmtps)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileSocks
//
//
// Virtual server SOCKS traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileSocks(id string, object LtmProfileSocks) (*LtmProfileSocks, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/socks/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSocks), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileSocks")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileSocks), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileSocks")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileSocks)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileSpdy
//
//
// Virtual server SPDY traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileSpdy(id string, object LtmProfileSpdy) (*LtmProfileSpdy, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/spdy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSpdy), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileSpdy")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileSpdy), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileSpdy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileSpdy)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileStatistics
//
//
// Virtual server custom statistics configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileStatistics(id string, object LtmProfileStatistics) (*LtmProfileStatistics, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/statistics/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileStatistics), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileStatistics")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileStatistics), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileStatistics")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileStatistics)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileStream
//
//
// Virtual server Stream traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileStream(id string, object LtmProfileStream) (*LtmProfileStream, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/stream/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileStream), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileStream")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileStream), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileStream")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileStream)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileTcp
//
//
// Virtual server TCP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileTcp(id string, object LtmProfileTcp) (*LtmProfileTcp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/tcp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileTcp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileTcp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileTcp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileTcp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileTcp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileTftp
//
//
// Virtual server TFTP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileTftp(id string, object LtmProfileTftp) (*LtmProfileTftp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/tftp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileTftp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileTftp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileTftp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileTftp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileTftp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileUdp
//
//
// Virtual server UDP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileUdp(id string, object LtmProfileUdp) (*LtmProfileUdp, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/udp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileUdp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileUdp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileUdp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileUdp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileUdp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileWebAcceleration
//
//
// Virtual server Web Acceleration profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileWebAcceleration(id string, object LtmProfileWebAcceleration) (*LtmProfileWebAcceleration, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/webAcceleration/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileWebAcceleration), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileWebAcceleration")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileWebAcceleration), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileWebAcceleration")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileWebAcceleration)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileWebSecurity
//
//
// Virtual server Web Security profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileWebSecurity(id string, object LtmProfileWebSecurity) (*LtmProfileWebSecurity, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/webSecurity/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileWebSecurity), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileWebSecurity")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileWebSecurity), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileWebSecurity")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileWebSecurity)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostProfileXml
//
//
// Virtual server XML configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostProfileXml(id string, object LtmProfileXml) (*LtmProfileXml, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/xml/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileXml), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostProfileXml")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileXml), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostProfileXml")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileXml)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostRule
//
//
// iRules configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostRule(id string, object LtmRule) (*LtmRule, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/rule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmRule), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostRule")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmRule), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostRule")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmRule)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostSnat
//
//
// Secure network address translation (SNAT) configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostSnat(id string, object LtmSnat) (*LtmSnat, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/snat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmSnat), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostSnat")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmSnat), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostSnat")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmSnat)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostSnatTranslation
//
//
// SNAT translation address configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostSnatTranslation(id string, object LtmSnatTranslation) (*LtmSnatTranslation, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/snatTranslation/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmSnatTranslation), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostSnatTranslation")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmSnatTranslation), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostSnatTranslation")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmSnatTranslation)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostSnatpool
//
//
// Collections of SNAT translation addresses.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostSnatpool(id string, object LtmSnatpool) (*LtmSnatpool, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/snatpool/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmSnatpool), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostSnatpool")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmSnatpool), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostSnatpool")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmSnatpool)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostTacdbCustomdb
//
//
// Custom tacdb for detection of device type and OS..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostTacdbCustomdb(id string, object LtmTacdbCustomdb) (*LtmTacdbCustomdb, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/tacdb/customdb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmTacdbCustomdb), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostTacdbCustomdb")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmTacdbCustomdb), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostTacdbCustomdb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmTacdbCustomdb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostTacdbCustomdbFile
//
//
// File object for custom tacdb. User should NOT use it. Daemon use it internally..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostTacdbCustomdbFile(id string, object LtmTacdbCustomdbFile) (*LtmTacdbCustomdbFile, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/tacdb/customdbFile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmTacdbCustomdbFile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostTacdbCustomdbFile")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmTacdbCustomdbFile), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostTacdbCustomdbFile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmTacdbCustomdbFile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostTrafficClass
//
//
// Traffic Class Configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostTrafficClass(id string, object LtmTrafficClass) (*LtmTrafficClass, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/trafficClass/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmTrafficClass), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostTrafficClass")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmTrafficClass), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostTrafficClass")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmTrafficClass)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostVirtual
//
//
// Virtual server configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostVirtual(id string, object LtmVirtual) (*LtmVirtual, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmVirtual), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostVirtual")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmVirtual), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostVirtual")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmVirtual)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostVirtualAddress
//
//
// Virtual server IP address configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostVirtualAddress(id string, object LtmVirtualAddress) (*LtmVirtualAddress, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtualAddress/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmVirtualAddress), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostVirtualAddress")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmVirtualAddress), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostVirtualAddress")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmVirtualAddress)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostVirtualFwEnforcedPolicyRules
//
//
// Firewall policy rule entry.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostVirtualFwEnforcedPolicyRules(id string, object LtmVirtualFwEnforcedPolicyRules) (*LtmVirtualFwEnforcedPolicyRules, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/fwEnforcedPolicyRules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmVirtualFwEnforcedPolicyRules), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostVirtualFwEnforcedPolicyRules")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmVirtualFwEnforcedPolicyRules), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostVirtualFwEnforcedPolicyRules")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmVirtualFwEnforcedPolicyRules)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostVirtualFwStagedPolicyRules
//
//
// Firewall policy rule entry.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostVirtualFwStagedPolicyRules(id string, object LtmVirtualFwStagedPolicyRules) (*LtmVirtualFwStagedPolicyRules, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/fwStagedPolicyRules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmVirtualFwStagedPolicyRules), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostVirtualFwStagedPolicyRules")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmVirtualFwStagedPolicyRules), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostVirtualFwStagedPolicyRules")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmVirtualFwStagedPolicyRules)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostVirtualPolicies
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostVirtualPolicies(id string, object LtmVirtualPolicies) (*LtmVirtualPolicies, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/policies/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmVirtualPolicies), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostVirtualPolicies")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmVirtualPolicies), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostVirtualPolicies")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmVirtualPolicies)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PostVirtualProfiles
//
//
// Manage the set of profiles that are associated with virtual servers.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PostVirtualProfiles(id string, object LtmVirtualProfiles) (*LtmVirtualProfiles, *APIResponse, error) {

	var httpMethod = "Post"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/profiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmVirtualProfiles), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PostVirtualProfiles")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmVirtualProfiles), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PostVirtualProfiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmVirtualProfiles)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutAlgLogProfile
//
//
// Defines the configuration for logging of ALG flows..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutAlgLogProfile(id string, object LtmAlgLogProfile) (*LtmAlgLogProfile, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/algLogProfile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAlgLogProfile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutAlgLogProfile")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAlgLogProfile), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutAlgLogProfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAlgLogProfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutAuthCrldpServer
//
//
// Certificate Revocation List Distribution Point (CRDLP) server configuration, for use with a CRLDP authentication profile.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutAuthCrldpServer(id string, object LtmAuthCrldpServer) (*LtmAuthCrldpServer, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/crldpServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthCrldpServer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutAuthCrldpServer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthCrldpServer), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutAuthCrldpServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthCrldpServer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutAuthKerberosDelegation
//
//
// Kerberos configuration for remote client authentication.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutAuthKerberosDelegation(id string, object LtmAuthKerberosDelegation) (*LtmAuthKerberosDelegation, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/kerberosDelegation/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthKerberosDelegation), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutAuthKerberosDelegation")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthKerberosDelegation), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutAuthKerberosDelegation")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthKerberosDelegation)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutAuthLdap
//
//
// LDAP configuration for remote LDAP client authentication.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutAuthLdap(id string, object LtmAuthLdap) (*LtmAuthLdap, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/ldap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthLdap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutAuthLdap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthLdap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutAuthLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthLdap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutAuthOcspResponder
//
//
// Online Certificate System Protocol (OCSP) responder configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutAuthOcspResponder(id string, object LtmAuthOcspResponder) (*LtmAuthOcspResponder, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/ocspResponder/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthOcspResponder), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutAuthOcspResponder")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthOcspResponder), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutAuthOcspResponder")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthOcspResponder)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutAuthProfile
//
//
// Virtual server traffic Authentication profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutAuthProfile(id string, object LtmAuthProfile) (*LtmAuthProfile, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/profile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthProfile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutAuthProfile")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthProfile), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutAuthProfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthProfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutAuthRadius
//
//
// RADIUS configuration for remote RADIUS client authentication.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutAuthRadius(id string, object LtmAuthRadius) (*LtmAuthRadius, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/radius/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthRadius), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutAuthRadius")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthRadius), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutAuthRadius")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthRadius)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutAuthRadiusServer
//
//
// RADIUS server configuration for use with RADIUS authentication profiles.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutAuthRadiusServer(id string, object LtmAuthRadiusServer) (*LtmAuthRadiusServer, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/radiusServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthRadiusServer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutAuthRadiusServer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthRadiusServer), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutAuthRadiusServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthRadiusServer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutAuthSslCcLdap
//
//
// SSL client certificate configuration, for use with remote SSL-based LDAP authorization.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutAuthSslCcLdap(id string, object LtmAuthSslCcLdap) (*LtmAuthSslCcLdap, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/sslCcLdap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthSslCcLdap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutAuthSslCcLdap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthSslCcLdap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutAuthSslCcLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthSslCcLdap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutAuthSslCrldp
//
//
// SSL client certificate configuration, for use with remote SSL-based CRLDP authorization.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutAuthSslCrldp(id string, object LtmAuthSslCrldp) (*LtmAuthSslCrldp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/sslCrldp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthSslCrldp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutAuthSslCrldp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthSslCrldp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutAuthSslCrldp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthSslCrldp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutAuthSslOcsp
//
//
// OCSP configuration for implementing remote OCSP-based client authentication.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutAuthSslOcsp(id string, object LtmAuthSslOcsp) (*LtmAuthSslOcsp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/sslOcsp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthSslOcsp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutAuthSslOcsp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthSslOcsp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutAuthSslOcsp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthSslOcsp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutAuthTacacs
//
//
// TACACS+ configuration for remote TACACS+ client authentication.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutAuthTacacs(id string, object LtmAuthTacacs) (*LtmAuthTacacs, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/auth/tacacs/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmAuthTacacs), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutAuthTacacs")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmAuthTacacs), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutAuthTacacs")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmAuthTacacs)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutClassificationApplication
//
//
// Traffic Classification Application.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutClassificationApplication(id string, object LtmClassificationApplication) (*LtmClassificationApplication, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/application/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationApplication), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutClassificationApplication")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationApplication), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutClassificationApplication")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationApplication)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutClassificationCategory
//
//
// Traffic Classification Category.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutClassificationCategory(id string, object LtmClassificationCategory) (*LtmClassificationCategory, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/category/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationCategory), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutClassificationCategory")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationCategory), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutClassificationCategory")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationCategory)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutClassificationSignatureUpdateSchedule
//
//
// Configure scheduling for classification signature updates..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutClassificationSignatureUpdateSchedule(id string, object LtmClassificationSignatureUpdateSchedule) (*LtmClassificationSignatureUpdateSchedule, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/signatureUpdateSchedule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationSignatureUpdateSchedule), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutClassificationSignatureUpdateSchedule")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationSignatureUpdateSchedule), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutClassificationSignatureUpdateSchedule")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationSignatureUpdateSchedule)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutClassificationSignatureVersion
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutClassificationSignatureVersion(id string, object LtmClassificationSignatureVersion) (*LtmClassificationSignatureVersion, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/signatureVersion/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationSignatureVersion), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutClassificationSignatureVersion")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationSignatureVersion), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutClassificationSignatureVersion")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationSignatureVersion)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutClassificationUrlCatPolicy
//
//
// URL Categorization policy.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutClassificationUrlCatPolicy(id string, object LtmClassificationUrlCatPolicy) (*LtmClassificationUrlCatPolicy, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urlCatPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationUrlCatPolicy), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutClassificationUrlCatPolicy")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationUrlCatPolicy), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutClassificationUrlCatPolicy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationUrlCatPolicy)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutClassificationUrlCategory
//
//
// URL Classification Category.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutClassificationUrlCategory(id string, object LtmClassificationUrlCategory) (*LtmClassificationUrlCategory, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urlCategory/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationUrlCategory), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutClassificationUrlCategory")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationUrlCategory), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutClassificationUrlCategory")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationUrlCategory)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutClassificationUrldbFeedList
//
//
// Reusable URLDB feed lists for URL Categorization..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutClassificationUrldbFeedList(id string, object LtmClassificationUrldbFeedList) (*LtmClassificationUrldbFeedList, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urldbFeedList/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationUrldbFeedList), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutClassificationUrldbFeedList")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationUrldbFeedList), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutClassificationUrldbFeedList")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationUrldbFeedList)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutClassificationUrldbFile
//
//
// File object for custom url category database..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutClassificationUrldbFile(id string, object LtmClassificationUrldbFile) (*LtmClassificationUrldbFile, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/classification/urldbFile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmClassificationUrldbFile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutClassificationUrldbFile")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmClassificationUrldbFile), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutClassificationUrldbFile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmClassificationUrldbFile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDataGroupExternal
//
//
// External data group configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutDataGroupExternal(id string, object LtmDataGroupExternal) (*LtmDataGroupExternal, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dataGroup/external/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDataGroupExternal), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutDataGroupExternal")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDataGroupExternal), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutDataGroupExternal")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDataGroupExternal)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDataGroupInternal
//
//
// Internal data group configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutDataGroupInternal(id string, object LtmDataGroupInternal) (*LtmDataGroupInternal, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dataGroup/internal/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDataGroupInternal), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutDataGroupInternal")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDataGroupInternal), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutDataGroupInternal")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDataGroupInternal)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDefaultNodeMonitor
//
//
// Configure the default-monitor rule.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutDefaultNodeMonitor(id string, object LtmDefaultNodeMonitor) (*LtmDefaultNodeMonitor, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/defaultNodeMonitor/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDefaultNodeMonitor), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutDefaultNodeMonitor")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDefaultNodeMonitor), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutDefaultNodeMonitor")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDefaultNodeMonitor)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDnsAnalyticsGlobalSettings
//
//
// AVR DNS statistics global settings affecting all DNS listeners..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutDnsAnalyticsGlobalSettings(id string, object LtmDnsAnalyticsGlobalSettings) (*LtmDnsAnalyticsGlobalSettings, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/analytics/globalSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsAnalyticsGlobalSettings), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutDnsAnalyticsGlobalSettings")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsAnalyticsGlobalSettings), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutDnsAnalyticsGlobalSettings")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsAnalyticsGlobalSettings)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDnsCacheGlobalSettings
//
//
// DNS Cache global settings affecting all caches..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutDnsCacheGlobalSettings(id string, object LtmDnsCacheGlobalSettings) (*LtmDnsCacheGlobalSettings, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/globalSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsCacheGlobalSettings), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutDnsCacheGlobalSettings")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsCacheGlobalSettings), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutDnsCacheGlobalSettings")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsCacheGlobalSettings)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDnsCacheResolver
//
//
// DNS Cache with recursive resolver..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutDnsCacheResolver(id string, object LtmDnsCacheResolver) (*LtmDnsCacheResolver, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/resolver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsCacheResolver), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutDnsCacheResolver")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsCacheResolver), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutDnsCacheResolver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsCacheResolver)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDnsCacheTransparent
//
//
// DNS Cache without a resolver (responses from serverside cached)..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutDnsCacheTransparent(id string, object LtmDnsCacheTransparent) (*LtmDnsCacheTransparent, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/transparent/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsCacheTransparent), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutDnsCacheTransparent")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsCacheTransparent), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutDnsCacheTransparent")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsCacheTransparent)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDnsCacheValidatingResolver
//
//
// DNS Cache with recursive resolver and DNSSEC validation..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutDnsCacheValidatingResolver(id string, object LtmDnsCacheValidatingResolver) (*LtmDnsCacheValidatingResolver, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/cache/validatingResolver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsCacheValidatingResolver), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutDnsCacheValidatingResolver")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsCacheValidatingResolver), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutDnsCacheValidatingResolver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsCacheValidatingResolver)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDnsDnssecKey
//
//
// DNSSEC key configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutDnsDnssecKey(id string, object LtmDnsDnssecKey) (*LtmDnsDnssecKey, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/dnssec/key/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsDnssecKey), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutDnsDnssecKey")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsDnssecKey), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutDnsDnssecKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsDnssecKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDnsDnssecKeyTmGeneration
//
//
// DNSSEC key generation configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutDnsDnssecKeyTmGeneration(id string, object LtmDnsDnssecKeyTmGeneration) (*LtmDnsDnssecKeyTmGeneration, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/dnssec/key/tmGeneration/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsDnssecKeyTmGeneration), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutDnsDnssecKeyTmGeneration")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsDnssecKeyTmGeneration), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutDnsDnssecKeyTmGeneration")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsDnssecKeyTmGeneration)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDnsDnssecZone
//
//
// DNSSEC zone configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutDnsDnssecZone(id string, object LtmDnsDnssecZone) (*LtmDnsDnssecZone, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/dnssec/zone/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsDnssecZone), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutDnsDnssecZone")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsDnssecZone), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutDnsDnssecZone")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsDnssecZone)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDnsNameserver
//
//
// DNS nameserver configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutDnsNameserver(id string, object LtmDnsNameserver) (*LtmDnsNameserver, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/nameserver/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsNameserver), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutDnsNameserver")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsNameserver), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutDnsNameserver")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsNameserver)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDnsTsigKey
//
//
// TSIG Key configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutDnsTsigKey(id string, object LtmDnsTsigKey) (*LtmDnsTsigKey, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/tsigKey/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsTsigKey), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutDnsTsigKey")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsTsigKey), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutDnsTsigKey")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsTsigKey)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutDnsZone
//
//
// Zone configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutDnsZone(id string, object LtmDnsZone) (*LtmDnsZone, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/dns/zone/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmDnsZone), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutDnsZone")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmDnsZone), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutDnsZone")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmDnsZone)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutEvictionPolicy
//
//
// Defines an eviction policy, used to select which flows to evict when approaching limits..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutEvictionPolicy(id string, object LtmEvictionPolicy) (*LtmEvictionPolicy, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/evictionPolicy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmEvictionPolicy), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutEvictionPolicy")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmEvictionPolicy), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutEvictionPolicy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmEvictionPolicy)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutGlobalSettingsConnection
//
//
// General configuration options for connections.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutGlobalSettingsConnection(id string, object LtmGlobalSettingsConnection) (*LtmGlobalSettingsConnection, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/globalSettings/connection/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmGlobalSettingsConnection), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutGlobalSettingsConnection")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmGlobalSettingsConnection), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutGlobalSettingsConnection")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmGlobalSettingsConnection)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutGlobalSettingsGeneral
//
//
// General configuration options.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutGlobalSettingsGeneral(id string, object LtmGlobalSettingsGeneral) (*LtmGlobalSettingsGeneral, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/globalSettings/general/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmGlobalSettingsGeneral), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutGlobalSettingsGeneral")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmGlobalSettingsGeneral), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutGlobalSettingsGeneral")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmGlobalSettingsGeneral)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutGlobalSettingsTrafficControl
//
//
// General configuration options for traffic.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutGlobalSettingsTrafficControl(id string, object LtmGlobalSettingsTrafficControl) (*LtmGlobalSettingsTrafficControl, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/globalSettings/trafficControl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmGlobalSettingsTrafficControl), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutGlobalSettingsTrafficControl")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmGlobalSettingsTrafficControl), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutGlobalSettingsTrafficControl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmGlobalSettingsTrafficControl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutHtmlRuleCommentRaiseEvent
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutHtmlRuleCommentRaiseEvent(id string, object LtmHtmlRuleCommentRaiseEvent) (*LtmHtmlRuleCommentRaiseEvent, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/commentRaiseEvent/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleCommentRaiseEvent), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutHtmlRuleCommentRaiseEvent")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmHtmlRuleCommentRaiseEvent), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutHtmlRuleCommentRaiseEvent")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmHtmlRuleCommentRaiseEvent)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutHtmlRuleCommentRemove
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutHtmlRuleCommentRemove(id string, object LtmHtmlRuleCommentRemove) (*LtmHtmlRuleCommentRemove, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/commentRemove/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleCommentRemove), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutHtmlRuleCommentRemove")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmHtmlRuleCommentRemove), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutHtmlRuleCommentRemove")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmHtmlRuleCommentRemove)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutHtmlRuleTagAppendHtml
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutHtmlRuleTagAppendHtml(id string, object LtmHtmlRuleTagAppendHtml) (*LtmHtmlRuleTagAppendHtml, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagAppendHtml/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleTagAppendHtml), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutHtmlRuleTagAppendHtml")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmHtmlRuleTagAppendHtml), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutHtmlRuleTagAppendHtml")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmHtmlRuleTagAppendHtml)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutHtmlRuleTagPrependHtml
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutHtmlRuleTagPrependHtml(id string, object LtmHtmlRuleTagPrependHtml) (*LtmHtmlRuleTagPrependHtml, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagPrependHtml/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleTagPrependHtml), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutHtmlRuleTagPrependHtml")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmHtmlRuleTagPrependHtml), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutHtmlRuleTagPrependHtml")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmHtmlRuleTagPrependHtml)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutHtmlRuleTagRaiseEvent
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutHtmlRuleTagRaiseEvent(id string, object LtmHtmlRuleTagRaiseEvent) (*LtmHtmlRuleTagRaiseEvent, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagRaiseEvent/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleTagRaiseEvent), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutHtmlRuleTagRaiseEvent")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmHtmlRuleTagRaiseEvent), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutHtmlRuleTagRaiseEvent")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmHtmlRuleTagRaiseEvent)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutHtmlRuleTagRemove
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutHtmlRuleTagRemove(id string, object LtmHtmlRuleTagRemove) (*LtmHtmlRuleTagRemove, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagRemove/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleTagRemove), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutHtmlRuleTagRemove")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmHtmlRuleTagRemove), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutHtmlRuleTagRemove")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmHtmlRuleTagRemove)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutHtmlRuleTagRemoveAttribute
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutHtmlRuleTagRemoveAttribute(id string, object LtmHtmlRuleTagRemoveAttribute) (*LtmHtmlRuleTagRemoveAttribute, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/htmlRule/tagRemoveAttribute/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmHtmlRuleTagRemoveAttribute), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutHtmlRuleTagRemoveAttribute")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmHtmlRuleTagRemoveAttribute), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutHtmlRuleTagRemoveAttribute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmHtmlRuleTagRemoveAttribute)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutIfile
//
//
// iFile Configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutIfile(id string, object LtmIfile) (*LtmIfile, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/ifile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmIfile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutIfile")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmIfile), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutIfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmIfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutLsnLogProfile
//
//
// Defines the configuration for logging of LSN flows..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutLsnLogProfile(id string, object LtmLsnLogProfile) (*LtmLsnLogProfile, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/lsnLogProfile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmLsnLogProfile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutLsnLogProfile")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmLsnLogProfile), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutLsnLogProfile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmLsnLogProfile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutLsnPool
//
//
// LSNAT/CGNAT translation address configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutLsnPool(id string, object LtmLsnPool) (*LtmLsnPool, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/lsnPool/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmLsnPool), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutLsnPool")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmLsnPool), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutLsnPool")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmLsnPool)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMessageRoutingDiameterPeer
//
//
// Peed for routing generic message protocol messages..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMessageRoutingDiameterPeer(id string, object LtmMessageRoutingDiameterPeer) (*LtmMessageRoutingDiameterPeer, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/peer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterPeer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMessageRoutingDiameterPeer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingDiameterPeer), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMessageRoutingDiameterPeer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingDiameterPeer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMessageRoutingDiameterProfileRouter
//
//
// Configures a Diameter Router profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMessageRoutingDiameterProfileRouter(id string, object LtmMessageRoutingDiameterProfileRouter) (*LtmMessageRoutingDiameterProfileRouter, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/profile/router/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterProfileRouter), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMessageRoutingDiameterProfileRouter")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingDiameterProfileRouter), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMessageRoutingDiameterProfileRouter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingDiameterProfileRouter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMessageRoutingDiameterProfileSession
//
//
// Configures a Diameter Session profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMessageRoutingDiameterProfileSession(id string, object LtmMessageRoutingDiameterProfileSession) (*LtmMessageRoutingDiameterProfileSession, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/profile/session/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterProfileSession), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMessageRoutingDiameterProfileSession")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingDiameterProfileSession), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMessageRoutingDiameterProfileSession")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingDiameterProfileSession)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMessageRoutingDiameterRoute
//
//
// Configures a static route for use in Diameter message routing..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMessageRoutingDiameterRoute(id string, object LtmMessageRoutingDiameterRoute) (*LtmMessageRoutingDiameterRoute, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/route/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterRoute), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMessageRoutingDiameterRoute")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingDiameterRoute), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMessageRoutingDiameterRoute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingDiameterRoute)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMessageRoutingDiameterTransportConfig
//
//
// Defines the configuration for an outgoing connection..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMessageRoutingDiameterTransportConfig(id string, object LtmMessageRoutingDiameterTransportConfig) (*LtmMessageRoutingDiameterTransportConfig, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/transportConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterTransportConfig), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMessageRoutingDiameterTransportConfig")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingDiameterTransportConfig), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMessageRoutingDiameterTransportConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingDiameterTransportConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMessageRoutingDiameterTransportConfigProfiles
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMessageRoutingDiameterTransportConfigProfiles(id string, object LtmMessageRoutingDiameterTransportConfigProfiles) (*LtmMessageRoutingDiameterTransportConfigProfiles, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/diameter/transportConfig/profiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingDiameterTransportConfigProfiles), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMessageRoutingDiameterTransportConfigProfiles")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingDiameterTransportConfigProfiles), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMessageRoutingDiameterTransportConfigProfiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingDiameterTransportConfigProfiles)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMessageRoutingGenericPeer
//
//
// Peed for routing generic message protocol messages..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMessageRoutingGenericPeer(id string, object LtmMessageRoutingGenericPeer) (*LtmMessageRoutingGenericPeer, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/peer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericPeer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMessageRoutingGenericPeer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingGenericPeer), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMessageRoutingGenericPeer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingGenericPeer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMessageRoutingGenericProtocol
//
//
// Generic message parser for use with the message routing framework..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMessageRoutingGenericProtocol(id string, object LtmMessageRoutingGenericProtocol) (*LtmMessageRoutingGenericProtocol, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/protocol/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericProtocol), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMessageRoutingGenericProtocol")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingGenericProtocol), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMessageRoutingGenericProtocol")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingGenericProtocol)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMessageRoutingGenericRoute
//
//
// Static route for routing generic message protocol messages..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMessageRoutingGenericRoute(id string, object LtmMessageRoutingGenericRoute) (*LtmMessageRoutingGenericRoute, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/route/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericRoute), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMessageRoutingGenericRoute")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingGenericRoute), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMessageRoutingGenericRoute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingGenericRoute)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMessageRoutingGenericRouter
//
//
// Message routing instance for generic message protocol..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMessageRoutingGenericRouter(id string, object LtmMessageRoutingGenericRouter) (*LtmMessageRoutingGenericRouter, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/router/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericRouter), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMessageRoutingGenericRouter")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingGenericRouter), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMessageRoutingGenericRouter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingGenericRouter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMessageRoutingGenericTransportConfig
//
//
// Defines the configuration for an outgoing connection..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMessageRoutingGenericTransportConfig(id string, object LtmMessageRoutingGenericTransportConfig) (*LtmMessageRoutingGenericTransportConfig, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/transportConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericTransportConfig), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMessageRoutingGenericTransportConfig")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingGenericTransportConfig), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMessageRoutingGenericTransportConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingGenericTransportConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMessageRoutingGenericTransportConfigProfiles
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMessageRoutingGenericTransportConfigProfiles(id string, object LtmMessageRoutingGenericTransportConfigProfiles) (*LtmMessageRoutingGenericTransportConfigProfiles, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/generic/transportConfig/profiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingGenericTransportConfigProfiles), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMessageRoutingGenericTransportConfigProfiles")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingGenericTransportConfigProfiles), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMessageRoutingGenericTransportConfigProfiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingGenericTransportConfigProfiles)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMessageRoutingSipPeer
//
//
// Peed for routing generic message protocol messages..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMessageRoutingSipPeer(id string, object LtmMessageRoutingSipPeer) (*LtmMessageRoutingSipPeer, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/peer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipPeer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMessageRoutingSipPeer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingSipPeer), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMessageRoutingSipPeer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingSipPeer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMessageRoutingSipProfileRouter
//
//
// Configures a Session Initiation Protocol (SIP) Router profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMessageRoutingSipProfileRouter(id string, object LtmMessageRoutingSipProfileRouter) (*LtmMessageRoutingSipProfileRouter, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/profile/router/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipProfileRouter), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMessageRoutingSipProfileRouter")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingSipProfileRouter), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMessageRoutingSipProfileRouter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingSipProfileRouter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMessageRoutingSipProfileSession
//
//
// Configures a Session Initiation Protocol (SIP) Session profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMessageRoutingSipProfileSession(id string, object LtmMessageRoutingSipProfileSession) (*LtmMessageRoutingSipProfileSession, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/profile/session/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipProfileSession), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMessageRoutingSipProfileSession")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingSipProfileSession), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMessageRoutingSipProfileSession")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingSipProfileSession)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMessageRoutingSipRoute
//
//
// Configures a static route for use in Session Initiation Protocol (SIP) message routing..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMessageRoutingSipRoute(id string, object LtmMessageRoutingSipRoute) (*LtmMessageRoutingSipRoute, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/route/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipRoute), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMessageRoutingSipRoute")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingSipRoute), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMessageRoutingSipRoute")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingSipRoute)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMessageRoutingSipTransportConfig
//
//
// Defines the configuration for an outgoing connection..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMessageRoutingSipTransportConfig(id string, object LtmMessageRoutingSipTransportConfig) (*LtmMessageRoutingSipTransportConfig, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/transportConfig/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipTransportConfig), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMessageRoutingSipTransportConfig")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingSipTransportConfig), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMessageRoutingSipTransportConfig")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingSipTransportConfig)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMessageRoutingSipTransportConfigProfiles
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMessageRoutingSipTransportConfigProfiles(id string, object LtmMessageRoutingSipTransportConfigProfiles) (*LtmMessageRoutingSipTransportConfigProfiles, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/messageRouting/sip/transportConfig/profiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMessageRoutingSipTransportConfigProfiles), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMessageRoutingSipTransportConfigProfiles")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMessageRoutingSipTransportConfigProfiles), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMessageRoutingSipTransportConfigProfiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMessageRoutingSipTransportConfigProfiles)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorDiameter
//
//
// Diameter monitor configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorDiameter(id string, object LtmMonitorDiameter) (*LtmMonitorDiameter, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/diameter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorDiameter), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorDiameter")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorDiameter), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorDiameter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorDiameter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorDns
//
//
// DNS monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorDns(id string, object LtmMonitorDns) (*LtmMonitorDns, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/dns/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorDns), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorDns")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorDns), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorDns")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorDns)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorExternal
//
//
// External monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorExternal(id string, object LtmMonitorExternal) (*LtmMonitorExternal, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/external/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorExternal), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorExternal")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorExternal), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorExternal")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorExternal)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorFirepass
//
//
// Firepass monitor configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorFirepass(id string, object LtmMonitorFirepass) (*LtmMonitorFirepass, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/firepass/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorFirepass), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorFirepass")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorFirepass), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorFirepass")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorFirepass)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorFtp
//
//
// FTP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorFtp(id string, object LtmMonitorFtp) (*LtmMonitorFtp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/ftp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorFtp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorFtp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorFtp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorFtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorFtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorGatewayIcmp
//
//
// Gateway ICMP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorGatewayIcmp(id string, object LtmMonitorGatewayIcmp) (*LtmMonitorGatewayIcmp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/gatewayIcmp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorGatewayIcmp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorGatewayIcmp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorGatewayIcmp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorGatewayIcmp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorGatewayIcmp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorHttp
//
//
// HTTP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorHttp(id string, object LtmMonitorHttp) (*LtmMonitorHttp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/http/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorHttp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorHttp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorHttp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorHttp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorHttp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorHttps
//
//
// HTTPS monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorHttps(id string, object LtmMonitorHttps) (*LtmMonitorHttps, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/https/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorHttps), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorHttps")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorHttps), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorHttps")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorHttps)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorIcmp
//
//
// ICMP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorIcmp(id string, object LtmMonitorIcmp) (*LtmMonitorIcmp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/icmp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorIcmp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorIcmp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorIcmp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorIcmp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorIcmp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorImap
//
//
// IMAP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorImap(id string, object LtmMonitorImap) (*LtmMonitorImap, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/imap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorImap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorImap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorImap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorImap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorImap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorInband
//
//
// Inband monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorInband(id string, object LtmMonitorInband) (*LtmMonitorInband, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/inband/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorInband), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorInband")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorInband), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorInband")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorInband)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorLdap
//
//
// LDAP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorLdap(id string, object LtmMonitorLdap) (*LtmMonitorLdap, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/ldap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorLdap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorLdap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorLdap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorLdap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorModuleScore
//
//
// Module score monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorModuleScore(id string, object LtmMonitorModuleScore) (*LtmMonitorModuleScore, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/moduleScore/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorModuleScore), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorModuleScore")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorModuleScore), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorModuleScore")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorModuleScore)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorMssql
//
//
// MSSQL monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorMssql(id string, object LtmMonitorMssql) (*LtmMonitorMssql, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/mssql/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorMssql), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorMssql")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorMssql), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorMssql")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorMssql)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorMysql
//
//
// MySQL monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorMysql(id string, object LtmMonitorMysql) (*LtmMonitorMysql, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/mysql/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorMysql), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorMysql")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorMysql), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorMysql")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorMysql)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorNntp
//
//
// NNTP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorNntp(id string, object LtmMonitorNntp) (*LtmMonitorNntp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/nntp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorNntp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorNntp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorNntp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorNntp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorNntp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorNone
//
//
// The NULL monitor..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorNone(id string, object LtmMonitorNone) (*LtmMonitorNone, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/none/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorNone), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorNone")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorNone), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorNone")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorNone)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorOracle
//
//
// Oracle monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorOracle(id string, object LtmMonitorOracle) (*LtmMonitorOracle, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/oracle/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorOracle), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorOracle")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorOracle), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorOracle")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorOracle)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorPop3
//
//
// POP3 monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorPop3(id string, object LtmMonitorPop3) (*LtmMonitorPop3, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/pop3/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorPop3), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorPop3")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorPop3), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorPop3")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorPop3)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorPostgresql
//
//
// Postgresql monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorPostgresql(id string, object LtmMonitorPostgresql) (*LtmMonitorPostgresql, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/postgresql/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorPostgresql), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorPostgresql")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorPostgresql), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorPostgresql")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorPostgresql)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorRadius
//
//
// Radius monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorRadius(id string, object LtmMonitorRadius) (*LtmMonitorRadius, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/radius/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorRadius), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorRadius")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorRadius), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorRadius")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorRadius)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorRadiusAccounting
//
//
// Radius accounting monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorRadiusAccounting(id string, object LtmMonitorRadiusAccounting) (*LtmMonitorRadiusAccounting, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/radiusAccounting/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorRadiusAccounting), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorRadiusAccounting")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorRadiusAccounting), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorRadiusAccounting")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorRadiusAccounting)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorRealServer
//
//
// Real Server monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorRealServer(id string, object LtmMonitorRealServer) (*LtmMonitorRealServer, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/realServer/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorRealServer), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorRealServer")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorRealServer), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorRealServer")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorRealServer)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorRpc
//
//
// RPC monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorRpc(id string, object LtmMonitorRpc) (*LtmMonitorRpc, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/rpc/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorRpc), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorRpc")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorRpc), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorRpc")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorRpc)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorSasp
//
//
// SASP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorSasp(id string, object LtmMonitorSasp) (*LtmMonitorSasp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/sasp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSasp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorSasp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorSasp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorSasp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorSasp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorScripted
//
//
// Scripted monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorScripted(id string, object LtmMonitorScripted) (*LtmMonitorScripted, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/scripted/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorScripted), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorScripted")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorScripted), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorScripted")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorScripted)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorSip
//
//
// SIP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorSip(id string, object LtmMonitorSip) (*LtmMonitorSip, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/sip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSip), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorSip")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorSip), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorSip")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorSip)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorSmb
//
//
// SMB monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorSmb(id string, object LtmMonitorSmb) (*LtmMonitorSmb, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/smb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSmb), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorSmb")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorSmb), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorSmb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorSmb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorSmtp
//
//
// SMTP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorSmtp(id string, object LtmMonitorSmtp) (*LtmMonitorSmtp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/smtp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSmtp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorSmtp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorSmtp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorSmtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorSmtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorSnmpDca
//
//
// SNMP DCA monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorSnmpDca(id string, object LtmMonitorSnmpDca) (*LtmMonitorSnmpDca, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/snmpDca/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSnmpDca), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorSnmpDca")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorSnmpDca), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorSnmpDca")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorSnmpDca)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorSnmpDcaBase
//
//
// SNMP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorSnmpDcaBase(id string, object LtmMonitorSnmpDcaBase) (*LtmMonitorSnmpDcaBase, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/snmpDcaBase/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSnmpDcaBase), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorSnmpDcaBase")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorSnmpDcaBase), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorSnmpDcaBase")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorSnmpDcaBase)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorSoap
//
//
// SOAP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorSoap(id string, object LtmMonitorSoap) (*LtmMonitorSoap, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/soap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorSoap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorSoap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorSoap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorSoap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorSoap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorTcp
//
//
// TCP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorTcp(id string, object LtmMonitorTcp) (*LtmMonitorTcp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/tcp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorTcp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorTcp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorTcp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorTcp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorTcp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorTcpEcho
//
//
// TCP Echo monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorTcpEcho(id string, object LtmMonitorTcpEcho) (*LtmMonitorTcpEcho, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/tcpEcho/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorTcpEcho), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorTcpEcho")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorTcpEcho), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorTcpEcho")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorTcpEcho)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorTcpHalfOpen
//
//
// TCP Half Open monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorTcpHalfOpen(id string, object LtmMonitorTcpHalfOpen) (*LtmMonitorTcpHalfOpen, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/tcpHalfOpen/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorTcpHalfOpen), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorTcpHalfOpen")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorTcpHalfOpen), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorTcpHalfOpen")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorTcpHalfOpen)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorUdp
//
//
// UDP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorUdp(id string, object LtmMonitorUdp) (*LtmMonitorUdp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/udp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorUdp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorUdp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorUdp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorUdp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorUdp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorVirtualLocation
//
//
// Virtual Location monitor configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorVirtualLocation(id string, object LtmMonitorVirtualLocation) (*LtmMonitorVirtualLocation, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/virtualLocation/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorVirtualLocation), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorVirtualLocation")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorVirtualLocation), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorVirtualLocation")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorVirtualLocation)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorWap
//
//
// WAP monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorWap(id string, object LtmMonitorWap) (*LtmMonitorWap, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/wap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorWap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorWap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorWap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorWap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorWap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutMonitorWmi
//
//
// WMI monitor configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutMonitorWmi(id string, object LtmMonitorWmi) (*LtmMonitorWmi, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/monitor/wmi/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmMonitorWmi), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutMonitorWmi")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmMonitorWmi), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutMonitorWmi")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmMonitorWmi)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutNat
//
//
// Network address translation configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutNat(id string, object LtmNat) (*LtmNat, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/nat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmNat), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutNat")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmNat), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutNat")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmNat)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutNode
//
//
// Node specific pool member configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutNode(id string, object LtmNode) (*LtmNode, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/node/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmNode), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutNode")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmNode), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutNode")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmNode)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutPersistenceCookie
//
//
// Virtual server Cookie persistence profile.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutPersistenceCookie(id string, object LtmPersistenceCookie) (*LtmPersistenceCookie, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/cookie/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceCookie), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutPersistenceCookie")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceCookie), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutPersistenceCookie")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceCookie)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutPersistenceDestAddr
//
//
// Virtual server Destination Address Affinity persistence profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutPersistenceDestAddr(id string, object LtmPersistenceDestAddr) (*LtmPersistenceDestAddr, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/destAddr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceDestAddr), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutPersistenceDestAddr")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceDestAddr), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutPersistenceDestAddr")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceDestAddr)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutPersistenceGlobalSettings
//
//
// Global settings for persistence.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutPersistenceGlobalSettings(id string, object LtmPersistenceGlobalSettings) (*LtmPersistenceGlobalSettings, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/globalSettings/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceGlobalSettings), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutPersistenceGlobalSettings")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceGlobalSettings), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutPersistenceGlobalSettings")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceGlobalSettings)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutPersistenceHash
//
//
// Virtual server Hash persistence profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutPersistenceHash(id string, object LtmPersistenceHash) (*LtmPersistenceHash, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/hash/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceHash), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutPersistenceHash")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceHash), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutPersistenceHash")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceHash)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutPersistenceMsrdp
//
//
// Virtual server Microsoft Remote Desktop (MSRDP) persistence profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutPersistenceMsrdp(id string, object LtmPersistenceMsrdp) (*LtmPersistenceMsrdp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/msrdp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceMsrdp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutPersistenceMsrdp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceMsrdp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutPersistenceMsrdp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceMsrdp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutPersistenceSip
//
//
// Virtual server SIP persistence profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutPersistenceSip(id string, object LtmPersistenceSip) (*LtmPersistenceSip, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/sip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceSip), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutPersistenceSip")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceSip), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutPersistenceSip")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceSip)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutPersistenceSourceAddr
//
//
// Virtual server Source Address persistence profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutPersistenceSourceAddr(id string, object LtmPersistenceSourceAddr) (*LtmPersistenceSourceAddr, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/sourceAddr/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceSourceAddr), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutPersistenceSourceAddr")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceSourceAddr), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutPersistenceSourceAddr")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceSourceAddr)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutPersistenceSsl
//
//
// Virtual server SSL persistence profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutPersistenceSsl(id string, object LtmPersistenceSsl) (*LtmPersistenceSsl, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/ssl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceSsl), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutPersistenceSsl")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceSsl), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutPersistenceSsl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceSsl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutPersistenceUniversal
//
//
// Virtual server Universal persistence profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutPersistenceUniversal(id string, object LtmPersistenceUniversal) (*LtmPersistenceUniversal, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/persistence/universal/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPersistenceUniversal), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutPersistenceUniversal")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPersistenceUniversal), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutPersistenceUniversal")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPersistenceUniversal)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutPolicy
//
//
// Centralized Policy Matching configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutPolicy(id string, object LtmPolicy) (*LtmPolicy, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicy), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutPolicy")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPolicy), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutPolicy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPolicy)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutPolicyRules
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutPolicyRules(id string, object LtmPolicyRules) (*LtmPolicyRules, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/rules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicyRules), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutPolicyRules")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPolicyRules), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutPolicyRules")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPolicyRules)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutPolicyRulesActions
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutPolicyRulesActions(id string, object LtmPolicyRulesActions) (*LtmPolicyRulesActions, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/rules/actions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicyRulesActions), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutPolicyRulesActions")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPolicyRulesActions), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutPolicyRulesActions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPolicyRulesActions)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutPolicyRulesConditions
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutPolicyRulesConditions(id string, object LtmPolicyRulesConditions) (*LtmPolicyRulesConditions, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policy/rules/conditions/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicyRulesConditions), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutPolicyRulesConditions")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPolicyRulesConditions), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutPolicyRulesConditions")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPolicyRulesConditions)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutPolicyStrategy
//
//
// Centralized Policy Matching rule selection strategy.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutPolicyStrategy(id string, object LtmPolicyStrategy) (*LtmPolicyStrategy, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policyStrategy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicyStrategy), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutPolicyStrategy")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPolicyStrategy), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutPolicyStrategy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPolicyStrategy)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutPolicyStrategyOperands
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutPolicyStrategyOperands(id string, object LtmPolicyStrategyOperands) (*LtmPolicyStrategyOperands, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/policyStrategy/operands/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPolicyStrategyOperands), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutPolicyStrategyOperands")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPolicyStrategyOperands), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutPolicyStrategyOperands")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPolicyStrategyOperands)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutPool
//
//
// Load balancing pool configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutPool(id string, object LtmPool) (*LtmPool, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/pool/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPool), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutPool")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPool), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutPool")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPool)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutPoolMembers
//
//
// Manage the set of pool members that are associated with a load balancing pool.
//
// pid is for ID of the parent resource
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutPoolMembers(pid string, id string, object LtmPoolMembers) (*LtmPoolMembers, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/pool/{pid}/members/{id}"
	path = strings.Replace(path, "{"+"pid"+"}", fmt.Sprintf("%v", pid), -1)
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'pid' is set
	if &pid == nil {
		return new(LtmPoolMembers), nil, errors.New("Missing required parameter 'pid' when calling LtmApi->PutPoolMembers")
	}
	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmPoolMembers), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutPoolMembers")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmPoolMembers), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutPoolMembers")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmPoolMembers)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileAnalytics
//
//
// Virtual server analytics profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileAnalytics(id string, object LtmProfileAnalytics) (*LtmProfileAnalytics, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/analytics/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileAnalytics), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileAnalytics")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileAnalytics), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileAnalytics")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileAnalytics)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileAnalyticsAlerts
//
//
// Manage the set of analytics alerts that are associated with an analytics profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileAnalyticsAlerts(id string, object LtmProfileAnalyticsAlerts) (*LtmProfileAnalyticsAlerts, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/analytics/alerts/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileAnalyticsAlerts), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileAnalyticsAlerts")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileAnalyticsAlerts), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileAnalyticsAlerts")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileAnalyticsAlerts)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileAnalyticsTrafficCapture
//
//
// Manage the set of analytics alerts that are associated with an analytics profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileAnalyticsTrafficCapture(id string, object LtmProfileAnalyticsTrafficCapture) (*LtmProfileAnalyticsTrafficCapture, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/analytics/trafficCapture/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileAnalyticsTrafficCapture), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileAnalyticsTrafficCapture")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileAnalyticsTrafficCapture), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileAnalyticsTrafficCapture")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileAnalyticsTrafficCapture)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileCertificateAuthority
//
//
// Virtual server Certificate Authority profile configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileCertificateAuthority(id string, object LtmProfileCertificateAuthority) (*LtmProfileCertificateAuthority, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/certificateAuthority/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileCertificateAuthority), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileCertificateAuthority")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileCertificateAuthority), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileCertificateAuthority")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileCertificateAuthority)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileClassification
//
//
// Virtual server classification profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileClassification(id string, object LtmProfileClassification) (*LtmProfileClassification, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/classification/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileClassification), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileClassification")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileClassification), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileClassification")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileClassification)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileClientLdap
//
//
// Virtual server Client LDAP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileClientLdap(id string, object LtmProfileClientLdap) (*LtmProfileClientLdap, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/clientLdap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileClientLdap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileClientLdap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileClientLdap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileClientLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileClientLdap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileClientSsl
//
//
// Virtual server client-side proxy SSL profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileClientSsl(id string, object LtmProfileClientSsl) (*LtmProfileClientSsl, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/clientSsl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileClientSsl), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileClientSsl")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileClientSsl), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileClientSsl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileClientSsl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileDhcpv4
//
//
// Dynamic Host Configuration Protocol, DHCPv4, profile to manage DHCPv4 network traffic..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileDhcpv4(id string, object LtmProfileDhcpv4) (*LtmProfileDhcpv4, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dhcpv4/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileDhcpv4), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileDhcpv4")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileDhcpv4), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileDhcpv4")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileDhcpv4)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileDhcpv6
//
//
// Dynamic Host Configuration Protocol, DHCPv6, profile to manage DHCPv6 network traffic..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileDhcpv6(id string, object LtmProfileDhcpv6) (*LtmProfileDhcpv6, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dhcpv6/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileDhcpv6), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileDhcpv6")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileDhcpv6), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileDhcpv6")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileDhcpv6)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileDiameter
//
//
// Virtual server Diameter traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileDiameter(id string, object LtmProfileDiameter) (*LtmProfileDiameter, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/diameter/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileDiameter), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileDiameter")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileDiameter), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileDiameter")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileDiameter)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileDns
//
//
// Virtual server DNS traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileDns(id string, object LtmProfileDns) (*LtmProfileDns, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dns/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileDns), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileDns")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileDns), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileDns")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileDns)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileDnsLogging
//
//
// High-speed logging settings for the DNS profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileDnsLogging(id string, object LtmProfileDnsLogging) (*LtmProfileDnsLogging, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/dnsLogging/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileDnsLogging), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileDnsLogging")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileDnsLogging), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileDnsLogging")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileDnsLogging)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileFasthttp
//
//
// Virtual server Fast HTTP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileFasthttp(id string, object LtmProfileFasthttp) (*LtmProfileFasthttp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/fasthttp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileFasthttp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileFasthttp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileFasthttp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileFasthttp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileFasthttp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileFastl4
//
//
// Virtual server FastL4 traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileFastl4(id string, object LtmProfileFastl4) (*LtmProfileFastl4, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/fastl4/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileFastl4), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileFastl4")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileFastl4), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileFastl4")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileFastl4)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileFix
//
//
// Virtual server Financial Information eXchange(FIX) profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileFix(id string, object LtmProfileFix) (*LtmProfileFix, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/fix/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileFix), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileFix")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileFix), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileFix")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileFix)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileFtp
//
//
// Virtual server FTP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileFtp(id string, object LtmProfileFtp) (*LtmProfileFtp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ftp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileFtp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileFtp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileFtp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileFtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileFtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileGtp
//
//
// Virtual server GTP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileGtp(id string, object LtmProfileGtp) (*LtmProfileGtp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/gtp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileGtp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileGtp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileGtp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileGtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileGtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileHtml
//
//
// Virtual server HTML profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileHtml(id string, object LtmProfileHtml) (*LtmProfileHtml, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/html/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileHtml), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileHtml")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileHtml), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileHtml")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileHtml)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileHttp
//
//
// Virtual server HTTP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileHttp(id string, object LtmProfileHttp) (*LtmProfileHttp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/http/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileHttp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileHttp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileHttp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileHttp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileHttp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileHttp2
//
//
// Virtual server HTTP/2 traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileHttp2(id string, object LtmProfileHttp2) (*LtmProfileHttp2, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/http2/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileHttp2), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileHttp2")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileHttp2), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileHttp2")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileHttp2)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileHttpCompression
//
//
// Virtual server HTTP compression profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileHttpCompression(id string, object LtmProfileHttpCompression) (*LtmProfileHttpCompression, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/httpCompression/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileHttpCompression), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileHttpCompression")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileHttpCompression), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileHttpCompression")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileHttpCompression)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileIcap
//
//
// Virtual server Internet Content Adaptation Protocol (ICAP) profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileIcap(id string, object LtmProfileIcap) (*LtmProfileIcap, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/icap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileIcap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileIcap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileIcap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileIcap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileIcap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileIiop
//
//
// Virtual server IIOP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileIiop(id string, object LtmProfileIiop) (*LtmProfileIiop, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/iiop/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileIiop), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileIiop")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileIiop), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileIiop")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileIiop)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileIpother
//
//
// Virtual server IPOTHER for non-TCP and non-UDP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileIpother(id string, object LtmProfileIpother) (*LtmProfileIpother, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ipother/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileIpother), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileIpother")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileIpother), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileIpother")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileIpother)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileMblb
//
//
// MBLB profile configuration (experimental).
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileMblb(id string, object LtmProfileMblb) (*LtmProfileMblb, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/mblb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileMblb), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileMblb")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileMblb), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileMblb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileMblb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileMssql
//
//
// Virtual server MSSQL profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileMssql(id string, object LtmProfileMssql) (*LtmProfileMssql, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/mssql/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileMssql), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileMssql")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileMssql), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileMssql")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileMssql)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileNtlm
//
//
// Virtual server NT Lan Manager profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileNtlm(id string, object LtmProfileNtlm) (*LtmProfileNtlm, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ntlm/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileNtlm), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileNtlm")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileNtlm), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileNtlm")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileNtlm)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileOcspStaplingParams
//
//
// OCSP Stapling Parameters for clientssl profiles. This object should be associated with a cert-key-chain object in a clientssl profile..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileOcspStaplingParams(id string, object LtmProfileOcspStaplingParams) (*LtmProfileOcspStaplingParams, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/ocspStaplingParams/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileOcspStaplingParams), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileOcspStaplingParams")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileOcspStaplingParams), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileOcspStaplingParams")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileOcspStaplingParams)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileOneConnect
//
//
// Virtual server OneConnect profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileOneConnect(id string, object LtmProfileOneConnect) (*LtmProfileOneConnect, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/oneConnect/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileOneConnect), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileOneConnect")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileOneConnect), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileOneConnect")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileOneConnect)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfilePcp
//
//
// LSN Pool PCP configuration profile.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfilePcp(id string, object LtmProfilePcp) (*LtmProfilePcp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/pcp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfilePcp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfilePcp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfilePcp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfilePcp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfilePcp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfilePptp
//
//
// Virtual server Point to Point Tunneling Protocol (PPTP) profile configuration..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfilePptp(id string, object LtmProfilePptp) (*LtmProfilePptp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/pptp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfilePptp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfilePptp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfilePptp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfilePptp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfilePptp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileQoe
//
//
// Virtual server Quality of Experience profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileQoe(id string, object LtmProfileQoe) (*LtmProfileQoe, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/qoe/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileQoe), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileQoe")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileQoe), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileQoe")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileQoe)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileRadius
//
//
// Virtual server Radius traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileRadius(id string, object LtmProfileRadius) (*LtmProfileRadius, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/radius/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRadius), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileRadius")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileRadius), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileRadius")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileRadius)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileRequestAdapt
//
//
// Virtual server HTTP request adaptation profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileRequestAdapt(id string, object LtmProfileRequestAdapt) (*LtmProfileRequestAdapt, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/requestAdapt/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRequestAdapt), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileRequestAdapt")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileRequestAdapt), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileRequestAdapt")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileRequestAdapt)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileRequestLog
//
//
// Virtual server request logging profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileRequestLog(id string, object LtmProfileRequestLog) (*LtmProfileRequestLog, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/requestLog/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRequestLog), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileRequestLog")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileRequestLog), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileRequestLog")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileRequestLog)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileResponseAdapt
//
//
// Virtual server HTTP response adaptation profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileResponseAdapt(id string, object LtmProfileResponseAdapt) (*LtmProfileResponseAdapt, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/responseAdapt/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileResponseAdapt), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileResponseAdapt")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileResponseAdapt), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileResponseAdapt")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileResponseAdapt)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileRewrite
//
//
// Virtual server Rewrite profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileRewrite(id string, object LtmProfileRewrite) (*LtmProfileRewrite, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/rewrite/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRewrite), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileRewrite")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileRewrite), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileRewrite")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileRewrite)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileRewriteUriRules
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileRewriteUriRules(id string, object LtmProfileRewriteUriRules) (*LtmProfileRewriteUriRules, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/rewrite/uriRules/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRewriteUriRules), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileRewriteUriRules")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileRewriteUriRules), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileRewriteUriRules")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileRewriteUriRules)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileRtsp
//
//
// Virtual server RTSP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileRtsp(id string, object LtmProfileRtsp) (*LtmProfileRtsp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/rtsp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileRtsp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileRtsp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileRtsp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileRtsp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileRtsp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileSctp
//
//
// Virtual server SCTP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileSctp(id string, object LtmProfileSctp) (*LtmProfileSctp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/sctp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSctp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileSctp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileSctp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileSctp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileSctp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileServerLdap
//
//
// Virtual server Server LDAP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileServerLdap(id string, object LtmProfileServerLdap) (*LtmProfileServerLdap, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/serverLdap/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileServerLdap), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileServerLdap")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileServerLdap), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileServerLdap")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileServerLdap)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileServerSsl
//
//
// Virtual server server-side proxy SSL profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileServerSsl(id string, object LtmProfileServerSsl) (*LtmProfileServerSsl, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/serverSsl/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileServerSsl), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileServerSsl")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileServerSsl), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileServerSsl")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileServerSsl)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileSip
//
//
// Virtual server SIP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileSip(id string, object LtmProfileSip) (*LtmProfileSip, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/sip/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSip), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileSip")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileSip), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileSip")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileSip)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileSmtp
//
//
// Virtual server SMTP profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileSmtp(id string, object LtmProfileSmtp) (*LtmProfileSmtp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/smtp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSmtp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileSmtp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileSmtp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileSmtp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileSmtp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileSmtps
//
//
// Virtual server SMTPs traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileSmtps(id string, object LtmProfileSmtps) (*LtmProfileSmtps, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/smtps/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSmtps), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileSmtps")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileSmtps), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileSmtps")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileSmtps)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileSocks
//
//
// Virtual server SOCKS traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileSocks(id string, object LtmProfileSocks) (*LtmProfileSocks, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/socks/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSocks), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileSocks")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileSocks), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileSocks")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileSocks)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileSpdy
//
//
// Virtual server SPDY traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileSpdy(id string, object LtmProfileSpdy) (*LtmProfileSpdy, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/spdy/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileSpdy), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileSpdy")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileSpdy), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileSpdy")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileSpdy)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileStatistics
//
//
// Virtual server custom statistics configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileStatistics(id string, object LtmProfileStatistics) (*LtmProfileStatistics, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/statistics/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileStatistics), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileStatistics")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileStatistics), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileStatistics")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileStatistics)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileStream
//
//
// Virtual server Stream traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileStream(id string, object LtmProfileStream) (*LtmProfileStream, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/stream/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileStream), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileStream")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileStream), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileStream")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileStream)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileTcp
//
//
// Virtual server TCP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileTcp(id string, object LtmProfileTcp) (*LtmProfileTcp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/tcp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileTcp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileTcp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileTcp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileTcp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileTcp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileTftp
//
//
// Virtual server TFTP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileTftp(id string, object LtmProfileTftp) (*LtmProfileTftp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/tftp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileTftp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileTftp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileTftp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileTftp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileTftp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileUdp
//
//
// Virtual server UDP traffic profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileUdp(id string, object LtmProfileUdp) (*LtmProfileUdp, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/udp/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileUdp), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileUdp")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileUdp), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileUdp")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileUdp)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileWebAcceleration
//
//
// Virtual server Web Acceleration profile configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileWebAcceleration(id string, object LtmProfileWebAcceleration) (*LtmProfileWebAcceleration, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/webAcceleration/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileWebAcceleration), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileWebAcceleration")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileWebAcceleration), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileWebAcceleration")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileWebAcceleration)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutProfileXml
//
//
// Virtual server XML configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutProfileXml(id string, object LtmProfileXml) (*LtmProfileXml, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/profile/xml/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmProfileXml), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutProfileXml")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmProfileXml), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutProfileXml")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmProfileXml)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutRule
//
//
// iRules configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutRule(id string, object LtmRule) (*LtmRule, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/rule/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmRule), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutRule")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmRule), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutRule")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmRule)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutSnat
//
//
// Secure network address translation (SNAT) configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutSnat(id string, object LtmSnat) (*LtmSnat, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/snat/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmSnat), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutSnat")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmSnat), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutSnat")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmSnat)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutSnatTranslation
//
//
// SNAT translation address configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutSnatTranslation(id string, object LtmSnatTranslation) (*LtmSnatTranslation, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/snatTranslation/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmSnatTranslation), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutSnatTranslation")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmSnatTranslation), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutSnatTranslation")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmSnatTranslation)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutSnatpool
//
//
// Collections of SNAT translation addresses.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutSnatpool(id string, object LtmSnatpool) (*LtmSnatpool, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/snatpool/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmSnatpool), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutSnatpool")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmSnatpool), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutSnatpool")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmSnatpool)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutTacdbCustomdb
//
//
// Custom tacdb for detection of device type and OS..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutTacdbCustomdb(id string, object LtmTacdbCustomdb) (*LtmTacdbCustomdb, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/tacdb/customdb/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmTacdbCustomdb), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutTacdbCustomdb")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmTacdbCustomdb), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutTacdbCustomdb")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmTacdbCustomdb)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutTacdbCustomdbFile
//
//
// File object for custom tacdb. User should NOT use it. Daemon use it internally..
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutTacdbCustomdbFile(id string, object LtmTacdbCustomdbFile) (*LtmTacdbCustomdbFile, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/tacdb/customdbFile/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmTacdbCustomdbFile), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutTacdbCustomdbFile")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmTacdbCustomdbFile), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutTacdbCustomdbFile")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmTacdbCustomdbFile)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutTrafficClass
//
//
// Traffic Class Configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutTrafficClass(id string, object LtmTrafficClass) (*LtmTrafficClass, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/trafficClass/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmTrafficClass), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutTrafficClass")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmTrafficClass), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutTrafficClass")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmTrafficClass)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutVirtual
//
//
// Virtual server configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutVirtual(id string, object LtmVirtual) (*LtmVirtual, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmVirtual), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutVirtual")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmVirtual), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutVirtual")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmVirtual)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutVirtualAddress
//
//
// Virtual server IP address configuration.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutVirtualAddress(id string, object LtmVirtualAddress) (*LtmVirtualAddress, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtualAddress/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmVirtualAddress), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutVirtualAddress")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmVirtualAddress), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutVirtualAddress")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmVirtualAddress)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutVirtualPolicies
//
//
// .
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutVirtualPolicies(id string, object LtmVirtualPolicies) (*LtmVirtualPolicies, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/policies/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmVirtualPolicies), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutVirtualPolicies")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmVirtualPolicies), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutVirtualPolicies")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmVirtualPolicies)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}

// PutVirtualProfiles
//
//
// Manage the set of profiles that are associated with virtual servers.
//
// id is for ID of the resource
//
// object is for .
func (a LtmApi) PutVirtualProfiles(id string, object LtmVirtualProfiles) (*LtmVirtualProfiles, *APIResponse, error) {

	var httpMethod = "Put"
	// create path and map variables
	path := a.configuration.BasePath + "/tm/ltm/virtual/profiles/{id}"
	path = strings.Replace(path, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	// verify the required parameter 'id' is set
	if &id == nil {
		return new(LtmVirtualProfiles), nil, errors.New("Missing required parameter 'id' when calling LtmApi->PutVirtualProfiles")
	}
	// verify the required parameter 'object' is set
	if &object == nil {
		return new(LtmVirtualProfiles), nil, errors.New("Missing required parameter 'object' when calling LtmApi->PutVirtualProfiles")
	}

	headerParams := make(map[string]string)
	queryParams := url.Values{}
	formParams := make(map[string]string)
	var postBody interface{}
	var fileName string
	var fileBytes []byte
	// authentication (token) required

	// set key with prefix in header
	headerParams["X-F5-Auth-Token"] = a.configuration.getAPIKeyWithPrefix("X-F5-Auth-Token")

	// add default headers if any
	for key := range a.configuration.DefaultHeader {
		headerParams[key] = a.configuration.DefaultHeader[key]
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{
		"application/json",
	}

	// set Content-Type header
	localVarHttpContentType := a.configuration.restClient.selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		headerParams["Content-Type"] = localVarHttpContentType
	}
	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{
		"aplication/json",
	}

	// set Accept header
	localVarHttpHeaderAccept := a.configuration.restClient.SelectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		headerParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	postBody = &object

	var successPayload = new(LtmVirtualProfiles)
	httpResponse, err := a.configuration.restClient.callAPI(path, httpMethod, postBody, headerParams, queryParams, formParams, fileName, fileBytes)
	if err != nil {
		return successPayload, NewAPIResponse(httpResponse.RawResponse), err
	}
	err = json.Unmarshal(httpResponse.Body(), &successPayload)
	return successPayload, NewAPIResponse(httpResponse.RawResponse), err
}
